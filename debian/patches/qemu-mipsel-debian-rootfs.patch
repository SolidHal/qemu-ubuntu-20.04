apply patch to fix debian bug #562887, qemu-user-static mipsel emulation not 
working:
http://lists.nongnu.org/archive/html/qemu-devel/2011-07/msg00313.html

Index: qemu-0.14.1.1/linux-user/main.c
===================================================================
--- qemu-0.14.1.1.orig/linux-user/main.c	2011-07-04 19:37:39.000000000 +0200
+++ qemu-0.14.1.1/linux-user/main.c	2011-07-05 10:39:30.000000000 +0200
@@ -1875,7 +1875,7 @@
 	MIPS_SYS(sys_getcwd	, 2)
 	MIPS_SYS(sys_capget	, 2)
 	MIPS_SYS(sys_capset	, 2)	/* 4205 */
-	MIPS_SYS(sys_sigaltstack	, 0)
+	MIPS_SYS(sys_sigaltstack	, 2)
 	MIPS_SYS(sys_sendfile	, 4)
 	MIPS_SYS(sys_ni_syscall	, 0)
 	MIPS_SYS(sys_ni_syscall	, 0)
@@ -1985,6 +1985,20 @@
 	MIPS_SYS(sys_epoll_pwait, 6)
 	MIPS_SYS(sys_ioprio_set, 3)
 	MIPS_SYS(sys_ioprio_get, 2)
+	MIPS_SYS(sys_utimensat, 4)
+	MIPS_SYS(sys_ni_syscall, 0) /* signalfd */
+	MIPS_SYS(sys_ni_syscall, 0) /* timerfd */
+	MIPS_SYS(sys_eventfd, 1)
+	MIPS_SYS(sys_fallocate, 4)
+	MIPS_SYS(sys_ni_syscall, 0) /* timerfd_create */
+	MIPS_SYS(sys_ni_syscall, 0) /* timerfd_gettime */
+	MIPS_SYS(sys_ni_syscall, 0) /* timerfd_settime */
+	MIPS_SYS(sys_ni_syscall, 0) /* signalfd4 */
+	MIPS_SYS(sys_eventfd2, 2)
+	MIPS_SYS(sys_epoll_create1, 1)
+	MIPS_SYS(sys_dup3, 3)
+	MIPS_SYS(sys_pipe2, 2)
+	MIPS_SYS(sys_inotify_init1, 1)
 };
 
 #undef MIPS_SYS
@@ -2053,7 +2067,7 @@
             syscall_num = env->active_tc.gpr[2] - 4000;
             env->active_tc.PC += 4;
             if (syscall_num >= sizeof(mips_syscall_args)) {
-                ret = -ENOSYS;
+                ret = -TARGET_ENOSYS;
             } else {
                 int nb_args;
                 abi_ulong sp_reg;
@@ -2093,6 +2107,8 @@
             break;
         case EXCP_TLBL:
         case EXCP_TLBS:
+        case EXCP_AdEL:
+        case EXCP_AdES:
             info.si_signo = TARGET_SIGSEGV;
             info.si_errno = 0;
             /* XXX: check env->error_code */
Index: qemu-0.14.1.1/linux-user/syscall.c
===================================================================
--- qemu-0.14.1.1.orig/linux-user/syscall.c	2011-07-04 19:37:39.000000000 +0200
+++ qemu-0.14.1.1/linux-user/syscall.c	2011-07-04 19:37:41.000000000 +0200
@@ -933,6 +933,44 @@
         return tswapl(rlim);
 }
 
+static inline int target_to_host_resource(int code)
+{
+    switch (code) {
+    case TARGET_RLIMIT_AS:
+        return RLIMIT_AS;
+    case TARGET_RLIMIT_CORE:
+        return RLIMIT_CORE;
+    case TARGET_RLIMIT_CPU:
+        return RLIMIT_CPU;
+    case TARGET_RLIMIT_DATA:
+        return RLIMIT_DATA;
+    case TARGET_RLIMIT_FSIZE:
+        return RLIMIT_FSIZE;
+    case TARGET_RLIMIT_LOCKS:
+        return RLIMIT_LOCKS;
+    case TARGET_RLIMIT_MEMLOCK:
+        return RLIMIT_MEMLOCK;
+    case TARGET_RLIMIT_MSGQUEUE:
+        return RLIMIT_MSGQUEUE;
+    case TARGET_RLIMIT_NICE:
+        return RLIMIT_NICE;
+    case TARGET_RLIMIT_NOFILE:
+        return RLIMIT_NOFILE;
+    case TARGET_RLIMIT_NPROC:
+        return RLIMIT_NPROC;
+    case TARGET_RLIMIT_RSS:
+        return RLIMIT_RSS;
+    case TARGET_RLIMIT_RTPRIO:
+        return RLIMIT_RTPRIO;
+    case TARGET_RLIMIT_SIGPENDING:
+        return RLIMIT_SIGPENDING;
+    case TARGET_RLIMIT_STACK:
+        return RLIMIT_STACK;
+    default:
+        return code;
+    }
+}
+
 static inline abi_long copy_from_user_timeval(struct timeval *tv,
                                               abi_ulong target_tv_addr)
 {
@@ -4317,6 +4355,10 @@
         arg3 = arg4;
       }
 #endif
+#ifdef TARGET_MIPS
+    arg2 = arg3;
+    arg3 = arg4;
+#endif
     return get_errno(truncate64(arg1, target_offset64(arg2, arg3)));
 }
 #endif
@@ -4334,6 +4376,10 @@
         arg3 = arg4;
       }
 #endif
+#ifdef TARGET_MIPS
+    arg2 = arg3;
+    arg3 = arg4;
+#endif
     return get_errno(ftruncate64(arg1, target_offset64(arg2, arg3)));
 }
 #endif
@@ -5543,7 +5589,7 @@
         break;
     case TARGET_NR_setrlimit:
         {
-            int resource = arg1;
+            int resource = target_to_host_resource(arg1);
             struct target_rlimit *target_rlim;
             struct rlimit rlim;
             if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))
@@ -5556,7 +5602,7 @@
         break;
     case TARGET_NR_getrlimit:
         {
-            int resource = arg1;
+            int resource = target_to_host_resource(arg1);
             struct target_rlimit *target_rlim;
             struct rlimit rlim;
 
@@ -6791,6 +6837,9 @@
         if (((CPUARMState *)cpu_env)->eabi)
             arg4 = arg5;
 #endif
+#ifdef TARGET_MIPS
+        arg4 = arg5;
+#endif
         if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
             goto efault;
         ret = get_errno(pread(arg1, p, arg3, arg4));
@@ -6801,6 +6850,9 @@
         if (((CPUARMState *)cpu_env)->eabi)
             arg4 = arg5;
 #endif
+#ifdef TARGET_MIPS
+        arg4 = arg5;
+#endif
         if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
             goto efault;
         ret = get_errno(pwrite(arg1, p, arg3, arg4));
@@ -6860,7 +6912,8 @@
     case TARGET_NR_ugetrlimit:
     {
 	struct rlimit rlim;
-	ret = get_errno(getrlimit(arg1, &rlim));
+	int resource = target_to_host_resource(arg1);
+	ret = get_errno(getrlimit(resource, &rlim));
 	if (!is_error(ret)) {
 	    struct target_rlimit *target_rlim;
             if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))
@@ -7558,6 +7611,11 @@
             arg4 = arg5;
         }
 #endif
+#ifdef TARGET_MIPS
+        arg2 = arg3;
+        arg3 = arg4;
+        arg4 = arg5;
+#endif
         ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));
 #else
         ret = get_errno(readahead(arg1, arg2, arg3));
Index: qemu-0.14.1.1/linux-user/syscall_defs.h
===================================================================
--- qemu-0.14.1.1.orig/linux-user/syscall_defs.h	2011-07-04 19:37:39.000000000 +0200
+++ qemu-0.14.1.1/linux-user/syscall_defs.h	2011-07-04 19:37:41.000000000 +0200
@@ -693,6 +693,40 @@
 #define TARGET_RLIM_INFINITY	((target_ulong)~0UL)
 #endif
 
+#if defined(TARGET_MIPS)
+#define TARGET_RLIMIT_CPU		0
+#define TARGET_RLIMIT_FSIZE		1
+#define TARGET_RLIMIT_DATA		2
+#define TARGET_RLIMIT_STACK		3
+#define TARGET_RLIMIT_CORE		4
+#define TARGET_RLIMIT_RSS		7
+#define TARGET_RLIMIT_NPROC		8
+#define TARGET_RLIMIT_NOFILE		5
+#define TARGET_RLIMIT_MEMLOCK		9
+#define TARGET_RLIMIT_AS		6
+#define TARGET_RLIMIT_LOCKS		10
+#define TARGET_RLIMIT_SIGPENDING	11
+#define TARGET_RLIMIT_MSGQUEUE		12
+#define TARGET_RLIMIT_NICE		13
+#define TARGET_RLIMIT_RTPRIO		14
+#else
+#define TARGET_RLIMIT_CPU		0
+#define TARGET_RLIMIT_FSIZE		1
+#define TARGET_RLIMIT_DATA		2
+#define TARGET_RLIMIT_STACK		3
+#define TARGET_RLIMIT_CORE		4
+#define TARGET_RLIMIT_RSS		5
+#define TARGET_RLIMIT_NPROC		6
+#define TARGET_RLIMIT_NOFILE		7
+#define TARGET_RLIMIT_MEMLOCK		8
+#define TARGET_RLIMIT_AS		9
+#define TARGET_RLIMIT_LOCKS		10
+#define TARGET_RLIMIT_SIGPENDING	11
+#define TARGET_RLIMIT_MSGQUEUE		12
+#define TARGET_RLIMIT_NICE		13
+#define TARGET_RLIMIT_RTPRIO		14
+#endif
+
 struct target_pollfd {
     int fd;           /* file descriptor */
     short events;     /* requested events */
