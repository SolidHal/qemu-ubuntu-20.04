Subject: use fixed data path and use it as path not directory
From: Michael Tokarev <mjt@tls.msk.ru>
Debian-specific: yes

Instead of using data_dir determined at runtime from executable
filename, use fixed data_path and treat it as path (series of
directories determined by colons (:), the same as $PATH environment
variable).  Prepend -L value to it if given, instead of replacing
it completely.  And don't try to open files directly if the given
filename does not contain slash.

This way, we can give a set of directories -- like
/usr/share/seabios:/usr/share/gpxe etc -- as QEMU_DATADIR at configure
time, instead of using (dangling) symlinks.  We also may use alternative
implementations of various components, and stop hard-depending on other
packages.

diff --git a/os-posix.c b/os-posix.c
index 5c64518..1e26b42 100644
--- a/os-posix.c
+++ b/os-posix.c
@@ -79,6 +79,7 @@ void os_setup_signal_handling(void)
     sigaction(SIGTERM, &act, NULL);
 }
 
+#if 0 /* we use a fixed configured data path */
 /* Find a likely location for support files using the location of the binary.
    For installed binaries this will be "$bindir/../share/qemu".  When
    running from the build tree this will be "$bindir/../pc-bios".  */
@@ -141,6 +142,7 @@ char *os_find_datadir(const char *argv0)
 }
 #undef SHARE_SUFFIX
 #undef BUILD_SUFFIX
+#endif
 
 void os_set_proc_name(const char *s)
 {
diff --git a/vl.c b/vl.c
index 1355f69..a004396 100644
--- a/vl.c
+++ b/vl.c
@@ -2247,10 +2247,24 @@ char *qemu_find_file(int type, const char *name)
     const char *subdir;
     char *buf;
 
-    /* Try the name as a straight path first */
-    if (access(name, R_OK) == 0) {
-        return g_strdup(name);
+    static char *data_path;
+    static const char def_datapath[] = CONFIG_QEMU_DATADIR ":";
+    char *s, *p;
+
+    if (strchr(name, '/')) {
+        return access(name, R_OK) == 0 ? g_strdup(name) : NULL;
     }
+
+    if (!data_path) {
+        len = (data_dir ? strlen(data_dir) + 1 : 0) + sizeof(def_datapath) + 1;
+        data_path = g_malloc(len);
+        if (data_dir) {
+            snprintf(data_path, len, "%s:%s", data_dir, def_datapath);
+        } else {
+            strcpy(data_path, def_datapath);
+        }
+    }
+
     switch (type) {
     case QEMU_FILE_TYPE_BIOS:
         subdir = "";
@@ -2261,14 +2275,21 @@ char *qemu_find_file(int type, const char *name)
     default:
         abort();
     }
-    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;
+    len = strlen(data_path) + strlen(name) + strlen(subdir) + 2;
     buf = g_malloc0(len);
-    snprintf(buf, len, "%s/%s%s", data_dir, subdir, name);
-    if (access(buf, R_OK)) {
-        g_free(buf);
-        return NULL;
+    for(p = data_path; (s = strchr(p, ':')) != NULL; p = s + 1) 
+    {
+        if (p == s) {
+            snprintf(buf, len, "%s%s", subdir, name);
+        } else {
+            snprintf(buf, len, "%.*s/%s%s", s - p, p, subdir, name);
+        }
+        if (access(buf, R_OK)) {
+            return buf;
+        }
     }
-    return buf;
+    g_free(buf);
+    return NULL;
 }
 
 static int device_help_func(QemuOpts *opts, void *opaque)
@@ -3874,16 +3895,6 @@ int main(int argc, char **argv, char **envp)
         exit(1);
     }
 
-    /* If no data_dir is specified then try to find it relative to the
-       executable path.  */
-    if (!data_dir) {
-        data_dir = os_find_datadir(argv[0]);
-    }
-    /* If all else fails use the install path specified when building. */
-    if (!data_dir) {
-        data_dir = CONFIG_QEMU_DATADIR;
-    }
-
     /*
      * Default to max_cpus = smp_cpus, in case the user doesn't
      * specify a max_cpus value.
