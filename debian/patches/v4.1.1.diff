commit fbde196c30e4797a51bda046ba514b187963d4ba
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Jul 29 23:34:16 2019 +0200

    dma-helpers: ensure AIO callback is invoked after cancellation
    
    dma_aio_cancel unschedules the BH if there is one, which corresponds
    to the reschedule_dma case of dma_blk_cb.  This can stall the DMA
    permanently, because dma_complete will never get invoked and therefore
    nobody will ever invoke the original AIO callback in dbs->common.cb.
    
    Fix this by invoking the callback (which is ensured to happen after
    a bdrv_aio_cancel_async, or done manually in the dbs->bh case), and
    add assertions to check that the DMA state machine is indeed waiting
    for dma_complete or reschedule_dma, but never both.
    
    Reported-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Message-id: 20190729213416.1972-1-pbonzini@redhat.com
    Signed-off-by: John Snow <jsnow@redhat.com>
    (cherry picked from commit 539343c0a47e19d5dd64d846d64d084d9793681f)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 73a5bf472921068e6db10e7e325b7ac46f111834
Author: John Snow <jsnow@redhat.com>
Date:   Mon Jul 29 18:36:05 2019 -0400

    Revert "ide/ahci: Check for -ECANCELED in aio callbacks"
    
    This reverts commit 0d910cfeaf2076b116b4517166d5deb0fea76394.
    
    It's not correct to just ignore an error code in a callback; we need to
    handle that error and possible report failure to the guest so that they
    don't wait indefinitely for an operation that will now never finish.
    
    This ought to help cases reported by Nutanix where iSCSI returns a
    legitimate -ECANCELED for certain operations which should be propagated
    normally.
    
    Reported-by: Shaju Abraham <shaju.abraham@nutanix.com>
    Signed-off-by: John Snow <jsnow@redhat.com>
    Message-id: 20190729223605.7163-1-jsnow@redhat.com
    Signed-off-by: John Snow <jsnow@redhat.com>
    (cherry picked from commit 8ec41c4265714255d5a138f8b538faf3583dcff6)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 499a5d6bb47ec8be73fc47a37952c4d595957232
Author: David Hildenbrand <david@redhat.com>
Date:   Wed Aug 14 17:12:42 2019 +0200

    s390x/tcg: Fix VERIM with 32/64 bit elements
    
    Wrong order of operands. The constant always comes last. Makes QEMU crash
    reliably on specific git fetch invocations.
    
    Reported-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David Hildenbrand <david@redhat.com>
    Message-Id: <20190814151242.27199-1-david@redhat.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Fixes: 5c4b0ab460ef ("s390x/tcg: Implement VECTOR ELEMENT ROTATE AND INSERT UNDER MASK")
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Cornelia Huck <cohuck@redhat.com>
    (cherry picked from commit 25bcb45d1b81d22634daa2b1a2d8bee746ac129b)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 4bfd496be385073644f639e58790b84bf5f7a5ef
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Thu Aug 22 10:45:14 2019 -0700

    target/alpha: fix tlb_fill trap_arg2 value for instruction fetch
    
    Commit e41c94529740cc26 ("target/alpha: Convert to CPUClass::tlb_fill")
    slightly changed the way the trap_arg2 value is computed in case of TLB
    fill. The type of the variable used in the ternary operator has been
    changed from an int to an enum. This causes the -1 value to not be
    sign-extended to 64-bit in case of an instruction fetch. The trap_arg2
    ends up with 0xffffffff instead of 0xffffffffffffffff. Fix that by
    changing the -1 into -1LL.
    
    This fixes the execution of user space processes in qemu-system-alpha.
    
    Fixes: e41c94529740cc26
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
    [rth: Test MMU_DATA_LOAD and MMU_DATA_STORE instead of implying them.]
    Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
    (cherry picked from commit cb1de55a83eaca9ee32be9c959dca99e11f2fea8)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 7ebcd375ade505358c1c45542de22f188c599bdd
Author: Eduardo Habkost <ehabkost@redhat.com>
Date:   Fri Aug 16 14:07:50 2019 -0300

    pc: Don't make die-id mandatory unless necessary
    
    We have this issue reported when using libvirt to hotplug CPUs:
    https://bugzilla.redhat.com/show_bug.cgi?id=1741451
    
    Basically, libvirt is not copying die-id from
    query-hotpluggable-cpus, but die-id is now mandatory.
    
    We could blame libvirt and say it is not following the documented
    interface, because we have this buried in the QAPI schema
    documentation:
    
    > Note: currently there are 5 properties that could be present
    > but management should be prepared to pass through other
    > properties with device_add command to allow for future
    > interface extension. This also requires the filed names to be kept in
    > sync with the properties passed to -device/device_add.
    
    But I don't think this would be reasonable from us.  We can just
    make QEMU more flexible and let die-id to be omitted when there's
    no ambiguity.  This will allow us to keep compatibility with
    existing libvirt versions.
    
    Test case included to ensure we don't break this again.
    
    Fixes: commit 176d2cda0dee ("i386/cpu: Consolidate die-id validity in smp context")
    Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
    Message-Id: <20190816170750.23910-1-ehabkost@redhat.com>
    Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
    (cherry picked from commit fea374e7c8079563bca7c8fac895c6a880f76adc)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit b6cedc911e44a5bc6f3f120fee411c1ccc22f220
Author: Anthony PERARD <anthony.perard@citrix.com>
Date:   Fri Aug 23 11:15:33 2019 +0100

    xen-bus: Fix backend state transition on device reset
    
    When a frontend wants to reset its state and the backend one, it
    starts with setting "Closing", then waits for the backend (QEMU) to do
    the same.
    
    But when QEMU is setting "Closing" to its state, it triggers an event
    (xenstore watch) that re-execute xen_device_backend_changed() and set
    the backend state to "Closed". QEMU should wait for the frontend to
    set "Closed" before doing the same.
    
    Before setting "Closed" to the backend_state, we are also going to
    check if there is a frontend. If that the case, when the backend state
    is set to "Closing" the frontend should react and sets its state to
    "Closing" then "Closed". The backend should wait for that to happen.
    
    Fixes: b6af8926fb858c4f1426e5acb2cfc1f0580ec98a
    Signed-off-by: Anthony PERARD <anthony.perard@citrix.com>
    Reviewed-by: Paul Durrant <paul.durrant@citrix.com>
    Message-Id: <20190823101534.465-2-anthony.perard@citrix.com>
    (cherry picked from commit cb3231460747552d70af9d546dc53d8195bcb796)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c12adfd8f61b9dad3a98b0622457ce0ad62db245
Author: Paul Durrant <paul.durrant@citrix.com>
Date:   Tue Sep 10 18:17:53 2019 +0100

    xen-bus: check whether the frontend is active during device reset...
    
    ...not the backend
    
    Commit cb323146 "xen-bus: Fix backend state transition on device reset"
    contained a subtle mistake. The hunk
    
    @@ -539,11 +556,11 @@ static void xen_device_backend_changed(void *opaque)
    
         /*
          * If the toolstack (or unplug request callback) has set the backend
    -     * state to Closing, but there is no active frontend (i.e. the
    -     * state is not Connected) then set the backend state to Closed.
    +     * state to Closing, but there is no active frontend then set the
    +     * backend state to Closed.
          */
         if (xendev->backend_state == XenbusStateClosing &&
    -        xendev->frontend_state != XenbusStateConnected) {
    +        !xen_device_state_is_active(state)) {
             xen_device_backend_set_state(xendev, XenbusStateClosed);
         }
    
    mistakenly replaced the check of 'xendev->frontend_state' with a check
    (now in a helper function) of 'state', which actually equates to
    'xendev->backend_state'.
    
    This patch fixes the mistake.
    
    Fixes: cb3231460747552d70af9d546dc53d8195bcb796
    Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
    Reviewed-by: Anthony PERARD <anthony.perard@citrix.com>
    Message-Id: <20190910171753.3775-1-paul.durrant@citrix.com>
    Signed-off-by: Anthony PERARD <anthony.perard@citrix.com>
    (cherry picked from commit df6180bb56cd03949c2c64083da58755fed81a61)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 6f1a94035b02d3676a897ea5fa4cda4c62128228
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Aug 23 15:03:40 2019 +0200

    block/file-posix: Reduce xfsctl() use
    
    This patch removes xfs_write_zeroes() and xfs_discard().  Both functions
    have been added just before the same feature was present through
    fallocate():
    
    - fallocate() has supported PUNCH_HOLE for XFS since Linux 2.6.38 (March
      2011); xfs_discard() was added in December 2010.
    
    - fallocate() has supported ZERO_RANGE for XFS since Linux 3.15 (June
      2014); xfs_write_zeroes() was added in November 2013.
    
    Nowadays, all systems that qemu runs on should support both fallocate()
    features (RHEL 7's kernel does).
    
    xfsctl() is still useful for getting the request alignment for O_DIRECT,
    so this patch does not remove our dependency on it completely.
    
    Note that xfs_write_zeroes() had a bug: It calls ftruncate() when the
    file is shorter than the specified range (because ZERO_RANGE does not
    increase the file length).  ftruncate() may yield and then discard data
    that parallel write requests have written past the EOF in the meantime.
    Dropping the function altogether fixes the bug.
    
    Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
    Fixes: 50ba5b2d994853b38fed10e0841b119da0f8b8e5
    Reported-by: Lukáš Doktor <ldoktor@redhat.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: Stefano Garzarella <sgarzare@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Tested-by: Stefano Garzarella <sgarzare@redhat.com>
    Tested-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit b2c6f23f4a9f6d8f1b648705cd46d3713b78d6a2)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 3361d03ff005f0a581664582c914da66ab886cfb
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Aug 23 15:03:41 2019 +0200

    iotests: Test reverse sub-cluster qcow2 writes
    
    This exercises the regression introduced in commit
    50ba5b2d994853b38fed10e0841b119da0f8b8e5.  On my machine, it has close
    to a 50 % false-negative rate, but that should still be sufficient to
    test the fix.
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: Stefano Garzarella <sgarzare@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Tested-by: Stefano Garzarella <sgarzare@redhat.com>
    Tested-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit ae6ef0190981a21f2d4bc8dcee7253688f14fae7)
     Conflicts:
            tests/qemu-iotests/group
    *fix context deps on tests not in 4.1.0
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 57fdf4a13ff16d9d48a43f02a5e7b42e3d264f83
Author: Markus Armbruster <armbru@redhat.com>
Date:   Thu Aug 22 15:38:46 2019 +0200

    pr-manager: Fix invalid g_free() crash bug
    
    pr_manager_worker() passes its @opaque argument to g_free().  Wrong;
    it points to pr_manager_worker()'s automatic @data.  Broken when
    commit 2f3a7ab39be converted @data from heap- to stack-allocated.  Fix
    by deleting the g_free().
    
    Fixes: 2f3a7ab39bec4ba8022dc4d42ea641165b004e3e
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Markus Armbruster <armbru@redhat.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 6b9d62c2a9e83bbad73fb61406f0ff69b46ff6f3)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 725dfa851f8e1de8653f41a4bd38c7f98757eb40
Author: Igor Mammedov <imammedo@redhat.com>
Date:   Mon Sep 2 08:02:22 2019 -0400

    x86: do not advertise die-id in query-hotpluggbale-cpus if '-smp dies' is not set
    
    Commit 176d2cda0 (i386/cpu: Consolidate die-id validity in smp context) added
    new 'die-id' topology property to CPUs and exposed it via QMP command
    query-hotpluggable-cpus, which broke -device/device_add cpu-foo for existing
    users that do not support die-id/dies yet. That's would be fine if it happened
    to new machine type only but it also happened to old machine types,
    which breaks migration from old QEMU to the new one, for example following CLI:
    
      OLD-QEMU -M pc-i440fx-4.0 -smp 1,max_cpus=2 \
               -device qemu64-x86_64-cpu,socket-id=1,core-id=0,thread-id
    is not able to start with new QEMU, complaining about invalid die-id.
    
    After discovering regression, the patch
       "pc: Don't make die-id mandatory unless necessary"
    makes die-id optional so old CLI would work.
    
    However it's not enough as new QEMU still exposes die-id via query-hotpluggbale-cpus
    QMP command, so the users that started old machine type on new QEMU, using all
    properties (including die-id) received from QMP command (as required), won't be
    able to start old QEMU using the same properties since it doesn't support die-id.
    
    Fix it by hiding die-id in query-hotpluggbale-cpus for all machine types in case
    '-smp dies' is not provided on CLI or -smp dies = 1', in which case smp_dies == 1
    and APIC ID is calculated in default way (as it was before DIE support) so we won't
    need compat code as in both cases the topology provided to guest via CPUID is the same.
    
    Signed-off-by: Igor Mammedov <imammedo@redhat.com>
    Message-Id: <20190902120222.6179-1-imammedo@redhat.com>
    Reviewed-by: Eduardo Habkost <ehabkost@redhat.com>
    Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
    (cherry picked from commit c6c1bb89fb46f3b88f832e654cf5a6f7941aac51)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 97c478c355fee96eb2b740313f50561e69b6f305
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Sep 2 21:33:16 2019 +0200

    vpc: Return 0 from vpc_co_create() on success
    
    blockdev_create_run() directly uses .bdrv_co_create()'s return value as
    the job's return value.  Jobs must return 0 on success, not just any
    nonnegative value.  Therefore, using blockdev-create for VPC images may
    currently fail as the vpc driver may return a positive integer.
    
    Because there is no point in returning a positive integer anywhere in
    the block layer (all non-negative integers are generally treated as
    complete success), we probably do not want to add more such cases.
    Therefore, fix this problem by making the vpc driver always return 0 in
    case of success.
    
    Suggested-by: Kevin Wolf <kwolf@redhat.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 1a37e3124407b5a145d44478d3ecbdb89c63789f)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 4d9bdd31496acc3d51d58490006244d75a485100
Author: John Snow <jsnow@redhat.com>
Date:   Mon Jul 29 16:35:53 2019 -0400

    iotests: add testing shim for script-style python tests
    
    Because the new-style python tests don't use the iotests.main() test
    launcher, we don't turn on the debugger logging for these scripts
    when invoked via ./check -d.
    
    Refactor the launcher shim into new and old style shims so that they
    share environmental configuration.
    
    Two cleanup notes: debug was not actually used as a global, and there
    was no reason to create a class in an inner scope just to achieve
    default variables; we can simply create an instance of the runner with
    the values we want instead.
    
    Signed-off-by: John Snow <jsnow@redhat.com>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190709232550.10724-14-jsnow@redhat.com
    Signed-off-by: John Snow <jsnow@redhat.com>
    (cherry picked from commit 456a2d5ac7641c7e75c76328a561b528a8607a8e)
    *prereq for 88d2aa533a
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 819ba23575be2ce4d14bff12d54bad0f625cf148
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Sep 2 21:33:17 2019 +0200

    iotests: Add supported protocols to execute_test()
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 88d2aa533a4a1aad44a27c2e6cd5bc5fbcbce7ed)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit eee776fbc06be627ce6e01c5766db9f83af55ec1
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Sep 2 21:33:18 2019 +0200

    iotests: Restrict file Python tests to file
    
    Most of our Python unittest-style tests only support the file protocol.
    You can run them with any other protocol, but the test will simply
    ignore your choice and use file anyway.
    
    We should let them signal that they require the file protocol so they
    are skipped when you want to test some other protocol.
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 103cbc771e5660d1f5bb458be80aa9e363547ae0)
     Conflicts:
            tests/qemu-iotests/257
    *drop changes for tests not in 4.1.0
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 593beeaf81964e890d0f7f40fa4bafcb9769ae35
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Sep 2 21:33:19 2019 +0200

    iotests: Restrict nbd Python tests to nbd
    
    We have two Python unittest-style tests that test NBD.  As such, they
    should specify supported_protocols=['nbd'] so they are skipped when the
    user wants to test some other protocol.
    
    Furthermore, we should restrict their choice of formats to 'raw'.  The
    idea of a protocol/format combination is to use some format over some
    protocol; but we always use the raw format over NBD.  It does not really
    matter what the NBD server uses on its end, and it is not a useful test
    of the respective format driver anyway.
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 7c932a1d69a6d6ac5c0b615c11d191da3bbe9aa8)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit ad95e0573ede001e7d56f10c2119368dc57c3bb6
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Sep 2 21:33:20 2019 +0200

    iotests: Test blockdev-create for vpc
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit cb73747e1a47b93d3dfdc3f769c576b053916938)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 38fb634853ac6547326d9f88b9a068d9fc6b4ad4
Author: Peter Maydell <peter.maydell@linaro.org>
Date:   Tue Aug 27 13:19:31 2019 +0100

    target/arm: Free TCG temps in trans_VMOV_64_sp()
    
    The function neon_store_reg32() doesn't free the TCG temp that it
    is passed, so the caller must do that. We got this right in most
    places but forgot to free the TCG temps in trans_VMOV_64_sp().
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Message-id: 20190827121931.26836-1-peter.maydell@linaro.org
    (cherry picked from commit 342d27581bd3ecdb995e4fc55fcd383cf3242888)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 9027d3fba605d8f6093342ebe4a1da450d374630
Author: Peter Maydell <peter.maydell@linaro.org>
Date:   Thu Aug 22 14:15:34 2019 +0100

    target/arm: Don't abort on M-profile exception return in linux-user mode
    
    An attempt to do an exception-return (branch to one of the magic
    addresses) in linux-user mode for M-profile should behave like
    a normal branch, because linux-user mode is always going to be
    in 'handler' mode. This used to work, but we broke it when we added
    support for the M-profile security extension in commit d02a8698d7ae2bfed.
    
    In that commit we allowed even handler-mode calls to magic return
    values to be checked for and dealt with by causing an
    EXCP_EXCEPTION_EXIT exception to be taken, because this is
    needed for the FNC_RETURN return-from-non-secure-function-call
    handling. For system mode we added a check in do_v7m_exception_exit()
    to make any spurious calls from Handler mode behave correctly, but
    forgot that linux-user mode would also be affected.
    
    How an attempted return-from-non-secure-function-call in linux-user
    mode should be handled is not clear -- on real hardware it would
    result in return to secure code (not to the Linux kernel) which
    could then handle the error in any way it chose. For QEMU we take
    the simple approach of treating this erroneous return the same way
    it would be handled on a CPU without the security extensions --
    treat it as a normal branch.
    
    The upshot of all this is that for linux-user mode we should never
    do any of the bx_excret magic, so the code change is simple.
    
    This ought to be a weird corner case that only affects broken guest
    code (because Linux user processes should never be attempting to do
    exception returns or NS function returns), except that the code that
    assigns addresses in RAM for the process and stack in our linux-user
    code does not attempt to avoid this magic address range, so
    legitimate code attempting to return to a trampoline routine on the
    stack can fall into this case. This change fixes those programs,
    but we should also look at restricting the range of memory we
    use for M-profile linux-user guests to the area that would be
    real RAM in hardware.
    
    Cc: qemu-stable@nongnu.org
    Reported-by: Christophe Lyon <christophe.lyon@linaro.org>
    Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    Message-id: 20190822131534.16602-1-peter.maydell@linaro.org
    Fixes: https://bugs.launchpad.net/qemu/+bug/1840922
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    (cherry picked from commit 5e5584c89f36b302c666bc6db535fd3f7ff35ad2)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 28a9a3558a427493049723fff390add7026653eb
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Sep 3 23:04:22 2019 +0300

    libvhost-user: fix SLAVE_SEND_FD handling
    
    It doesn't look like this could possibly work properly since
    VHOST_USER_PROTOCOL_F_SLAVE_SEND_FD is defined to 10, but the
    dev->protocol_features has a bitmap. I suppose the peer this
    was tested with also supported VHOST_USER_PROTOCOL_F_LOG_SHMFD,
    in which case the test would always be false, but nevertheless
    the code seems wrong.
    
    Use has_feature() to fix this.
    
    Fixes: d84599f56c82 ("libvhost-user: support host notifier")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Message-Id: <20190903200422.11693-1-johannes@sipsolutions.net>
    Reviewed-by: Tiwei Bie <tiwei.bie@intel.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    (cherry picked from commit 8726b70b449896f1211f869ec4f608904f027207)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c9ffb12754b1575babfef45168b6e1b1af80a95f
Author: Alberto Garcia <berto@igalia.com>
Date:   Fri Aug 16 15:17:42 2019 +0300

    qcow2: Fix the calculation of the maximum L2 cache size
    
    The size of the qcow2 L2 cache defaults to 32 MB, which can be easily
    larger than the maximum amount of L2 metadata that the image can have.
    For example: with 64 KB clusters the user would need a qcow2 image
    with a virtual size of 256 GB in order to have 32 MB of L2 metadata.
    
    Because of that, since commit b749562d9822d14ef69c9eaa5f85903010b86c30
    we forbid the L2 cache to become larger than the maximum amount of L2
    metadata for the image, calculated using this formula:
    
        uint64_t max_l2_cache = virtual_disk_size / (s->cluster_size / 8);
    
    The problem with this formula is that the result should be rounded up
    to the cluster size because an L2 table on disk always takes one full
    cluster.
    
    For example, a 1280 MB qcow2 image with 64 KB clusters needs exactly
    160 KB of L2 metadata, but we need 192 KB on disk (3 clusters) even if
    the last 32 KB of those are not going to be used.
    
    However QEMU rounds the numbers down and only creates 2 cache tables
    (128 KB), which is not enough for the image.
    
    A quick test doing 4KB random writes on a 1280 MB image gives me
    around 500 IOPS, while with the correct cache size I get 16K IOPS.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Alberto Garcia <berto@igalia.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit b70d08205b2e4044c529eefc21df2c8ab61b473b)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 0694c489cd240620fee5675e8d24c7ce02d1d67d
Author: Peter Lieven <pl@kamp.de>
Date:   Tue Sep 10 17:41:09 2019 +0200

    block/nfs: tear down aio before nfs_close
    
    nfs_close is a sync call from libnfs and has its own event
    handler polling on the nfs FD. Avoid that both QEMU and libnfs
    are intefering here.
    
    CC: qemu-stable@nongnu.org
    Signed-off-by: Peter Lieven <pl@kamp.de>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit 601dc6559725f7a614b6f893611e17ff0908e914)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 3648493495f2ecb2df22aa4be396e00077693d79
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:30 2019 +0200

    curl: Keep pointer to the CURLState in CURLSocket
    
    A follow-up patch will make curl_multi_do() and curl_multi_read() take a
    CURLSocket instead of the CURLState.  They still need the latter,
    though, so add a pointer to it to the former.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Message-id: 20190910124136.10565-2-mreitz@redhat.com
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 0487861685294660b23bc146e1ebd5304aa8bbe0)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 78ea94e389b2d503ae9a3023759050fd8072e581
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:31 2019 +0200

    curl: Keep *socket until the end of curl_sock_cb()
    
    This does not really change anything, but it makes the code a bit easier
    to follow once we use @socket as the opaque pointer for
    aio_set_fd_handler().
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190910124136.10565-3-mreitz@redhat.com
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 007f339b1099af46a008dac438ca0943e31dba72)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 4be97ef966f5d88a64bcc359d2c72152bc08b322
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:32 2019 +0200

    curl: Check completion in curl_multi_do()
    
    While it is more likely that transfers complete after some file
    descriptor has data ready to read, we probably should not rely on it.
    Better be safe than sorry and call curl_multi_check_completion() in
    curl_multi_do(), too, just like it is done in curl_multi_read().
    
    With this change, curl_multi_do() and curl_multi_read() are actually the
    same, so drop curl_multi_read() and use curl_multi_do() as the sole FD
    handler.
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190910124136.10565-4-mreitz@redhat.com
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 948403bcb1c7e71dcbe8ab8479cf3934a0efcbb5)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 0888ddac8e507e54ae69db7ccbae1117d7ec33b1
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:33 2019 +0200

    curl: Pass CURLSocket to curl_multi_do()
    
    curl_multi_do_locked() currently marks all sockets as ready.  That is
    not only inefficient, but in fact unsafe (the loop is).  A follow-up
    patch will change that, but to do so, curl_multi_do_locked() needs to
    know exactly which socket is ready; and that is accomplished by this
    patch here.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190910124136.10565-5-mreitz@redhat.com
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 9dbad87d25587ff640ef878f7b6159fc368ff541)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 18e1b71937a37bde173e3d9b2f8f97ee92fedd16
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:34 2019 +0200

    curl: Report only ready sockets
    
    Instead of reporting all sockets to cURL, only report the one that has
    caused curl_multi_do_locked() to be called.  This lets us get rid of the
    QLIST_FOREACH_SAFE() list, which was actually wrong: SAFE foreaches are
    only safe when the current element is removed in each iteration.  If it
    possible for the list to be concurrently modified, we cannot guarantee
    that only the current element will be removed.  Therefore, we must not
    use QLIST_FOREACH_SAFE() here.
    
    Fixes: ff5ca1664af85b24a4180d595ea6873fd3deac57
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190910124136.10565-6-mreitz@redhat.com
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 9abaf9fc474c3dd53e8e119326abc774c977c331)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 2d86df1f78d71ca30a4bff84002ada70e6a04169
Author: Max Reitz <mreitz@redhat.com>
Date:   Tue Sep 10 14:41:35 2019 +0200

    curl: Handle success in multi_check_completion
    
    Background: As of cURL 7.59.0, it verifies that several functions are
    not called from within a callback.  Among these functions is
    curl_multi_add_handle().
    
    curl_read_cb() is a callback from cURL and not a coroutine.  Waking up
    acb->co will lead to entering it then and there, which means the current
    request will settle and the caller (if it runs in the same coroutine)
    may then issue the next request.  In such a case, we will enter
    curl_setup_preadv() effectively from within curl_read_cb().
    
    Calling curl_multi_add_handle() will then fail and the new request will
    not be processed.
    
    Fix this by not letting curl_read_cb() wake up acb->co.  Instead, leave
    the whole business of settling the AIOCB objects to
    curl_multi_check_completion() (which is called from our timer callback
    and our FD handler, so not from any cURL callbacks).
    
    Reported-by: Natalie Gavrielov <ngavrilo@redhat.com>
    Buglink: https://bugzilla.redhat.com/show_bug.cgi?id=1740193
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190910124136.10565-7-mreitz@redhat.com
    Reviewed-by: John Snow <jsnow@redhat.com>
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit bfb23b480a49114315877aacf700b49453e0f9d9)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 86b0f4022bb43b16979ba5300e8d40a1e6d44b79
Author: Sergio Lopez <slp@redhat.com>
Date:   Wed Sep 11 12:03:16 2019 +0200

    blockjob: update nodes head while removing all bdrv
    
    block_job_remove_all_bdrv() iterates through job->nodes, calling
    bdrv_root_unref_child() for each entry. The call to the latter may
    reach child_job_[can_]set_aio_ctx(), which will also attempt to
    traverse job->nodes, potentially finding entries that where freed
    on previous iterations.
    
    To avoid this situation, update job->nodes head on each iteration to
    ensure that already freed entries are no longer linked to the list.
    
    RHBZ: https://bugzilla.redhat.com/show_bug.cgi?id=1746631
    Signed-off-by: Sergio Lopez <slp@redhat.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20190911100316.32282-1-mreitz@redhat.com
    Reviewed-by: Sergio Lopez <slp@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit d876bf676f5e7c6aa9ac64555e48cba8734ecb2f)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 84f22c728520792f1010074e0d5ac2ec8e2e372c
Author: Maxim Levitsky <mlevitsk@redhat.com>
Date:   Sun Sep 15 23:36:53 2019 +0300

    block/qcow2: Fix corruption introduced by commit 8ac0f15f335
    
    This fixes subtle corruption introduced by luks threaded encryption
    in commit 8ac0f15f335
    
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1745922
    
    The corruption happens when we do a write that
       * writes to two or more unallocated clusters at once
       * doesn't fully cover the first sector
       * doesn't fully cover the last sector
       * uses luks encryption
    
    In this case, when allocating the new clusters we COW both areas
    prior to the write and after the write, and we encrypt them.
    
    The above mentioned commit accidentally made it so we encrypt the
    second COW area using the physical cluster offset of the first area.
    
    The problem is that offset_in_cluster in do_perform_cow_encrypt
    can be larger that the cluster size, thus cluster_offset
    will no longer point to the start of the cluster at which encrypted
    area starts.
    
    Next patch in this series will refactor the code to avoid all these
    assumptions.
    
    In the bugreport that was triggered by rebasing a luks image to new,
    zero filled base, which lot of such writes, and causes some files
    with zero areas to contain garbage there instead.
    But as described above it can happen elsewhere as well
    
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Message-id: 20190915203655.21638-2-mlevitsk@redhat.com
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 38e7d54bdc518b5a05a922467304bcace2396945)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit e9bb3d942e268a19e03fc5d404586d2ed1564282
Author: Kevin Wolf <kwolf@redhat.com>
Date:   Thu Oct 24 16:26:57 2019 +0200

    coroutine: Add qemu_co_mutex_assert_locked()
    
    Some functions require that the caller holds a certain CoMutex for them
    to operate correctly. Add a function so that they can assert the lock is
    really held.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    Tested-by: Michael Weiser <michael.weiser@gmx.de>
    Reviewed-by: Michael Weiser <michael.weiser@gmx.de>
    Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Reviewed-by: Denis V. Lunev <den@openvz.org>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 944f3d5dd216fcd8cb007eddd4f82dced0a15b3d)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 416a692e51b8b582407e30046ddcffbbe52ecf77
Author: Kevin Wolf <kwolf@redhat.com>
Date:   Thu Oct 24 16:26:58 2019 +0200

    qcow2: Fix corruption bug in qcow2_detect_metadata_preallocation()
    
    qcow2_detect_metadata_preallocation() calls qcow2_get_refcount() which
    requires s->lock to be taken to protect its accesses to the refcount
    table and refcount blocks. However, nothing in this code path actually
    took the lock. This could cause the same cache entry to be used by two
    requests at the same time, for different tables at different offsets,
    resulting in image corruption.
    
    As it would be preferable to base the detection on consistent data (even
    though it's just heuristics), let's take the lock not only around the
    qcow2_get_refcount() calls, but around the whole function.
    
    This patch takes the lock in qcow2_co_block_status() earlier and asserts
    in qcow2_detect_metadata_preallocation() that we hold the lock.
    
    Fixes: 69f47505ee66afaa513305de0c1895a224e52c45
    Cc: qemu-stable@nongnu.org
    Reported-by: Michael Weiser <michael.weiser@gmx.de>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    Tested-by: Michael Weiser <michael.weiser@gmx.de>
    Reviewed-by: Michael Weiser <michael.weiser@gmx.de>
    Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 5e9785505210e2477e590e61b1ab100d0ec22b01)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit e01ed1a1ae42e023fa8f91c9e3905f4f9c3523a0
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Fri Sep 20 17:20:42 2019 +0300

    block/backup: fix max_transfer handling for copy_range
    
    Of course, QEMU_ALIGN_UP is a typo, it should be QEMU_ALIGN_DOWN, as we
    are trying to find aligned size which satisfy both source and target.
    Also, don't ignore too small max_transfer. In this case seems safer to
    disable copy_range.
    
    Fixes: 9ded4a0114968e
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Message-id: 20190920142056.12778-2-vsementsov@virtuozzo.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 981fb5810aa3f68797ee6e261db338bd78857614)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 783e7eb52c0a8e2b8cb906566d0dc2538ffefccf
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Fri Sep 20 17:20:43 2019 +0300

    block/backup: fix backup_cow_with_offload for last cluster
    
    We shouldn't try to copy bytes beyond EOF. Fix it.
    
    Fixes: 9ded4a0114968e
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Message-id: 20190920142056.12778-3-vsementsov@virtuozzo.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 1048ddf0a32dcdaa952e581bd503d49adad527cc)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 220816989c1e3d490d293b8d7ac85dbc41a4c321
Author: Peter Maydell <peter.maydell@linaro.org>
Date:   Fri Sep 20 18:40:39 2019 +0100

    hw/arm/boot.c: Set NSACR.{CP11,CP10} for NS kernel boots
    
    If we're booting a Linux kernel directly into Non-Secure
    state on a CPU which has Secure state, then make sure we
    set the NSACR CP11 and CP10 bits, so that Non-Secure is allowed
    to access the FPU. Otherwise an AArch32 kernel will UNDEF as
    soon as it tries to use the FPU.
    
    It used to not matter that we didn't do this until commit
    fc1120a7f5f2d4b6, where we implemented actually honouring
    these NSACR bits.
    
    The problem only exists for CPUs where EL3 is AArch32; the
    equivalent AArch64 trap bits are in CPTR_EL3 and are "0 to
    not trap, 1 to trap", so the reset value of the register
    permits NS access, unlike NSACR.
    
    Fixes: fc1120a7f5
    Fixes: https://bugs.launchpad.net/qemu/+bug/1844597
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
    Message-id: 20190920174039.3916-1-peter.maydell@linaro.org
    (cherry picked from commit ece628fcf69cbbd4b3efb6fbd203af07609467a2)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c5c9b1362d1652a9d0f79f6d9ae2f80d4b5fe432
Author: Michael Roth <mdroth@linux.vnet.ibm.com>
Date:   Thu Sep 12 18:12:01 2019 -0500

    make-release: pull in edk2 submodules so we can build it from tarballs
    
    The `make efi` target added by 536d2173 is built from the roms/edk2
    submodule, which in turn relies on additional submodules nested under
    roms/edk2.
    
    The make-release script currently only pulls in top-level submodules,
    so these nested submodules are missing in the resulting tarball.
    
    We could try to address this situation more generally by recursively
    pulling in all submodules, but this doesn't necessarily ensure the
    end-result will build properly (this case also required other changes).
    
    Additionally, due to the nature of submodules, we may not always have
    control over how these sorts of things are dealt with, so for now we
    continue to handle it on a case-by-case in the make-release script.
    
    Cc: Laszlo Ersek <lersek@redhat.com>
    Cc: Bruce Rogers <brogers@suse.com>
    Cc: qemu-stable@nongnu.org # v4.1.0
    Reported-by: Bruce Rogers <brogers@suse.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Tested-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
    Message-Id: <20190912231202.12327-2-mdroth@linux.vnet.ibm.com>
    Signed-off-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    (cherry picked from commit 45c61c6c23918e3b05ed9ecac5b2328ebae5f774)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit fc5afb1a9230fe21d76bcef527b0d3cee90a2cd3
Author: Michael Roth <mdroth@linux.vnet.ibm.com>
Date:   Thu Sep 12 18:12:02 2019 -0500

    roms/Makefile.edk2: don't pull in submodules when building from tarball
    
    Currently the `make efi` target pulls submodules nested under the
    roms/edk2 submodule as dependencies. However, when we attempt to build
    from a tarball this fails since we are no longer in a git tree.
    
    A preceding patch will pre-populate these submodules in the tarball,
    so assume this build dependency is only needed when building from a
    git tree.
    
    Cc: Laszlo Ersek <lersek@redhat.com>
    Cc: Bruce Rogers <brogers@suse.com>
    Cc: qemu-stable@nongnu.org # v4.1.0
    Reported-by: Bruce Rogers <brogers@suse.com>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Tested-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
    Message-Id: <20190912231202.12327-3-mdroth@linux.vnet.ibm.com>
    Signed-off-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    (cherry picked from commit f3e330e3c319160ac04954399b5a10afc965098c)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 331c08d300aab154560d870b2be424f663d260b2
Author: Matthew Rosato <mjrosato@linux.ibm.com>
Date:   Thu Sep 26 10:10:36 2019 -0400

    s390: PCI: fix IOMMU region init
    
    The fix in dbe9cf606c shrinks the IOMMU memory region to a size
    that seems reasonable on the surface, however is actually too
    small as it is based against a 0-mapped address space.  This
    causes breakage with small guests as they can overrun the IOMMU window.
    
    Let's go back to the prior method of initializing iommu for now.
    
    Fixes: dbe9cf606c ("s390x/pci: Set the iommu region size mpcifc request")
    Cc: qemu-stable@nongnu.org
    Reviewed-by: Pierre Morel <pmorel@linux.ibm.com>
    Reported-by: Boris Fiuczynski <fiuczy@linux.ibm.com>
    Tested-by: Boris Fiuczynski <fiuczy@linux.ibm.com>
    Reported-by: Stefan Zimmerman <stzi@linux.ibm.com>
    Signed-off-by: Matthew Rosato <mjrosato@linux.ibm.com>
    Message-Id: <1569507036-15314-1-git-send-email-mjrosato@linux.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    (cherry picked from commit 7df1dac5f1c85312474df9cb3a8fcae72303da62)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 7a8aa6c734bb1c2927ad0cc1d10bcacb53cf4ae3
Author: Kevin Wolf <kwolf@redhat.com>
Date:   Tue Sep 17 12:26:23 2019 +0200

    block/snapshot: Restrict set of snapshot nodes
    
    Nodes involved in internal snapshots were those that were returned by
    bdrv_next(), inserted and not read-only. bdrv_next() in turn returns all
    nodes that are either the root node of a BlockBackend or monitor-owned
    nodes.
    
    With the typical -drive use, this worked well enough. However, in the
    typical -blockdev case, the user defines one node per option, making all
    nodes monitor-owned nodes. This includes protocol nodes etc. which often
    are not snapshottable, so "savevm" only returns an error.
    
    Change the conditions so that internal snapshot still include all nodes
    that have a BlockBackend attached (we definitely want to snapshot
    anything attached to a guest device and probably also the built-in NBD
    server; snapshotting block job BlockBackends is more of an accident, but
    a preexisting one), but other monitor-owned nodes are only included if
    they have no parents.
    
    This makes internal snapshots usable again with typical -blockdev
    configurations.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    Reviewed-by: Eric Blake <eblake@redhat.com>
    Reviewed-by: Peter Krempa <pkrempa@redhat.com>
    Tested-by: Peter Krempa <pkrempa@redhat.com>
    (cherry picked from commit 05f4aced658a02b02d3e89a6c7a2281008fcf26c)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit d868d30db6799cf0bc7da7ec67ca6be1e8ec07b2
Author: Kevin Wolf <kwolf@redhat.com>
Date:   Tue Sep 17 12:43:42 2019 +0200

    iotests: Test internal snapshots with -blockdev
    
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    Reviewed-by: Peter Krempa <pkrempa@redhat.com>
    Tested-by: Peter Krempa <pkrempa@redhat.com>
    (cherry picked from commit 92b22e7b1789b0e5f20d245706e72eae70dbddce)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 7b404cae7fa2850d476c29258f03b8e77a5b4bd0
Author: Adrian Moreno <amorenoz@redhat.com>
Date:   Tue Sep 24 18:20:44 2019 +0200

    vhost-user: save features if the char dev is closed
    
    That way the state can be correctly restored when the device is opened
    again. This might happen if the backend is restarted.
    
    Buglink: https://bugzilla.redhat.com/show_bug.cgi?id=1738768
    Reported-by: Pei Zhang <pezhang@redhat.com>
    Fixes: 6ab79a20af3a ("do not call vhost_net_cleanup() on running net from char user event")
    Cc: ddstreet@canonical.com
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Adrian Moreno <amorenoz@redhat.com>
    Message-Id: <20190924162044.11414-1-amorenoz@redhat.com>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    (cherry picked from commit c6beefd674fff8d41b90365dfccad32e53a5abcb)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit aae0faa5d3bee91c66dc4c1543190f55a242771e
Author: Thomas Huth <thuth@redhat.com>
Date:   Wed Sep 25 14:16:43 2019 +0200

    hw/core/loader: Fix possible crash in rom_copy()
    
    Both, "rom->addr" and "addr" are derived from the binary image
    that can be loaded with the "-kernel" paramer. The code in
    rom_copy() then calculates:
    
        d = dest + (rom->addr - addr);
    
    and uses "d" as destination in a memcpy() some lines later. Now with
    bad kernel images, it is possible that rom->addr is smaller than addr,
    thus "rom->addr - addr" gets negative and the memcpy() then tries to
    copy contents from the image to a bad memory location. This could
    maybe be used to inject code from a kernel image into the QEMU binary,
    so we better fix it with an additional sanity check here.
    
    Cc: qemu-stable@nongnu.org
    Reported-by: Guangming Liu
    Buglink: https://bugs.launchpad.net/qemu/+bug/1844635
    Message-Id: <20190925130331.27825-1-thuth@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Thomas Huth <thuth@redhat.com>
    (cherry picked from commit e423455c4f23a1a828901c78fe6d03b7dde79319)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 9e51c5306cffe1a0904d1a31fcf454c436ce8a13
Author: Max Reitz <mreitz@redhat.com>
Date:   Thu Oct 10 12:08:57 2019 +0200

    qcow2: Limit total allocation range to INT_MAX
    
    When the COW areas are included, the size of an allocation can exceed
    INT_MAX.  This is kind of limited by handle_alloc() in that it already
    caps avail_bytes at INT_MAX, but the number of clusters still reflects
    the original length.
    
    This can have all sorts of effects, ranging from the storage layer write
    call failing to image corruption.  (If there were no image corruption,
    then I suppose there would be data loss because the .cow_end area is
    forced to be empty, even though there might be something we need to
    COW.)
    
    Fix all of it by limiting nb_clusters so the equivalent number of bytes
    will not exceed INT_MAX.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: Eric Blake <eblake@redhat.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit d1b9d19f99586b33795e20a79f645186ccbc070f)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit b077ac637db468ad169385d9b702b002654d3a7a
Author: Max Reitz <mreitz@redhat.com>
Date:   Thu Oct 10 12:08:58 2019 +0200

    iotests: Test large write request to qcow2 file
    
    Without HEAD^, the following happens when you attempt a large write
    request to a qcow2 file such that the number of bytes covered by all
    clusters involved in a single allocation will exceed INT_MAX:
    
    (A) handle_alloc_space() decides to fill the whole area with zeroes and
        fails because bdrv_co_pwrite_zeroes() fails (the request is too
        large).
    
    (B) If handle_alloc_space() does not do anything, but merge_cow()
        decides that the requests can be merged, it will create a too long
        IOV that later cannot be written.
    
    (C) Otherwise, all parts will be written separately, so those requests
        will work.
    
    In either B or C, though, qcow2_alloc_cluster_link_l2() will have an
    overflow: We use an int (i) to iterate over nb_clusters, and then
    calculate the L2 entry based on "i << s->cluster_bits" -- which will
    overflow if the range covers more than INT_MAX bytes.  This then leads
    to image corruption because the L2 entry will be wrong (it will be
    recognized as a compressed cluster).
    
    Even if that were not the case, the .cow_end area would be empty
    (because handle_alloc() will cap avail_bytes and nb_bytes at INT_MAX, so
    their difference (which is the .cow_end size) will be 0).
    
    So this test checks that on such large requests, the image will not be
    corrupted.  Unfortunately, we cannot check whether COW will be handled
    correctly, because that data is discarded when it is written to null-co
    (but we have to use null-co, because writing 2 GB of data in a test is
    not quite reasonable).
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: Eric Blake <eblake@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit a1406a9262a087d9ec9627b88da13c4590b61dae)
     Conflicts:
            tests/qemu-iotests/group
    *drop context dep. on tests not in 4.1
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c0e2fbf1240f022efc267cef4216e9c023651bee
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Oct 14 17:39:28 2019 +0200

    mirror: Do not dereference invalid pointers
    
    mirror_exit_common() may be called twice (if it is called from
    mirror_prepare() and fails, it will be called from mirror_abort()
    again).
    
    In such a case, many of the pointers in the MirrorBlockJob object will
    already be freed.  This can be seen most reliably for s->target, which
    is set to NULL (and then dereferenced by blk_bs()).
    
    Cc: qemu-stable@nongnu.org
    Fixes: 737efc1eda23b904fbe0e66b37715fb0e5c3e58b
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Message-id: 20191014153931.20699-2-mreitz@redhat.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit f93c3add3a773e0e3f6277e5517583c4ad3a43c2)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 6705b9344f8d6f134f612c2e35e87cdda5aa6284
Author: Hikaru Nishida <hikarupsp@gmail.com>
Date:   Tue Oct 15 10:07:34 2019 +0900

    ui: Fix hanging up Cocoa display on macOS 10.15 (Catalina)
    
    macOS API documentation says that before applicationDidFinishLaunching
    is called, any events will not be processed. However, some events are
    fired before it is called in macOS Catalina. This causes deadlock of
    iothread_lock in handleEvent while it will be released after the
    app_started_sem is posted.
    This patch avoids processing events before the app_started_sem is
    posted to prevent this deadlock.
    
    Buglink: https://bugs.launchpad.net/qemu/+bug/1847906
    Signed-off-by: Hikaru Nishida <hikarupsp@gmail.com>
    Message-id: 20191015010734.85229-1-hikarupsp@gmail.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    (cherry picked from commit dff742ad27efa474ec04accdbf422c9acfd3e30e)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 8010d3fce008dd13f155bc0babfe236ea44a2712
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Fri Oct 11 15:58:03 2019 +0200

    virtio: new post_load hook
    
    Post load hook in virtio vmsd is called early while device is processed,
    and when VirtIODevice core isn't fully initialized.  Most device
    specific code isn't ready to deal with a device in such state, and
    behaves weirdly.
    
    Add a new post_load hook in a device class instead.  Devices should use
    this unless they specifically want to verify the migration stream as
    it's processed, e.g. for bounds checking.
    
    Cc: qemu-stable@nongnu.org
    Suggested-by: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
    Cc: Mikhail Sennikovsky <mikhail.sennikovskii@cloud.ionos.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    (cherry picked from commit 1dd713837cac8ec5a97d3b8492d72ce5ac94803c)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 4887acf574a573137660aa98d9d422ece0a41a5a
Author: Mikhail Sennikovsky <mikhail.sennikovskii@cloud.ionos.com>
Date:   Fri Oct 11 15:58:04 2019 +0200

    virtio-net: prevent offloads reset on migration
    
    Currently offloads disabled by guest via the VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET
    command are not preserved on VM migration.
    Instead all offloads reported by guest features (via VIRTIO_PCI_GUEST_FEATURES)
    get enabled.
    What happens is: first the VirtIONet::curr_guest_offloads gets restored and offloads
    are getting set correctly:
    
     #0  qemu_set_offload (nc=0x555556a11400, csum=1, tso4=0, tso6=0, ecn=0, ufo=0) at net/net.c:474
     #1  virtio_net_apply_guest_offloads (n=0x555557701ca0) at hw/net/virtio-net.c:720
     #2  virtio_net_post_load_device (opaque=0x555557701ca0, version_id=11) at hw/net/virtio-net.c:2334
     #3  vmstate_load_state (f=0x5555569dc010, vmsd=0x555556577c80 <vmstate_virtio_net_device>, opaque=0x555557701ca0, version_id=11)
         at migration/vmstate.c:168
     #4  virtio_load (vdev=0x555557701ca0, f=0x5555569dc010, version_id=11) at hw/virtio/virtio.c:2197
     #5  virtio_device_get (f=0x5555569dc010, opaque=0x555557701ca0, size=0, field=0x55555668cd00 <__compound_literal.5>) at hw/virtio/virtio.c:2036
     #6  vmstate_load_state (f=0x5555569dc010, vmsd=0x555556577ce0 <vmstate_virtio_net>, opaque=0x555557701ca0, version_id=11) at migration/vmstate.c:143
     #7  vmstate_load (f=0x5555569dc010, se=0x5555578189e0) at migration/savevm.c:829
     #8  qemu_loadvm_section_start_full (f=0x5555569dc010, mis=0x5555569eee20) at migration/savevm.c:2211
     #9  qemu_loadvm_state_main (f=0x5555569dc010, mis=0x5555569eee20) at migration/savevm.c:2395
     #10 qemu_loadvm_state (f=0x5555569dc010) at migration/savevm.c:2467
     #11 process_incoming_migration_co (opaque=0x0) at migration/migration.c:449
    
    However later on the features are getting restored, and offloads get reset to
    everything supported by features:
    
     #0  qemu_set_offload (nc=0x555556a11400, csum=1, tso4=1, tso6=1, ecn=0, ufo=0) at net/net.c:474
     #1  virtio_net_apply_guest_offloads (n=0x555557701ca0) at hw/net/virtio-net.c:720
     #2  virtio_net_set_features (vdev=0x555557701ca0, features=5104441767) at hw/net/virtio-net.c:773
     #3  virtio_set_features_nocheck (vdev=0x555557701ca0, val=5104441767) at hw/virtio/virtio.c:2052
     #4  virtio_load (vdev=0x555557701ca0, f=0x5555569dc010, version_id=11) at hw/virtio/virtio.c:2220
     #5  virtio_device_get (f=0x5555569dc010, opaque=0x555557701ca0, size=0, field=0x55555668cd00 <__compound_literal.5>) at hw/virtio/virtio.c:2036
     #6  vmstate_load_state (f=0x5555569dc010, vmsd=0x555556577ce0 <vmstate_virtio_net>, opaque=0x555557701ca0, version_id=11) at migration/vmstate.c:143
     #7  vmstate_load (f=0x5555569dc010, se=0x5555578189e0) at migration/savevm.c:829
     #8  qemu_loadvm_section_start_full (f=0x5555569dc010, mis=0x5555569eee20) at migration/savevm.c:2211
     #9  qemu_loadvm_state_main (f=0x5555569dc010, mis=0x5555569eee20) at migration/savevm.c:2395
     #10 qemu_loadvm_state (f=0x5555569dc010) at migration/savevm.c:2467
     #11 process_incoming_migration_co (opaque=0x0) at migration/migration.c:449
    
    Fix this by preserving the state in saved_guest_offloads field and
    pushing out offload initialization to the new post load hook.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Mikhail Sennikovsky <mikhail.sennikovskii@cloud.ionos.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    (cherry picked from commit 7788c3f2e21e35902d45809b236791383bbb613e)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit aea18ef938c115f02e269ab6c8bc83dc5126db19
Author: Fan Yang <Fan_Yang@sjtu.edu.cn>
Date:   Tue Sep 24 22:08:29 2019 +0800

    COLO-compare: Fix incorrect `if` logic
    
    'colo_mark_tcp_pkt' should return 'true' when packets are the same, and
    'false' otherwise.  However, it returns 'true' when
    'colo_compare_packet_payload' returns non-zero while
    'colo_compare_packet_payload' is just a 'memcmp'.  The result is that
    COLO-compare reports inconsistent TCP packets when they are actually
    the same.
    
    Fixes: f449c9e549c ("colo: compare the packet based on the tcp sequence number")
    Cc: qemu-stable@nongnu.org
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Signed-off-by: Fan Yang <Fan_Yang@sjtu.edu.cn>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    (cherry picked from commit 1e907a32b77e5d418538453df5945242e43224fa)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit fcd7cba6acb7344aca70f5f8ec16626e817b35a5
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Tue Aug 6 18:26:11 2019 +0300

    util/hbitmap: strict hbitmap_reset
    
    hbitmap_reset has an unobvious property: it rounds requested region up.
    It may provoke bugs, like in recently fixed write-blocking mode of
    mirror: user calls reset on unaligned region, not keeping in mind that
    there are possible unrelated dirty bytes, covered by rounded-up region
    and information of this unrelated "dirtiness" will be lost.
    
    Make hbitmap_reset strict: assert that arguments are aligned, allowing
    only one exception when @start + @count == hb->orig_size. It's needed
    to comfort users of hbitmap_next_dirty_area, which cares about
    hb->orig_size.
    
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Message-Id: <20190806152611.280389-1-vsementsov@virtuozzo.com>
    [Maintainer edit: Max's suggestions from on-list. --js]
    [Maintainer edit: Eric's suggestion for aligned macro. --js]
    Signed-off-by: John Snow <jsnow@redhat.com>
    (cherry picked from commit 48557b138383aaf69c2617ca9a88bfb394fc50ec)
    *prereq for fed33bd175f663cc8c13f8a490a4f35a19756cfe
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c0b35d87de345bd3b59a44c604b247a0497f2fc0
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Fri Oct 11 12:07:07 2019 +0300

    hbitmap: handle set/reset with zero length
    
    Passing zero length to these functions leads to unpredicted results.
    Zero-length set/reset may occur in active-mirror, on zero-length write
    (which is unlikely, but not guaranteed to never happen).
    
    Let's just do nothing on zero-length request.
    
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Message-id: 20191011090711.19940-2-vsementsov@virtuozzo.com
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit fed33bd175f663cc8c13f8a490a4f35a19756cfe)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit cdc6896659b85f7ed8f7552850312e55170de0c5
Author: Christophe Lyon <christophe.lyon@linaro.org>
Date:   Fri Oct 25 11:57:11 2019 +0200

    target/arm: Allow reading flags from FPSCR for M-profile
    
    rt==15 is a special case when reading the flags: it means the
    destination is APSR. This patch avoids rejecting
    vmrs apsr_nzcv, fpscr
    as illegal instruction.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Christophe Lyon <christophe.lyon@linaro.org>
    Message-id: 20191025095711.10853-1-christophe.lyon@linaro.org
    [PMM: updated the comment]
    Reviewed-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    (cherry picked from commit 2529ab43b8a05534494704e803e0332d111d8b91)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit b387531323ef1e2819f241a7d3bac86fa1ecb8b9
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Tue Oct 8 19:03:33 2019 -0700

    target/xtensa: regenerate and re-import test_mmuhifi_c3 core
    
    Overlay part of the test_mmuhifi_c3 core has GPL3 copyright headers in
    it. Fix that by regenerating test_mmuhifi_c3 core overlay and
    re-importing it.
    
    Fixes: d848ea776728 ("target/xtensa: add test_mmuhifi_c3 core")
    Reported-by: Thomas Huth <thuth@redhat.com>
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    (cherry picked from commit d5eaec84e592bb0085f84bef54d0a41e31faa99a)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 051c9b3cbcb4beb42a6ed017c2146ec3e7a754fb
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Wed Aug 14 17:35:21 2019 +0530

    scsi: lsi: exit infinite loop while executing script (CVE-2019-12068)
    
    When executing script in lsi_execute_script(), the LSI scsi adapter
    emulator advances 's->dsp' index to read next opcode. This can lead
    to an infinite loop if the next opcode is empty. Move the existing
    loop exit after 10k iterations so that it covers no-op opcodes as
    well.
    
    Reported-by: Bugs SysSec <bugs-syssec@rub.de>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    (cherry picked from commit de594e47659029316bbf9391efb79da0a1a08e08)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 01be50603be4f17af4318a7a3fe58dcc6dab1b31
Author: Philippe Mathieu-Daudé <philmd@redhat.com>
Date:   Fri Aug 16 19:15:03 2019 +0200

    virtio-blk: Cancel the pending BH when the dataplane is reset
    
    When 'system_reset' is called, the main loop clear the memory
    region cache before the BH has a chance to execute. Later when
    the deferred function is called, some assumptions that were
    made when scheduling them are no longer true when they actually
    execute.
    
    This is what happens using a virtio-blk device (fresh RHEL7.8 install):
    
     $ (sleep 12.3; echo system_reset; sleep 12.3; echo system_reset; sleep 1; echo q) \
       | qemu-system-x86_64 -m 4G -smp 8 -boot menu=on \
         -device virtio-blk-pci,id=image1,drive=drive_image1 \
         -drive file=/var/lib/libvirt/images/rhel78.qcow2,if=none,id=drive_image1,format=qcow2,cache=none \
         -device virtio-net-pci,netdev=net0,id=nic0,mac=52:54:00:c4:e7:84 \
         -netdev tap,id=net0,script=/bin/true,downscript=/bin/true,vhost=on \
         -monitor stdio -serial null -nographic
      (qemu) system_reset
      (qemu) system_reset
      (qemu) qemu-system-x86_64: hw/virtio/virtio.c:225: vring_get_region_caches: Assertion `caches != NULL' failed.
      Aborted
    
      (gdb) bt
      Thread 1 (Thread 0x7f109c17b680 (LWP 10939)):
      #0  0x00005604083296d1 in vring_get_region_caches (vq=0x56040a24bdd0) at hw/virtio/virtio.c:227
      #1  0x000056040832972b in vring_avail_flags (vq=0x56040a24bdd0) at hw/virtio/virtio.c:235
      #2  0x000056040832d13d in virtio_should_notify (vdev=0x56040a240630, vq=0x56040a24bdd0) at hw/virtio/virtio.c:1648
      #3  0x000056040832d1f8 in virtio_notify_irqfd (vdev=0x56040a240630, vq=0x56040a24bdd0) at hw/virtio/virtio.c:1662
      #4  0x00005604082d213d in notify_guest_bh (opaque=0x56040a243ec0) at hw/block/dataplane/virtio-blk.c:75
      #5  0x000056040883dc35 in aio_bh_call (bh=0x56040a243f10) at util/async.c:90
      #6  0x000056040883dccd in aio_bh_poll (ctx=0x560409161980) at util/async.c:118
      #7  0x0000560408842af7 in aio_dispatch (ctx=0x560409161980) at util/aio-posix.c:460
      #8  0x000056040883e068 in aio_ctx_dispatch (source=0x560409161980, callback=0x0, user_data=0x0) at util/async.c:261
      #9  0x00007f10a8fca06d in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
      #10 0x0000560408841445 in glib_pollfds_poll () at util/main-loop.c:215
      #11 0x00005604088414bf in os_host_main_loop_wait (timeout=0) at util/main-loop.c:238
      #12 0x00005604088415c4 in main_loop_wait (nonblocking=0) at util/main-loop.c:514
      #13 0x0000560408416b1e in main_loop () at vl.c:1923
      #14 0x000056040841e0e8 in main (argc=20, argv=0x7ffc2c3f9c58, envp=0x7ffc2c3f9d00) at vl.c:4578
    
    Fix this by cancelling the BH when the virtio dataplane is stopped.
    
    [This is version of the patch was modified as discussed with Philippe on
    the mailing list thread.
    --Stefan]
    
    Reported-by: Yihuang Yu <yihyu@redhat.com>
    Suggested-by: Stefan Hajnoczi <stefanha@redhat.com>
    Fixes: https://bugs.launchpad.net/qemu/+bug/1839428
    Signed-off-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Message-Id: <20190816171503.24761-1-philmd@redhat.com>
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    (cherry picked from commit ebb6ff25cd888a52a64a9adc3692541c6d1d9a42)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 405deba14f6b61b9c557484b46e863308c8cf373
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Oct 28 17:18:40 2019 +0100

    qcow2: Fix QCOW2_COMPRESSED_SECTOR_MASK
    
    Masks for L2 table entries should have 64 bit.
    
    Fixes: b6c246942b14d3e0dec46a6c5868ed84e7dbea19
    Buglink: https://bugs.launchpad.net/qemu/+bug/1850000
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20191028161841.1198-2-mreitz@redhat.com
    Reviewed-by: Alberto Garcia <berto@igalia.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 24552feb6ae2f615b76c2b95394af43901f75046)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 15f5e8c3675b9eb16e2413d56017c047533407bb
Author: Max Reitz <mreitz@redhat.com>
Date:   Mon Oct 28 17:18:41 2019 +0100

    iotests: Add test for 4G+ compressed qcow2 write
    
    Test what qemu-img check says about an image after one has written
    compressed data to an offset above 4 GB.
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20191028161841.1198-3-mreitz@redhat.com
    Reviewed-by: Alberto Garcia <berto@igalia.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit b7cd2c11f76d27930f53d3cf26d7b695c78d613b)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit b156178553341ab24dcc14efdb7b681375099462
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Oct 11 17:28:13 2019 +0200

    iotests: Add peek_file* functions
    
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Reviewed-by: Eric Blake <eblake@redhat.com>
    Message-id: 20191011152814.14791-16-mreitz@redhat.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit fc8ba423ca6b37bee56ec9dc339b44043c39553d)
    *prereq for 570542ec
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 40df4a1bf7520e0713273d6ebd5a3407b4d83267
Author: Tuguoyi <tu.guoyi@h3c.com>
Date:   Fri Nov 1 07:37:35 2019 +0000

    qcow2-bitmap: Fix uint64_t left-shift overflow
    
    There are two issues in In check_constraints_on_bitmap(),
    1) The sanity check on the granularity will cause uint64_t
    integer left-shift overflow when cluster_size is 2M and the
    granularity is BIGGER than 32K.
    2) The way to calculate image size that the maximum bitmap
    supported can map to is a bit incorrect.
    This patch fix it by add a helper function to calculate the
    number of bytes needed by a normal bitmap in image and compare
    it to the maximum bitmap bytes supported by qemu.
    
    Fixes: 5f72826e7fc62167cf3a
    Signed-off-by: Guoyi Tu <tu.guoyi@h3c.com>
    Message-id: 4ba40cd1e7ee4a708b40899952e49f22@h3c.com
    Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 570542ecb11e04b61ef4b3f4d0965a6915232a88)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit cff024fe856ab36db3056ba4cb1d7cfa4c39795d
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Tue Jun 4 19:15:03 2019 +0300

    util/iov: introduce qemu_iovec_init_extended
    
    Introduce new initialization API, to create requests with padding. Will
    be used in the following patch. New API uses qemu_iovec_init_buf if
    resulting io vector has only one element, to avoid extra allocations.
    So, we need to update qemu_iovec_destroy to support destroying such
    QIOVs.
    
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
    Message-id: 20190604161514.262241-2-vsementsov@virtuozzo.com
    Message-Id: <20190604161514.262241-2-vsementsov@virtuozzo.com>
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    (cherry picked from commit d953169d4840f312d3b9a54952f4a7ccfcb3b311)
    *prereq for 292d06b9
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit b3b76fc643912d2c86b13caff30a1151f2958702
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Tue Jun 4 19:15:04 2019 +0300

    util/iov: improve qemu_iovec_is_zero
    
    We'll need to check a part of qiov soon, so implement it now.
    
    Optimization with align down to 4 * sizeof(long) is dropped due to:
    1. It is strange: it aligns length of the buffer, but where is a
       guarantee that buffer pointer is aligned itself?
    2. buffer_is_zero() is a better place for optimizations and it has
       them.
    
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
    Message-id: 20190604161514.262241-3-vsementsov@virtuozzo.com
    Message-Id: <20190604161514.262241-3-vsementsov@virtuozzo.com>
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    (cherry picked from commit f76889e7b947d896db51be8a4d9c941c2f70365a)
    *prereq for 292d06b9
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 2e2ad02f2cecf419eaad0df982ceb5b41170cc7e
Author: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Date:   Tue Jun 4 19:15:05 2019 +0300

    block/io: refactor padding
    
    We have similar padding code in bdrv_co_pwritev,
    bdrv_co_do_pwrite_zeroes and bdrv_co_preadv. Let's combine and unify
    it.
    
    [Squashed in Vladimir's qemu-iotests 077 fix
    --Stefan]
    
    Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
    Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
    Message-id: 20190604161514.262241-4-vsementsov@virtuozzo.com
    Message-Id: <20190604161514.262241-4-vsementsov@virtuozzo.com>
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    (cherry picked from commit 7a3f542fbdfd799be4fa6f8b96dc8c1e6933fce4)
    *prereq for 292d06b9
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 590cff8230749794ba09b38f3ea4eb6b0f2f73b5
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Nov 1 16:25:08 2019 +0100

    block: Make wait/mark serialising requests public
    
    Make both bdrv_mark_request_serialising() and
    bdrv_wait_serialising_requests() public so they can be used from block
    drivers.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20191101152510.11719-2-mreitz@redhat.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 304d9d7f034ff7f5e1e66a65b7f720f63a72c57e)
     Conflicts:
            block/io.c
    *drop context dependency on 1acc3466a2
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit d9b88f7e0d56feb4d7daa2506e2756fc48e975a1
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Nov 1 16:25:09 2019 +0100

    block: Add bdrv_co_get_self_request()
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20191101152510.11719-3-mreitz@redhat.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit c28107e9e55b11cd35cf3dc2505e3e69d10dcf13)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 7db05c8a732fbdc986a40aadf0de6dd23057d044
Author: Max Reitz <mreitz@redhat.com>
Date:   Fri Nov 1 16:25:10 2019 +0100

    block/file-posix: Let post-EOF fallocate serialize
    
    The XFS kernel driver has a bug that may cause data corruption for qcow2
    images as of qemu commit c8bb23cbdbe32f.  We can work around it by
    treating post-EOF fallocates as serializing up until infinity (INT64_MAX
    in practice).
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    Message-id: 20191101152510.11719-4-mreitz@redhat.com
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit 292d06b925b2787ee6f2430996b95651cae42fce)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit f0d3fa265d074a155164d59af12db72986cfe55d
Author: Nir Soffer <nirsof@gmail.com>
Date:   Tue Aug 13 21:21:03 2019 +0300

    file-posix: Handle undetectable alignment
    
    In some cases buf_align or request_alignment cannot be detected:
    
    1. With Gluster, buf_align cannot be detected since the actual I/O is
       done on Gluster server, and qemu buffer alignment does not matter.
       Since we don't have alignment requirement, buf_align=1 is the best
       value.
    
    2. With local XFS filesystem, buf_align cannot be detected if reading
       from unallocated area. In this we must align the buffer, but we don't
       know what is the correct size. Using the wrong alignment results in
       I/O error.
    
    3. With Gluster backed by XFS, request_alignment cannot be detected if
       reading from unallocated area. In this case we need to use the
       correct alignment, and failing to do so results in I/O errors.
    
    4. With NFS, the server does not use direct I/O, so both buf_align cannot
       be detected. In this case we don't need any alignment so we can use
       buf_align=1 and request_alignment=1.
    
    These cases seems to work when storage sector size is 512 bytes, because
    the current code starts checking align=512. If the check succeeds
    because alignment cannot be detected we use 512. But this does not work
    for storage with 4k sector size.
    
    To determine if we can detect the alignment, we probe first with
    align=1. If probing succeeds, maybe there are no alignment requirement
    (cases 1, 4) or we are probing unallocated area (cases 2, 3). Since we
    don't have any way to tell, we treat this as undetectable alignment. If
    probing with align=1 fails with EINVAL, but probing with one of the
    expected alignments succeeds, we know that we found a working alignment.
    
    Practically the alignment requirements are the same for buffer
    alignment, buffer length, and offset in file. So in case we cannot
    detect buf_align, we can use request alignment. If we cannot detect
    request alignment, we can fallback to a safe value. To use this logic,
    we probe first request alignment instead of buf_align.
    
    Here is a table showing the behaviour with current code (the value in
    parenthesis is the optimal value).
    
    Case    Sector    buf_align (opt)   request_alignment (opt)     result
    ======================================================================
    1       512       512   (1)          512   (512)                 OK
    1       4096      512   (1)          4096  (4096)                FAIL
    ----------------------------------------------------------------------
    2       512       512   (512)        512   (512)                 OK
    2       4096      512   (4096)       4096  (4096)                FAIL
    ----------------------------------------------------------------------
    3       512       512   (1)          512   (512)                 OK
    3       4096      512   (1)          512   (4096)                FAIL
    ----------------------------------------------------------------------
    4       512       512   (1)          512   (1)                   OK
    4       4096      512   (1)          512   (1)                   OK
    
    Same cases with this change:
    
    Case    Sector    buf_align (opt)   request_alignment (opt)     result
    ======================================================================
    1       512       512   (1)          512   (512)                 OK
    1       4096      4096  (1)          4096  (4096)                OK
    ----------------------------------------------------------------------
    2       512       512   (512)        512   (512)                 OK
    2       4096      4096  (4096)       4096  (4096)                OK
    ----------------------------------------------------------------------
    3       512       4096  (1)          4096  (512)                 OK
    3       4096      4096  (1)          4096  (4096)                OK
    ----------------------------------------------------------------------
    4       512       4096  (1)          4096  (1)                   OK
    4       4096      4096  (1)          4096  (1)                   OK
    
    I tested that provisioning VMs and copying disks on local XFS and
    Gluster with 4k bytes sector size work now, resolving bugs [1],[2].
    I tested also on XFS, NFS, Gluster with 512 bytes sector size.
    
    [1] https://bugzilla.redhat.com/1737256
    [2] https://bugzilla.redhat.com/1738657
    
    Signed-off-by: Nir Soffer <nsoffer@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    
    (cherry picked from commit a6b257a08e3d72219f03e461a52152672fec0612)
    
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 3d018ff3bdd8aec260254036b600cfa8d694ced4
Author: Nir Soffer <nirsof@gmail.com>
Date:   Tue Aug 27 04:05:27 2019 +0300

    block: posix: Always allocate the first block
    
    When creating an image with preallocation "off" or "falloc", the first
    block of the image is typically not allocated. When using Gluster
    storage backed by XFS filesystem, reading this block using direct I/O
    succeeds regardless of request length, fooling alignment detection.
    
    In this case we fallback to a safe value (4096) instead of the optimal
    value (512), which may lead to unneeded data copying when aligning
    requests.  Allocating the first block avoids the fallback.
    
    Since we allocate the first block even with preallocation=off, we no
    longer create images with zero disk size:
    
        $ ./qemu-img create -f raw test.raw 1g
        Formatting 'test.raw', fmt=raw size=1073741824
    
        $ ls -lhs test.raw
        4.0K -rw-r--r--. 1 nsoffer nsoffer 1.0G Aug 16 23:48 test.raw
    
    And converting the image requires additional cluster:
    
        $ ./qemu-img measure -f raw -O qcow2 test.raw
        required size: 458752
        fully allocated size: 1074135040
    
    When using format like vmdk with multiple files per image, we allocate
    one block per file:
    
        $ ./qemu-img create -f vmdk -o subformat=twoGbMaxExtentFlat test.vmdk 4g
        Formatting 'test.vmdk', fmt=vmdk size=4294967296 compat6=off hwversion=undefined subformat=twoGbMaxExtentFlat
    
        $ ls -lhs test*.vmdk
        4.0K -rw-r--r--. 1 nsoffer nsoffer 2.0G Aug 27 03:23 test-f001.vmdk
        4.0K -rw-r--r--. 1 nsoffer nsoffer 2.0G Aug 27 03:23 test-f002.vmdk
        4.0K -rw-r--r--. 1 nsoffer nsoffer  353 Aug 27 03:23 test.vmdk
    
    I did quick performance test for copying disks with qemu-img convert to
    new raw target image to Gluster storage with sector size of 512 bytes:
    
        for i in $(seq 10); do
            rm -f dst.raw
            sleep 10
            time ./qemu-img convert -f raw -O raw -t none -T none src.raw dst.raw
        done
    
    Here is a table comparing the total time spent:
    
    Type    Before(s)   After(s)    Diff(%)
    ---------------------------------------
    real      530.028    469.123      -11.4
    user       17.204     10.768      -37.4
    sys        17.881      7.011      -60.7
    
    We can see very clear improvement in CPU usage.
    
    Signed-off-by: Nir Soffer <nsoffer@redhat.com>
    Message-id: 20190827010528.8818-2-nsoffer@redhat.com
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    Signed-off-by: Max Reitz <mreitz@redhat.com>
    
    (cherry picked from commit 3a20013fbb26d2a1bd11ef148eefdb1508783787)
    
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 54c130493c544573253f5bbdcdb705f3d79377f0
Author: Daniel P. Berrangé <berrange@redhat.com>
Date:   Wed Aug 21 16:14:27 2019 +0100

    tests: make filemonitor test more robust to event ordering
    
    The ordering of events that are emitted during the rmdir
    test have changed with kernel >= 5.3. Semantically both
    new & old orderings are correct, so we must be able to
    cope with either.
    
    To cope with this, when we see an unexpected event, we
    push it back onto the queue and look and the subsequent
    event to see if that matches instead.
    
    Tested-by: Peter Xu <peterx@redhat.com>
    Tested-by: Wei Yang <richardw.yang@linux.intel.com>
    Tested-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: Thomas Huth <thuth@redhat.com>
    Signed-off-by: Daniel P. Berrangé <berrange@redhat.com>
    (cherry picked from commit bf9e0313c27d8e6ecd7f7de3d63e1cb25d8f6311)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit c0aca9352d51c102c55fe29ce5c1bf8e74a5183e
Author: Dr. David Alan Gilbert <dgilbert@redhat.com>
Date:   Wed Aug 14 18:55:33 2019 +0100

    memory: Align MemoryRegionSections fields
    
    MemoryRegionSection includes an Int128 'size' field;
    on some platforms the compiler causes an alignment of this to
    a 128bit boundary, leaving 8 bytes of dead space.
    This deadspace can be filled with junk.
    
    Move the size field to the top avoiding unnecessary alignment.
    
    Signed-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Message-Id: <20190814175535.2023-2-dgilbert@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    (cherry picked from commit 44f85d3276397cfa2cfa379c61430405dad4e644)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 42b6571357a083f721a27daa6dfdc69e4bd516bd
Author: Dr. David Alan Gilbert <dgilbert@redhat.com>
Date:   Wed Aug 14 18:55:34 2019 +0100

    memory: Provide an equality function for MemoryRegionSections
    
    Provide a comparison function that checks all the fields are the same.
    
    Signed-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
    Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Message-Id: <20190814175535.2023-3-dgilbert@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    (cherry picked from commit 9366cf02e4e31c2a8128904d4d8290a0fad5f888)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 145b562990d252aeca7c37c21eb7e7110cfceffc
Author: Dr. David Alan Gilbert <dgilbert@redhat.com>
Date:   Wed Aug 14 18:55:35 2019 +0100

    vhost: Fix memory region section comparison
    
    Using memcmp to compare structures wasn't safe,
    as I found out on ARM when I was getting falce miscompares.
    
    Use the helper function for comparing the MRSs.
    
    Fixes: ade6d081fc33948e56e6 ("vhost: Regenerate region list from changed sections list")
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
    Message-Id: <20190814175535.2023-4-dgilbert@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    (cherry picked from commit 3fc4a64cbaed2ddee4c60ddc06740b320e18ab82)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 088f1e8fd9e790bc5766bd43af134230abcff6dd
Author: Philippe Mathieu-Daudé <philmd@redhat.com>
Date:   Thu Sep 12 00:08:49 2019 +0200

    block/create: Do not abort if a block driver is not available
    
    The 'blockdev-create' QMP command was introduced as experimental
    feature in commit b0292b851b8, using the assert() debug call.
    It got promoted to 'stable' command in 3fb588a0f2c, but the
    assert call was not removed.
    
    Some block drivers are optional, and bdrv_find_format() might
    return a NULL value, triggering the assertion.
    
    Stable code is not expected to abort, so return an error instead.
    
    This is easily reproducible when libnfs is not installed:
    
      ./configure
      [...]
      module support    no
      Block whitelist (rw)
      Block whitelist (ro)
      libiscsi support  yes
      libnfs support    no
      [...]
    
    Start QEMU:
    
      $ qemu-system-x86_64 -S -qmp unix:/tmp/qemu.qmp,server,nowait
    
    Send the 'blockdev-create' with the 'nfs' driver:
    
      $ ( cat << 'EOF'
      {'execute': 'qmp_capabilities'}
      {'execute': 'blockdev-create', 'arguments': {'job-id': 'x', 'options': {'size': 0, 'driver': 'nfs', 'location': {'path': '/', 'server': {'host': '::1', 'type': 'inet'}}}}, 'id': 'x'}
      EOF
      ) | socat STDIO UNIX:/tmp/qemu.qmp
      {"QMP": {"version": {"qemu": {"micro": 50, "minor": 1, "major": 4}, "package": "v4.1.0-733-g89ea03a7dc"}, "capabilities": ["oob"]}}
      {"return": {}}
    
    QEMU crashes:
    
      $ gdb qemu-system-x86_64 core
      Program received signal SIGSEGV, Segmentation fault.
      (gdb) bt
      #0  0x00007ffff510957f in raise () at /lib64/libc.so.6
      #1  0x00007ffff50f3895 in abort () at /lib64/libc.so.6
      #2  0x00007ffff50f3769 in _nl_load_domain.cold.0 () at /lib64/libc.so.6
      #3  0x00007ffff5101a26 in .annobin_assert.c_end () at /lib64/libc.so.6
      #4  0x0000555555d7e1f1 in qmp_blockdev_create (job_id=0x555556baee40 "x", options=0x555557666610, errp=0x7fffffffc770) at block/create.c:69
      #5  0x0000555555c96b52 in qmp_marshal_blockdev_create (args=0x7fffdc003830, ret=0x7fffffffc7f8, errp=0x7fffffffc7f0) at qapi/qapi-commands-block-core.c:1314
      #6  0x0000555555deb0a0 in do_qmp_dispatch (cmds=0x55555645de70 <qmp_commands>, request=0x7fffdc005c70, allow_oob=false, errp=0x7fffffffc898) at qapi/qmp-dispatch.c:131
      #7  0x0000555555deb2a1 in qmp_dispatch (cmds=0x55555645de70 <qmp_commands>, request=0x7fffdc005c70, allow_oob=false) at qapi/qmp-dispatch.c:174
    
    With this patch applied, QEMU returns a QMP error:
    
      {'execute': 'blockdev-create', 'arguments': {'job-id': 'x', 'options': {'size': 0, 'driver': 'nfs', 'location': {'path': '/', 'server': {'host': '::1', 'type': 'inet'}}}}, 'id': 'x'}
      {"id": "x", "error": {"class": "GenericError", "desc": "Block driver 'nfs' not found or not supported"}}
    
    Cc: qemu-stable@nongnu.org
    Reported-by: Xu Tian <xutian@redhat.com>
    Signed-off-by: Philippe Mathieu-Daudé <philmd@redhat.com>
    Reviewed-by: Eric Blake <eblake@redhat.com>
    Reviewed-by: John Snow <jsnow@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    (cherry picked from commit d90d5cae2b10efc0e8d0b3cc91ff16201853d3ba)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit e092a17d3825a8f2c93cb429aaa5d857b579b64c
Author: Kevin Wolf <kwolf@redhat.com>
Date:   Mon Jul 22 17:44:27 2019 +0200

    mirror: Keep mirror_top_bs drained after dropping permissions
    
    mirror_top_bs is currently implicitly drained through its connection to
    the source or the target node. However, the drain section for target_bs
    ends early after moving mirror_top_bs from src to target_bs, so that
    requests can already be restarted while mirror_top_bs is still present
    in the chain, but has dropped all permissions and therefore runs into an
    assertion failure like this:
    
        qemu-system-x86_64: block/io.c:1634: bdrv_co_write_req_prepare:
        Assertion `child->perm & BLK_PERM_WRITE' failed.
    
    Keep mirror_top_bs drained until all graph changes have completed.
    
    Cc: qemu-stable@nongnu.org
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>
    Reviewed-by: Max Reitz <mreitz@redhat.com>
    (cherry picked from commit d2da5e288a2e71e82866c8fdefd41b5727300124)
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

commit 99c5874a9b6c9f70aef285d6eff85d4f46de3c52
Author: Michael Roth <mdroth@linux.vnet.ibm.com>
Date:   Thu Nov 14 12:04:03 2019 -0600

    Update version for 4.1.1 release
    
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>
diff --git a/VERSION b/VERSION
index ee74734aa2..627a3f43a6 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-4.1.0
+4.1.1
diff --git a/block/backup.c b/block/backup.c
index b26c22c4b8..8761f1f9a7 100644
--- a/block/backup.c
+++ b/block/backup.c
@@ -167,7 +167,7 @@ static int coroutine_fn backup_cow_with_offload(BackupBlockJob *job,
 
     assert(QEMU_IS_ALIGNED(job->copy_range_size, job->cluster_size));
     assert(QEMU_IS_ALIGNED(start, job->cluster_size));
-    nbytes = MIN(job->copy_range_size, end - start);
+    nbytes = MIN(job->copy_range_size, MIN(end, job->len) - start);
     nr_clusters = DIV_ROUND_UP(nbytes, job->cluster_size);
     hbitmap_reset(job->copy_bitmap, start, job->cluster_size * nr_clusters);
     ret = blk_co_copy_range(blk, start, job->target, start, nbytes,
@@ -657,12 +657,19 @@ BlockJob *backup_job_create(const char *job_id, BlockDriverState *bs,
     job->cluster_size = cluster_size;
     job->copy_bitmap = copy_bitmap;
     copy_bitmap = NULL;
-    job->use_copy_range = !compress; /* compression isn't supported for it */
     job->copy_range_size = MIN_NON_ZERO(blk_get_max_transfer(job->common.blk),
                                         blk_get_max_transfer(job->target));
-    job->copy_range_size = MAX(job->cluster_size,
-                               QEMU_ALIGN_UP(job->copy_range_size,
-                                             job->cluster_size));
+    job->copy_range_size = QEMU_ALIGN_DOWN(job->copy_range_size,
+                                           job->cluster_size);
+    /*
+     * Set use_copy_range, consider the following:
+     * 1. Compression is not supported for copy_range.
+     * 2. copy_range does not respect max_transfer (it's a TODO), so we factor
+     *    that in here. If max_transfer is smaller than the job->cluster_size,
+     *    we do not use copy_range (in that case it's zero after aligning down
+     *    above).
+     */
+    job->use_copy_range = !compress && job->copy_range_size > 0;
 
     /* Required permissions are already taken with target's blk_new() */
     block_job_add_bdrv(&job->common, "target", target, 0, BLK_PERM_ALL,
diff --git a/block/create.c b/block/create.c
index 95341219ef..de5e97bb18 100644
--- a/block/create.c
+++ b/block/create.c
@@ -63,9 +63,13 @@ void qmp_blockdev_create(const char *job_id, BlockdevCreateOptions *options,
     const char *fmt = BlockdevDriver_str(options->driver);
     BlockDriver *drv = bdrv_find_format(fmt);
 
+    if (!drv) {
+        error_setg(errp, "Block driver '%s' not found or not supported", fmt);
+        return;
+    }
+
     /* If the driver is in the schema, we know that it exists. But it may not
      * be whitelisted. */
-    assert(drv);
     if (bdrv_uses_whitelist() && !bdrv_is_whitelisted(drv, false)) {
         error_setg(errp, "Driver is not whitelisted");
         return;
diff --git a/block/curl.c b/block/curl.c
index d4c8e94f3e..c343c7ed3d 100644
--- a/block/curl.c
+++ b/block/curl.c
@@ -80,6 +80,7 @@ static CURLMcode __curl_multi_socket_action(CURLM *multi_handle,
 #define CURL_BLOCK_OPT_TIMEOUT_DEFAULT 5
 
 struct BDRVCURLState;
+struct CURLState;
 
 static bool libcurl_initialized;
 
@@ -97,6 +98,7 @@ typedef struct CURLAIOCB {
 
 typedef struct CURLSocket {
     int fd;
+    struct CURLState *state;
     QLIST_ENTRY(CURLSocket) next;
 } CURLSocket;
 
@@ -137,7 +139,6 @@ typedef struct BDRVCURLState {
 
 static void curl_clean_state(CURLState *s);
 static void curl_multi_do(void *arg);
-static void curl_multi_read(void *arg);
 
 #ifdef NEED_CURL_TIMER_CALLBACK
 /* Called from curl_multi_do_locked, with s->mutex held.  */
@@ -170,33 +171,29 @@ static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
 
     QLIST_FOREACH(socket, &state->sockets, next) {
         if (socket->fd == fd) {
-            if (action == CURL_POLL_REMOVE) {
-                QLIST_REMOVE(socket, next);
-                g_free(socket);
-            }
             break;
         }
     }
     if (!socket) {
         socket = g_new0(CURLSocket, 1);
         socket->fd = fd;
+        socket->state = state;
         QLIST_INSERT_HEAD(&state->sockets, socket, next);
     }
-    socket = NULL;
 
     trace_curl_sock_cb(action, (int)fd);
     switch (action) {
         case CURL_POLL_IN:
             aio_set_fd_handler(s->aio_context, fd, false,
-                               curl_multi_read, NULL, NULL, state);
+                               curl_multi_do, NULL, NULL, socket);
             break;
         case CURL_POLL_OUT:
             aio_set_fd_handler(s->aio_context, fd, false,
-                               NULL, curl_multi_do, NULL, state);
+                               NULL, curl_multi_do, NULL, socket);
             break;
         case CURL_POLL_INOUT:
             aio_set_fd_handler(s->aio_context, fd, false,
-                               curl_multi_read, curl_multi_do, NULL, state);
+                               curl_multi_do, curl_multi_do, NULL, socket);
             break;
         case CURL_POLL_REMOVE:
             aio_set_fd_handler(s->aio_context, fd, false,
@@ -204,6 +201,11 @@ static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
             break;
     }
 
+    if (action == CURL_POLL_REMOVE) {
+        QLIST_REMOVE(socket, next);
+        g_free(socket);
+    }
+
     return 0;
 }
 
@@ -227,7 +229,6 @@ static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)
 {
     CURLState *s = ((CURLState*)opaque);
     size_t realsize = size * nmemb;
-    int i;
 
     trace_curl_read_cb(realsize);
 
@@ -243,32 +244,6 @@ static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)
     memcpy(s->orig_buf + s->buf_off, ptr, realsize);
     s->buf_off += realsize;
 
-    for(i=0; i<CURL_NUM_ACB; i++) {
-        CURLAIOCB *acb = s->acb[i];
-
-        if (!acb)
-            continue;
-
-        if ((s->buf_off >= acb->end)) {
-            size_t request_length = acb->bytes;
-
-            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,
-                                acb->end - acb->start);
-
-            if (acb->end - acb->start < request_length) {
-                size_t offset = acb->end - acb->start;
-                qemu_iovec_memset(acb->qiov, offset, 0,
-                                  request_length - offset);
-            }
-
-            acb->ret = 0;
-            s->acb[i] = NULL;
-            qemu_mutex_unlock(&s->s->mutex);
-            aio_co_wake(acb->co);
-            qemu_mutex_lock(&s->s->mutex);
-        }
-    }
-
 read_end:
     /* curl will error out if we do not return this value */
     return size * nmemb;
@@ -349,13 +324,14 @@ static void curl_multi_check_completion(BDRVCURLState *s)
             break;
 
         if (msg->msg == CURLMSG_DONE) {
+            int i;
             CURLState *state = NULL;
+            bool error = msg->data.result != CURLE_OK;
+
             curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE,
                               (char **)&state);
 
-            /* ACBs for successful messages get completed in curl_read_cb */
-            if (msg->data.result != CURLE_OK) {
-                int i;
+            if (error) {
                 static int errcount = 100;
 
                 /* Don't lose the original error message from curl, since
@@ -367,20 +343,35 @@ static void curl_multi_check_completion(BDRVCURLState *s)
                         error_report("curl: further errors suppressed");
                     }
                 }
+            }
 
-                for (i = 0; i < CURL_NUM_ACB; i++) {
-                    CURLAIOCB *acb = state->acb[i];
+            for (i = 0; i < CURL_NUM_ACB; i++) {
+                CURLAIOCB *acb = state->acb[i];
 
-                    if (acb == NULL) {
-                        continue;
-                    }
+                if (acb == NULL) {
+                    continue;
+                }
+
+                if (!error) {
+                    /* Assert that we have read all data */
+                    assert(state->buf_off >= acb->end);
 
-                    acb->ret = -EIO;
-                    state->acb[i] = NULL;
-                    qemu_mutex_unlock(&s->mutex);
-                    aio_co_wake(acb->co);
-                    qemu_mutex_lock(&s->mutex);
+                    qemu_iovec_from_buf(acb->qiov, 0,
+                                        state->orig_buf + acb->start,
+                                        acb->end - acb->start);
+
+                    if (acb->end - acb->start < acb->bytes) {
+                        size_t offset = acb->end - acb->start;
+                        qemu_iovec_memset(acb->qiov, offset, 0,
+                                          acb->bytes - offset);
+                    }
                 }
+
+                acb->ret = error ? -EIO : 0;
+                state->acb[i] = NULL;
+                qemu_mutex_unlock(&s->mutex);
+                aio_co_wake(acb->co);
+                qemu_mutex_lock(&s->mutex);
             }
 
             curl_clean_state(state);
@@ -390,42 +381,30 @@ static void curl_multi_check_completion(BDRVCURLState *s)
 }
 
 /* Called with s->mutex held.  */
-static void curl_multi_do_locked(CURLState *s)
+static void curl_multi_do_locked(CURLSocket *socket)
 {
-    CURLSocket *socket, *next_socket;
+    BDRVCURLState *s = socket->state->s;
     int running;
     int r;
 
-    if (!s->s->multi) {
+    if (!s->multi) {
         return;
     }
 
-    /* Need to use _SAFE because curl_multi_socket_action() may trigger
-     * curl_sock_cb() which might modify this list */
-    QLIST_FOREACH_SAFE(socket, &s->sockets, next, next_socket) {
-        do {
-            r = curl_multi_socket_action(s->s->multi, socket->fd, 0, &running);
-        } while (r == CURLM_CALL_MULTI_PERFORM);
-    }
+    do {
+        r = curl_multi_socket_action(s->multi, socket->fd, 0, &running);
+    } while (r == CURLM_CALL_MULTI_PERFORM);
 }
 
 static void curl_multi_do(void *arg)
 {
-    CURLState *s = (CURLState *)arg;
-
-    qemu_mutex_lock(&s->s->mutex);
-    curl_multi_do_locked(s);
-    qemu_mutex_unlock(&s->s->mutex);
-}
-
-static void curl_multi_read(void *arg)
-{
-    CURLState *s = (CURLState *)arg;
+    CURLSocket *socket = arg;
+    BDRVCURLState *s = socket->state->s;
 
-    qemu_mutex_lock(&s->s->mutex);
-    curl_multi_do_locked(s);
-    curl_multi_check_completion(s->s);
-    qemu_mutex_unlock(&s->s->mutex);
+    qemu_mutex_lock(&s->mutex);
+    curl_multi_do_locked(socket);
+    curl_multi_check_completion(s);
+    qemu_mutex_unlock(&s->mutex);
 }
 
 static void curl_multi_timeout_do(void *arg)
diff --git a/block/file-posix.c b/block/file-posix.c
index 4479cc7ab4..2184aa980c 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -323,6 +323,7 @@ static void raw_probe_alignment(BlockDriverState *bs, int fd, Error **errp)
     BDRVRawState *s = bs->opaque;
     char *buf;
     size_t max_align = MAX(MAX_BLOCKSIZE, getpagesize());
+    size_t alignments[] = {1, 512, 1024, 2048, 4096};
 
     /* For SCSI generic devices the alignment is not really used.
        With buffered I/O, we don't have any restrictions. */
@@ -349,25 +350,38 @@ static void raw_probe_alignment(BlockDriverState *bs, int fd, Error **errp)
     }
 #endif
 
-    /* If we could not get the sizes so far, we can only guess them */
-    if (!s->buf_align) {
+    /*
+     * If we could not get the sizes so far, we can only guess them. First try
+     * to detect request alignment, since it is more likely to succeed. Then
+     * try to detect buf_align, which cannot be detected in some cases (e.g.
+     * Gluster). If buf_align cannot be detected, we fallback to the value of
+     * request_alignment.
+     */
+
+    if (!bs->bl.request_alignment) {
+        int i;
         size_t align;
-        buf = qemu_memalign(max_align, 2 * max_align);
-        for (align = 512; align <= max_align; align <<= 1) {
-            if (raw_is_io_aligned(fd, buf + align, max_align)) {
-                s->buf_align = align;
+        buf = qemu_memalign(max_align, max_align);
+        for (i = 0; i < ARRAY_SIZE(alignments); i++) {
+            align = alignments[i];
+            if (raw_is_io_aligned(fd, buf, align)) {
+                /* Fallback to safe value. */
+                bs->bl.request_alignment = (align != 1) ? align : max_align;
                 break;
             }
         }
         qemu_vfree(buf);
     }
 
-    if (!bs->bl.request_alignment) {
+    if (!s->buf_align) {
+        int i;
         size_t align;
-        buf = qemu_memalign(s->buf_align, max_align);
-        for (align = 512; align <= max_align; align <<= 1) {
-            if (raw_is_io_aligned(fd, buf, align)) {
-                bs->bl.request_alignment = align;
+        buf = qemu_memalign(max_align, 2 * max_align);
+        for (i = 0; i < ARRAY_SIZE(alignments); i++) {
+            align = alignments[i];
+            if (raw_is_io_aligned(fd, buf + align, max_align)) {
+                /* Fallback to request_aligment. */
+                s->buf_align = (align != 1) ? align : bs->bl.request_alignment;
                 break;
             }
         }
@@ -1445,59 +1459,6 @@ out:
     }
 }
 
-#ifdef CONFIG_XFS
-static int xfs_write_zeroes(BDRVRawState *s, int64_t offset, uint64_t bytes)
-{
-    int64_t len;
-    struct xfs_flock64 fl;
-    int err;
-
-    len = lseek(s->fd, 0, SEEK_END);
-    if (len < 0) {
-        return -errno;
-    }
-
-    if (offset + bytes > len) {
-        /* XFS_IOC_ZERO_RANGE does not increase the file length */
-        if (ftruncate(s->fd, offset + bytes) < 0) {
-            return -errno;
-        }
-    }
-
-    memset(&fl, 0, sizeof(fl));
-    fl.l_whence = SEEK_SET;
-    fl.l_start = offset;
-    fl.l_len = bytes;
-
-    if (xfsctl(NULL, s->fd, XFS_IOC_ZERO_RANGE, &fl) < 0) {
-        err = errno;
-        trace_file_xfs_write_zeroes(strerror(errno));
-        return -err;
-    }
-
-    return 0;
-}
-
-static int xfs_discard(BDRVRawState *s, int64_t offset, uint64_t bytes)
-{
-    struct xfs_flock64 fl;
-    int err;
-
-    memset(&fl, 0, sizeof(fl));
-    fl.l_whence = SEEK_SET;
-    fl.l_start = offset;
-    fl.l_len = bytes;
-
-    if (xfsctl(NULL, s->fd, XFS_IOC_UNRESVSP64, &fl) < 0) {
-        err = errno;
-        trace_file_xfs_discard(strerror(errno));
-        return -err;
-    }
-
-    return 0;
-}
-#endif
-
 static int translate_err(int err)
 {
     if (err == -ENODEV || err == -ENOSYS || err == -EOPNOTSUPP ||
@@ -1553,10 +1514,8 @@ static ssize_t handle_aiocb_write_zeroes_block(RawPosixAIOData *aiocb)
 static int handle_aiocb_write_zeroes(void *opaque)
 {
     RawPosixAIOData *aiocb = opaque;
-#if defined(CONFIG_FALLOCATE) || defined(CONFIG_XFS)
-    BDRVRawState *s = aiocb->bs->opaque;
-#endif
 #ifdef CONFIG_FALLOCATE
+    BDRVRawState *s = aiocb->bs->opaque;
     int64_t len;
 #endif
 
@@ -1564,12 +1523,6 @@ static int handle_aiocb_write_zeroes(void *opaque)
         return handle_aiocb_write_zeroes_block(aiocb);
     }
 
-#ifdef CONFIG_XFS
-    if (s->is_xfs) {
-        return xfs_write_zeroes(s, aiocb->aio_offset, aiocb->aio_nbytes);
-    }
-#endif
-
 #ifdef CONFIG_FALLOCATE_ZERO_RANGE
     if (s->has_write_zeroes) {
         int ret = do_fallocate(s->fd, FALLOC_FL_ZERO_RANGE,
@@ -1632,14 +1585,6 @@ static int handle_aiocb_write_zeroes_unmap(void *opaque)
     }
 #endif
 
-#ifdef CONFIG_XFS
-    if (s->is_xfs) {
-        /* xfs_discard() guarantees that the discarded area reads as all-zero
-         * afterwards, so we can use it here. */
-        return xfs_discard(s, aiocb->aio_offset, aiocb->aio_nbytes);
-    }
-#endif
-
     /* If we couldn't manage to unmap while guaranteed that the area reads as
      * all-zero afterwards, just write zeroes without unmapping */
     ret = handle_aiocb_write_zeroes(aiocb);
@@ -1716,12 +1661,6 @@ static int handle_aiocb_discard(void *opaque)
         ret = -errno;
 #endif
     } else {
-#ifdef CONFIG_XFS
-        if (s->is_xfs) {
-            return xfs_discard(s, aiocb->aio_offset, aiocb->aio_nbytes);
-        }
-#endif
-
 #ifdef CONFIG_FALLOCATE_PUNCH_HOLE
         ret = do_fallocate(s->fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
                            aiocb->aio_offset, aiocb->aio_nbytes);
@@ -1735,6 +1674,43 @@ static int handle_aiocb_discard(void *opaque)
     return ret;
 }
 
+/*
+ * Help alignment probing by allocating the first block.
+ *
+ * When reading with direct I/O from unallocated area on Gluster backed by XFS,
+ * reading succeeds regardless of request length. In this case we fallback to
+ * safe alignment which is not optimal. Allocating the first block avoids this
+ * fallback.
+ *
+ * fd may be opened with O_DIRECT, but we don't know the buffer alignment or
+ * request alignment, so we use safe values.
+ *
+ * Returns: 0 on success, -errno on failure. Since this is an optimization,
+ * caller may ignore failures.
+ */
+static int allocate_first_block(int fd, size_t max_size)
+{
+    size_t write_size = (max_size < MAX_BLOCKSIZE)
+        ? BDRV_SECTOR_SIZE
+        : MAX_BLOCKSIZE;
+    size_t max_align = MAX(MAX_BLOCKSIZE, getpagesize());
+    void *buf;
+    ssize_t n;
+    int ret;
+
+    buf = qemu_memalign(max_align, write_size);
+    memset(buf, 0, write_size);
+
+    do {
+        n = pwrite(fd, buf, write_size, 0);
+    } while (n == -1 && errno == EINTR);
+
+    ret = (n == -1) ? -errno : 0;
+
+    qemu_vfree(buf);
+    return ret;
+}
+
 static int handle_aiocb_truncate(void *opaque)
 {
     RawPosixAIOData *aiocb = opaque;
@@ -1774,6 +1750,17 @@ static int handle_aiocb_truncate(void *opaque)
                 /* posix_fallocate() doesn't set errno. */
                 error_setg_errno(errp, -result,
                                  "Could not preallocate new data");
+            } else if (current_length == 0) {
+                /*
+                 * posix_fallocate() uses fallocate() if the filesystem
+                 * supports it, or fallback to manually writing zeroes. If
+                 * fallocate() was used, unaligned reads from the fallocated
+                 * area in raw_probe_alignment() will succeed, hence we need to
+                 * allocate the first block.
+                 *
+                 * Optimize future alignment probing; ignore failures.
+                 */
+                allocate_first_block(fd, offset);
             }
         } else {
             result = 0;
@@ -1835,6 +1822,9 @@ static int handle_aiocb_truncate(void *opaque)
         if (ftruncate(fd, offset) != 0) {
             result = -errno;
             error_setg_errno(errp, -result, "Could not resize file");
+        } else if (current_length == 0 && offset > current_length) {
+            /* Optimize future alignment probing; ignore failures. */
+            allocate_first_block(fd, offset);
         }
         return result;
     default:
@@ -2698,6 +2688,42 @@ raw_do_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int bytes,
     RawPosixAIOData acb;
     ThreadPoolFunc *handler;
 
+#ifdef CONFIG_FALLOCATE
+    if (offset + bytes > bs->total_sectors * BDRV_SECTOR_SIZE) {
+        BdrvTrackedRequest *req;
+        uint64_t end;
+
+        /*
+         * This is a workaround for a bug in the Linux XFS driver,
+         * where writes submitted through the AIO interface will be
+         * discarded if they happen beyond a concurrently running
+         * fallocate() that increases the file length (i.e., both the
+         * write and the fallocate() happen beyond the EOF).
+         *
+         * To work around it, we extend the tracked request for this
+         * zero write until INT64_MAX (effectively infinity), and mark
+         * it as serializing.
+         *
+         * We have to enable this workaround for all filesystems and
+         * AIO modes (not just XFS with aio=native), because for
+         * remote filesystems we do not know the host configuration.
+         */
+
+        req = bdrv_co_get_self_request(bs);
+        assert(req);
+        assert(req->type == BDRV_TRACKED_WRITE);
+        assert(req->offset <= offset);
+        assert(req->offset + req->bytes >= offset + bytes);
+
+        end = INT64_MAX & -(uint64_t)bs->bl.request_alignment;
+        req->bytes = end - req->offset;
+        req->overlap_bytes = req->bytes;
+
+        bdrv_mark_request_serialising(req, bs->bl.request_alignment);
+        bdrv_wait_serialising_requests(req);
+    }
+#endif
+
     acb = (RawPosixAIOData) {
         .bs             = bs,
         .aio_fildes     = s->fd,
diff --git a/block/io.c b/block/io.c
index 06305c6ea6..65b5102714 100644
--- a/block/io.c
+++ b/block/io.c
@@ -694,7 +694,7 @@ static void tracked_request_begin(BdrvTrackedRequest *req,
     qemu_co_mutex_unlock(&bs->reqs_lock);
 }
 
-static void mark_request_serialising(BdrvTrackedRequest *req, uint64_t align)
+void bdrv_mark_request_serialising(BdrvTrackedRequest *req, uint64_t align)
 {
     int64_t overlap_offset = req->offset & ~(align - 1);
     uint64_t overlap_bytes = ROUND_UP(req->offset + req->bytes, align)
@@ -721,6 +721,24 @@ static bool is_request_serialising_and_aligned(BdrvTrackedRequest *req)
            (req->bytes == req->overlap_bytes);
 }
 
+/**
+ * Return the tracked request on @bs for the current coroutine, or
+ * NULL if there is none.
+ */
+BdrvTrackedRequest *coroutine_fn bdrv_co_get_self_request(BlockDriverState *bs)
+{
+    BdrvTrackedRequest *req;
+    Coroutine *self = qemu_coroutine_self();
+
+    QLIST_FOREACH(req, &bs->tracked_requests, list) {
+        if (req->co == self) {
+            return req;
+        }
+    }
+
+    return NULL;
+}
+
 /**
  * Round a region to cluster boundaries
  */
@@ -784,7 +802,7 @@ void bdrv_dec_in_flight(BlockDriverState *bs)
     bdrv_wakeup(bs);
 }
 
-static bool coroutine_fn wait_serialising_requests(BdrvTrackedRequest *self)
+bool coroutine_fn bdrv_wait_serialising_requests(BdrvTrackedRequest *self)
 {
     BlockDriverState *bs = self->bs;
     BdrvTrackedRequest *req;
@@ -1340,14 +1358,14 @@ static int coroutine_fn bdrv_aligned_preadv(BdrvChild *child,
          * with each other for the same cluster.  For example, in copy-on-read
          * it ensures that the CoR read and write operations are atomic and
          * guest writes cannot interleave between them. */
-        mark_request_serialising(req, bdrv_get_cluster_size(bs));
+        bdrv_mark_request_serialising(req, bdrv_get_cluster_size(bs));
     }
 
     /* BDRV_REQ_SERIALISING is only for write operation */
     assert(!(flags & BDRV_REQ_SERIALISING));
 
     if (!(flags & BDRV_REQ_NO_SERIALISING)) {
-        wait_serialising_requests(req);
+        bdrv_wait_serialising_requests(req);
     }
 
     if (flags & BDRV_REQ_COPY_ON_READ) {
@@ -1408,28 +1426,177 @@ out:
 }
 
 /*
- * Handle a read request in coroutine context
+ * Request padding
+ *
+ *  |<---- align ----->|                     |<----- align ---->|
+ *  |<- head ->|<------------- bytes ------------->|<-- tail -->|
+ *  |          |       |                     |     |            |
+ * -*----------$-------*-------- ... --------*-----$------------*---
+ *  |          |       |                     |     |            |
+ *  |          offset  |                     |     end          |
+ *  ALIGN_DOWN(offset) ALIGN_UP(offset)      ALIGN_DOWN(end)   ALIGN_UP(end)
+ *  [buf   ... )                             [tail_buf          )
+ *
+ * @buf is an aligned allocation needed to store @head and @tail paddings. @head
+ * is placed at the beginning of @buf and @tail at the @end.
+ *
+ * @tail_buf is a pointer to sub-buffer, corresponding to align-sized chunk
+ * around tail, if tail exists.
+ *
+ * @merge_reads is true for small requests,
+ * if @buf_len == @head + bytes + @tail. In this case it is possible that both
+ * head and tail exist but @buf_len == align and @tail_buf == @buf.
+ */
+typedef struct BdrvRequestPadding {
+    uint8_t *buf;
+    size_t buf_len;
+    uint8_t *tail_buf;
+    size_t head;
+    size_t tail;
+    bool merge_reads;
+    QEMUIOVector local_qiov;
+} BdrvRequestPadding;
+
+static bool bdrv_init_padding(BlockDriverState *bs,
+                              int64_t offset, int64_t bytes,
+                              BdrvRequestPadding *pad)
+{
+    uint64_t align = bs->bl.request_alignment;
+    size_t sum;
+
+    memset(pad, 0, sizeof(*pad));
+
+    pad->head = offset & (align - 1);
+    pad->tail = ((offset + bytes) & (align - 1));
+    if (pad->tail) {
+        pad->tail = align - pad->tail;
+    }
+
+    if ((!pad->head && !pad->tail) || !bytes) {
+        return false;
+    }
+
+    sum = pad->head + bytes + pad->tail;
+    pad->buf_len = (sum > align && pad->head && pad->tail) ? 2 * align : align;
+    pad->buf = qemu_blockalign(bs, pad->buf_len);
+    pad->merge_reads = sum == pad->buf_len;
+    if (pad->tail) {
+        pad->tail_buf = pad->buf + pad->buf_len - align;
+    }
+
+    return true;
+}
+
+static int bdrv_padding_rmw_read(BdrvChild *child,
+                                 BdrvTrackedRequest *req,
+                                 BdrvRequestPadding *pad,
+                                 bool zero_middle)
+{
+    QEMUIOVector local_qiov;
+    BlockDriverState *bs = child->bs;
+    uint64_t align = bs->bl.request_alignment;
+    int ret;
+
+    assert(req->serialising && pad->buf);
+
+    if (pad->head || pad->merge_reads) {
+        uint64_t bytes = pad->merge_reads ? pad->buf_len : align;
+
+        qemu_iovec_init_buf(&local_qiov, pad->buf, bytes);
+
+        if (pad->head) {
+            bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);
+        }
+        if (pad->merge_reads && pad->tail) {
+            bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
+        }
+        ret = bdrv_aligned_preadv(child, req, req->overlap_offset, bytes,
+                                  align, &local_qiov, 0);
+        if (ret < 0) {
+            return ret;
+        }
+        if (pad->head) {
+            bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);
+        }
+        if (pad->merge_reads && pad->tail) {
+            bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
+        }
+
+        if (pad->merge_reads) {
+            goto zero_mem;
+        }
+    }
+
+    if (pad->tail) {
+        qemu_iovec_init_buf(&local_qiov, pad->tail_buf, align);
+
+        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
+        ret = bdrv_aligned_preadv(
+                child, req,
+                req->overlap_offset + req->overlap_bytes - align,
+                align, align, &local_qiov, 0);
+        if (ret < 0) {
+            return ret;
+        }
+        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
+    }
+
+zero_mem:
+    if (zero_middle) {
+        memset(pad->buf + pad->head, 0, pad->buf_len - pad->head - pad->tail);
+    }
+
+    return 0;
+}
+
+static void bdrv_padding_destroy(BdrvRequestPadding *pad)
+{
+    if (pad->buf) {
+        qemu_vfree(pad->buf);
+        qemu_iovec_destroy(&pad->local_qiov);
+    }
+}
+
+/*
+ * bdrv_pad_request
+ *
+ * Exchange request parameters with padded request if needed. Don't include RMW
+ * read of padding, bdrv_padding_rmw_read() should be called separately if
+ * needed.
+ *
+ * All parameters except @bs are in-out: they represent original request at
+ * function call and padded (if padding needed) at function finish.
+ *
+ * Function always succeeds.
  */
+static bool bdrv_pad_request(BlockDriverState *bs, QEMUIOVector **qiov,
+                             int64_t *offset, unsigned int *bytes,
+                             BdrvRequestPadding *pad)
+{
+    if (!bdrv_init_padding(bs, *offset, *bytes, pad)) {
+        return false;
+    }
+
+    qemu_iovec_init_extended(&pad->local_qiov, pad->buf, pad->head,
+                             *qiov, 0, *bytes,
+                             pad->buf + pad->buf_len - pad->tail, pad->tail);
+    *bytes += pad->head + pad->tail;
+    *offset -= pad->head;
+    *qiov = &pad->local_qiov;
+
+    return true;
+}
+
 int coroutine_fn bdrv_co_preadv(BdrvChild *child,
     int64_t offset, unsigned int bytes, QEMUIOVector *qiov,
     BdrvRequestFlags flags)
 {
     BlockDriverState *bs = child->bs;
-    BlockDriver *drv = bs->drv;
     BdrvTrackedRequest req;
-
-    uint64_t align = bs->bl.request_alignment;
-    uint8_t *head_buf = NULL;
-    uint8_t *tail_buf = NULL;
-    QEMUIOVector local_qiov;
-    bool use_local_qiov = false;
+    BdrvRequestPadding pad;
     int ret;
 
-    trace_bdrv_co_preadv(child->bs, offset, bytes, flags);
-
-    if (!drv) {
-        return -ENOMEDIUM;
-    }
+    trace_bdrv_co_preadv(bs, offset, bytes, flags);
 
     ret = bdrv_check_byte_request(bs, offset, bytes);
     if (ret < 0) {
@@ -1443,43 +1610,16 @@ int coroutine_fn bdrv_co_preadv(BdrvChild *child,
         flags |= BDRV_REQ_COPY_ON_READ;
     }
 
-    /* Align read if necessary by padding qiov */
-    if (offset & (align - 1)) {
-        head_buf = qemu_blockalign(bs, align);
-        qemu_iovec_init(&local_qiov, qiov->niov + 2);
-        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));
-        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);
-        use_local_qiov = true;
-
-        bytes += offset & (align - 1);
-        offset = offset & ~(align - 1);
-    }
-
-    if ((offset + bytes) & (align - 1)) {
-        if (!use_local_qiov) {
-            qemu_iovec_init(&local_qiov, qiov->niov + 1);
-            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);
-            use_local_qiov = true;
-        }
-        tail_buf = qemu_blockalign(bs, align);
-        qemu_iovec_add(&local_qiov, tail_buf,
-                       align - ((offset + bytes) & (align - 1)));
-
-        bytes = ROUND_UP(bytes, align);
-    }
+    bdrv_pad_request(bs, &qiov, &offset, &bytes, &pad);
 
     tracked_request_begin(&req, bs, offset, bytes, BDRV_TRACKED_READ);
-    ret = bdrv_aligned_preadv(child, &req, offset, bytes, align,
-                              use_local_qiov ? &local_qiov : qiov,
-                              flags);
+    ret = bdrv_aligned_preadv(child, &req, offset, bytes,
+                              bs->bl.request_alignment,
+                              qiov, flags);
     tracked_request_end(&req);
     bdrv_dec_in_flight(bs);
 
-    if (use_local_qiov) {
-        qemu_iovec_destroy(&local_qiov);
-        qemu_vfree(head_buf);
-        qemu_vfree(tail_buf);
-    }
+    bdrv_padding_destroy(&pad);
 
     return ret;
 }
@@ -1614,10 +1754,10 @@ bdrv_co_write_req_prepare(BdrvChild *child, int64_t offset, uint64_t bytes,
     assert(!(flags & ~BDRV_REQ_MASK));
 
     if (flags & BDRV_REQ_SERIALISING) {
-        mark_request_serialising(req, bdrv_get_cluster_size(bs));
+        bdrv_mark_request_serialising(req, bdrv_get_cluster_size(bs));
     }
 
-    waited = wait_serialising_requests(req);
+    waited = bdrv_wait_serialising_requests(req);
 
     assert(!waited || !req->serialising ||
            is_request_serialising_and_aligned(req));
@@ -1715,7 +1855,7 @@ static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,
 
     if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&
         !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&
-        qemu_iovec_is_zero(qiov)) {
+        qemu_iovec_is_zero(qiov, 0, qiov->size)) {
         flags |= BDRV_REQ_ZERO_WRITE;
         if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {
             flags |= BDRV_REQ_MAY_UNMAP;
@@ -1775,44 +1915,34 @@ static int coroutine_fn bdrv_co_do_zero_pwritev(BdrvChild *child,
                                                 BdrvTrackedRequest *req)
 {
     BlockDriverState *bs = child->bs;
-    uint8_t *buf = NULL;
     QEMUIOVector local_qiov;
     uint64_t align = bs->bl.request_alignment;
-    unsigned int head_padding_bytes, tail_padding_bytes;
     int ret = 0;
-
-    head_padding_bytes = offset & (align - 1);
-    tail_padding_bytes = (align - (offset + bytes)) & (align - 1);
-
-
-    assert(flags & BDRV_REQ_ZERO_WRITE);
-    if (head_padding_bytes || tail_padding_bytes) {
-        buf = qemu_blockalign(bs, align);
-        qemu_iovec_init_buf(&local_qiov, buf, align);
-    }
-    if (head_padding_bytes) {
-        uint64_t zero_bytes = MIN(bytes, align - head_padding_bytes);
-
-        /* RMW the unaligned part before head. */
-        mark_request_serialising(req, align);
-        wait_serialising_requests(req);
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);
-        ret = bdrv_aligned_preadv(child, req, offset & ~(align - 1), align,
-                                  align, &local_qiov, 0);
-        if (ret < 0) {
-            goto fail;
-        }
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);
-
-        memset(buf + head_padding_bytes, 0, zero_bytes);
-        ret = bdrv_aligned_pwritev(child, req, offset & ~(align - 1), align,
-                                   align, &local_qiov,
-                                   flags & ~BDRV_REQ_ZERO_WRITE);
-        if (ret < 0) {
-            goto fail;
+    bool padding;
+    BdrvRequestPadding pad;
+
+    padding = bdrv_init_padding(bs, offset, bytes, &pad);
+    if (padding) {
+        bdrv_mark_request_serialising(req, align);
+        bdrv_wait_serialising_requests(req);
+
+        bdrv_padding_rmw_read(child, req, &pad, true);
+
+        if (pad.head || pad.merge_reads) {
+            int64_t aligned_offset = offset & ~(align - 1);
+            int64_t write_bytes = pad.merge_reads ? pad.buf_len : align;
+
+            qemu_iovec_init_buf(&local_qiov, pad.buf, write_bytes);
+            ret = bdrv_aligned_pwritev(child, req, aligned_offset, write_bytes,
+                                       align, &local_qiov,
+                                       flags & ~BDRV_REQ_ZERO_WRITE);
+            if (ret < 0 || pad.merge_reads) {
+                /* Error or all work is done */
+                goto out;
+            }
+            offset += write_bytes - pad.head;
+            bytes -= write_bytes - pad.head;
         }
-        offset += zero_bytes;
-        bytes -= zero_bytes;
     }
 
     assert(!bytes || (offset & (align - 1)) == 0);
@@ -1822,7 +1952,7 @@ static int coroutine_fn bdrv_co_do_zero_pwritev(BdrvChild *child,
         ret = bdrv_aligned_pwritev(child, req, offset, aligned_bytes, align,
                                    NULL, flags);
         if (ret < 0) {
-            goto fail;
+            goto out;
         }
         bytes -= aligned_bytes;
         offset += aligned_bytes;
@@ -1830,26 +1960,17 @@ static int coroutine_fn bdrv_co_do_zero_pwritev(BdrvChild *child,
 
     assert(!bytes || (offset & (align - 1)) == 0);
     if (bytes) {
-        assert(align == tail_padding_bytes + bytes);
-        /* RMW the unaligned part after tail. */
-        mark_request_serialising(req, align);
-        wait_serialising_requests(req);
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
-        ret = bdrv_aligned_preadv(child, req, offset, align,
-                                  align, &local_qiov, 0);
-        if (ret < 0) {
-            goto fail;
-        }
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
+        assert(align == pad.tail + bytes);
 
-        memset(buf, 0, bytes);
+        qemu_iovec_init_buf(&local_qiov, pad.tail_buf, align);
         ret = bdrv_aligned_pwritev(child, req, offset, align, align,
                                    &local_qiov, flags & ~BDRV_REQ_ZERO_WRITE);
     }
-fail:
-    qemu_vfree(buf);
-    return ret;
 
+out:
+    bdrv_padding_destroy(&pad);
+
+    return ret;
 }
 
 /*
@@ -1862,10 +1983,7 @@ int coroutine_fn bdrv_co_pwritev(BdrvChild *child,
     BlockDriverState *bs = child->bs;
     BdrvTrackedRequest req;
     uint64_t align = bs->bl.request_alignment;
-    uint8_t *head_buf = NULL;
-    uint8_t *tail_buf = NULL;
-    QEMUIOVector local_qiov;
-    bool use_local_qiov = false;
+    BdrvRequestPadding pad;
     int ret;
 
     trace_bdrv_co_pwritev(child->bs, offset, bytes, flags);
@@ -1892,86 +2010,21 @@ int coroutine_fn bdrv_co_pwritev(BdrvChild *child,
         goto out;
     }
 
-    if (offset & (align - 1)) {
-        QEMUIOVector head_qiov;
-
-        mark_request_serialising(&req, align);
-        wait_serialising_requests(&req);
-
-        head_buf = qemu_blockalign(bs, align);
-        qemu_iovec_init_buf(&head_qiov, head_buf, align);
-
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);
-        ret = bdrv_aligned_preadv(child, &req, offset & ~(align - 1), align,
-                                  align, &head_qiov, 0);
-        if (ret < 0) {
-            goto fail;
-        }
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);
-
-        qemu_iovec_init(&local_qiov, qiov->niov + 2);
-        qemu_iovec_add(&local_qiov, head_buf, offset & (align - 1));
-        qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);
-        use_local_qiov = true;
-
-        bytes += offset & (align - 1);
-        offset = offset & ~(align - 1);
-
-        /* We have read the tail already if the request is smaller
-         * than one aligned block.
-         */
-        if (bytes < align) {
-            qemu_iovec_add(&local_qiov, head_buf + bytes, align - bytes);
-            bytes = align;
-        }
-    }
-
-    if ((offset + bytes) & (align - 1)) {
-        QEMUIOVector tail_qiov;
-        size_t tail_bytes;
-        bool waited;
-
-        mark_request_serialising(&req, align);
-        waited = wait_serialising_requests(&req);
-        assert(!waited || !use_local_qiov);
-
-        tail_buf = qemu_blockalign(bs, align);
-        qemu_iovec_init_buf(&tail_qiov, tail_buf, align);
-
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
-        ret = bdrv_aligned_preadv(child, &req, (offset + bytes) & ~(align - 1),
-                                  align, align, &tail_qiov, 0);
-        if (ret < 0) {
-            goto fail;
-        }
-        bdrv_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
-
-        if (!use_local_qiov) {
-            qemu_iovec_init(&local_qiov, qiov->niov + 1);
-            qemu_iovec_concat(&local_qiov, qiov, 0, qiov->size);
-            use_local_qiov = true;
-        }
-
-        tail_bytes = (offset + bytes) & (align - 1);
-        qemu_iovec_add(&local_qiov, tail_buf + tail_bytes, align - tail_bytes);
-
-        bytes = ROUND_UP(bytes, align);
+    if (bdrv_pad_request(bs, &qiov, &offset, &bytes, &pad)) {
+        bdrv_mark_request_serialising(&req, align);
+        bdrv_wait_serialising_requests(&req);
+        bdrv_padding_rmw_read(child, &req, &pad, false);
     }
 
     ret = bdrv_aligned_pwritev(child, &req, offset, bytes, align,
-                               use_local_qiov ? &local_qiov : qiov,
-                               flags);
+                               qiov, flags);
 
-fail:
+    bdrv_padding_destroy(&pad);
 
-    if (use_local_qiov) {
-        qemu_iovec_destroy(&local_qiov);
-    }
-    qemu_vfree(head_buf);
-    qemu_vfree(tail_buf);
 out:
     tracked_request_end(&req);
     bdrv_dec_in_flight(bs);
+
     return ret;
 }
 
@@ -3043,7 +3096,7 @@ static int coroutine_fn bdrv_co_copy_range_internal(
         /* BDRV_REQ_SERIALISING is only for write operation */
         assert(!(read_flags & BDRV_REQ_SERIALISING));
         if (!(read_flags & BDRV_REQ_NO_SERIALISING)) {
-            wait_serialising_requests(&req);
+            bdrv_wait_serialising_requests(&req);
         }
 
         ret = src->bs->drv->bdrv_co_copy_range_from(src->bs,
@@ -3170,7 +3223,7 @@ int coroutine_fn bdrv_co_truncate(BdrvChild *child, int64_t offset,
      * new area, we need to make sure that no write requests are made to it
      * concurrently or they might be overwritten by preallocation. */
     if (new_bytes) {
-        mark_request_serialising(&req, 1);
+        bdrv_mark_request_serialising(&req, 1);
     }
     if (bs->read_only) {
         error_setg(errp, "Image is read-only");
diff --git a/block/mirror.c b/block/mirror.c
index 9f5c59ece1..681b305de6 100644
--- a/block/mirror.c
+++ b/block/mirror.c
@@ -618,11 +618,11 @@ static int mirror_exit_common(Job *job)
 {
     MirrorBlockJob *s = container_of(job, MirrorBlockJob, common.job);
     BlockJob *bjob = &s->common;
-    MirrorBDSOpaque *bs_opaque = s->mirror_top_bs->opaque;
+    MirrorBDSOpaque *bs_opaque;
     AioContext *replace_aio_context = NULL;
-    BlockDriverState *src = s->mirror_top_bs->backing->bs;
-    BlockDriverState *target_bs = blk_bs(s->target);
-    BlockDriverState *mirror_top_bs = s->mirror_top_bs;
+    BlockDriverState *src;
+    BlockDriverState *target_bs;
+    BlockDriverState *mirror_top_bs;
     Error *local_err = NULL;
     bool abort = job->ret < 0;
     int ret = 0;
@@ -632,6 +632,11 @@ static int mirror_exit_common(Job *job)
     }
     s->prepared = true;
 
+    mirror_top_bs = s->mirror_top_bs;
+    bs_opaque = mirror_top_bs->opaque;
+    src = mirror_top_bs->backing->bs;
+    target_bs = blk_bs(s->target);
+
     if (bdrv_chain_contains(src, target_bs)) {
         bdrv_unfreeze_backing_chain(mirror_top_bs, target_bs);
     }
@@ -656,7 +661,10 @@ static int mirror_exit_common(Job *job)
     s->target = NULL;
 
     /* We don't access the source any more. Dropping any WRITE/RESIZE is
-     * required before it could become a backing file of target_bs. */
+     * required before it could become a backing file of target_bs. Not having
+     * these permissions any more means that we can't allow any new requests on
+     * mirror_top_bs from now on, so keep it drained. */
+    bdrv_drained_begin(mirror_top_bs);
     bs_opaque->stop = true;
     bdrv_child_refresh_perms(mirror_top_bs, mirror_top_bs->backing,
                              &error_abort);
@@ -724,6 +732,7 @@ static int mirror_exit_common(Job *job)
     bs_opaque->job = NULL;
 
     bdrv_drained_end(src);
+    bdrv_drained_end(mirror_top_bs);
     s->in_drain = false;
     bdrv_unref(mirror_top_bs);
     bdrv_unref(src);
diff --git a/block/nfs.c b/block/nfs.c
index d93241b3bb..2b7a078241 100644
--- a/block/nfs.c
+++ b/block/nfs.c
@@ -390,12 +390,14 @@ static void nfs_attach_aio_context(BlockDriverState *bs,
 static void nfs_client_close(NFSClient *client)
 {
     if (client->context) {
+        qemu_mutex_lock(&client->mutex);
+        aio_set_fd_handler(client->aio_context, nfs_get_fd(client->context),
+                           false, NULL, NULL, NULL, NULL);
+        qemu_mutex_unlock(&client->mutex);
         if (client->fh) {
             nfs_close(client->context, client->fh);
             client->fh = NULL;
         }
-        aio_set_fd_handler(client->aio_context, nfs_get_fd(client->context),
-                           false, NULL, NULL, NULL, NULL);
         nfs_destroy_context(client->context);
         client->context = NULL;
     }
diff --git a/block/qcow2-bitmap.c b/block/qcow2-bitmap.c
index b2487101ed..65034da1c0 100644
--- a/block/qcow2-bitmap.c
+++ b/block/qcow2-bitmap.c
@@ -142,6 +142,13 @@ static int check_table_entry(uint64_t entry, int cluster_size)
     return 0;
 }
 
+static int64_t get_bitmap_bytes_needed(int64_t len, uint32_t granularity)
+{
+    int64_t num_bits = DIV_ROUND_UP(len, granularity);
+
+    return DIV_ROUND_UP(num_bits, 8);
+}
+
 static int check_constraints_on_bitmap(BlockDriverState *bs,
                                        const char *name,
                                        uint32_t granularity,
@@ -150,6 +157,7 @@ static int check_constraints_on_bitmap(BlockDriverState *bs,
     BDRVQcow2State *s = bs->opaque;
     int granularity_bits = ctz32(granularity);
     int64_t len = bdrv_getlength(bs);
+    int64_t bitmap_bytes;
 
     assert(granularity > 0);
     assert((granularity & (granularity - 1)) == 0);
@@ -171,9 +179,9 @@ static int check_constraints_on_bitmap(BlockDriverState *bs,
         return -EINVAL;
     }
 
-    if ((len > (uint64_t)BME_MAX_PHYS_SIZE << granularity_bits) ||
-        (len > (uint64_t)BME_MAX_TABLE_SIZE * s->cluster_size <<
-               granularity_bits))
+    bitmap_bytes = get_bitmap_bytes_needed(len, granularity);
+    if ((bitmap_bytes > (uint64_t)BME_MAX_PHYS_SIZE) ||
+        (bitmap_bytes > (uint64_t)BME_MAX_TABLE_SIZE * s->cluster_size))
     {
         error_setg(errp, "Too much space will be occupied by the bitmap. "
                    "Use larger granularity");
diff --git a/block/qcow2-cluster.c b/block/qcow2-cluster.c
index cc5609e27a..f8576031b6 100644
--- a/block/qcow2-cluster.c
+++ b/block/qcow2-cluster.c
@@ -473,9 +473,10 @@ static bool coroutine_fn do_perform_cow_encrypt(BlockDriverState *bs,
         assert((offset_in_cluster & ~BDRV_SECTOR_MASK) == 0);
         assert((bytes & ~BDRV_SECTOR_MASK) == 0);
         assert(s->crypto);
-        if (qcow2_co_encrypt(bs, cluster_offset,
-                             src_cluster_offset + offset_in_cluster,
-                             buffer, bytes) < 0) {
+        if (qcow2_co_encrypt(bs,
+                start_of_cluster(s, cluster_offset + offset_in_cluster),
+                src_cluster_offset + offset_in_cluster,
+                buffer, bytes) < 0) {
             return false;
         }
     }
@@ -1340,6 +1341,9 @@ static int handle_alloc(BlockDriverState *bs, uint64_t guest_offset,
     nb_clusters = MIN(nb_clusters, s->l2_slice_size - l2_index);
     assert(nb_clusters <= INT_MAX);
 
+    /* Limit total allocation byte count to INT_MAX */
+    nb_clusters = MIN(nb_clusters, INT_MAX >> s->cluster_bits);
+
     /* Find L2 entry for the first involved cluster */
     ret = get_cluster_table(bs, guest_offset, &l2_slice, &l2_index);
     if (ret < 0) {
@@ -1428,7 +1432,7 @@ static int handle_alloc(BlockDriverState *bs, uint64_t guest_offset,
      * request actually writes to (excluding COW at the end)
      */
     uint64_t requested_bytes = *bytes + offset_into_cluster(s, guest_offset);
-    int avail_bytes = MIN(INT_MAX, nb_clusters << s->cluster_bits);
+    int avail_bytes = nb_clusters << s->cluster_bits;
     int nb_bytes = MIN(requested_bytes, avail_bytes);
     QCowL2Meta *old_m = *m;
 
diff --git a/block/qcow2-refcount.c b/block/qcow2-refcount.c
index ef965d7895..0d64bf5a5e 100644
--- a/block/qcow2-refcount.c
+++ b/block/qcow2-refcount.c
@@ -3455,6 +3455,8 @@ int qcow2_detect_metadata_preallocation(BlockDriverState *bs)
     int64_t i, end_cluster, cluster_count = 0, threshold;
     int64_t file_length, real_allocation, real_clusters;
 
+    qemu_co_mutex_assert_locked(&s->lock);
+
     file_length = bdrv_getlength(bs->file->bs);
     if (file_length < 0) {
         return file_length;
diff --git a/block/qcow2.c b/block/qcow2.c
index 039bdc2f7e..c0f5439dc8 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -826,7 +826,11 @@ static void read_cache_sizes(BlockDriverState *bs, QemuOpts *opts,
     bool l2_cache_entry_size_set;
     int min_refcount_cache = MIN_REFCOUNT_CACHE_SIZE * s->cluster_size;
     uint64_t virtual_disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;
-    uint64_t max_l2_cache = virtual_disk_size / (s->cluster_size / 8);
+    uint64_t max_l2_entries = DIV_ROUND_UP(virtual_disk_size, s->cluster_size);
+    /* An L2 table is always one cluster in size so the max cache size
+     * should be a multiple of the cluster size. */
+    uint64_t max_l2_cache = ROUND_UP(max_l2_entries * sizeof(uint64_t),
+                                     s->cluster_size);
 
     combined_cache_size_set = qemu_opt_get(opts, QCOW2_OPT_CACHE_SIZE);
     l2_cache_size_set = qemu_opt_get(opts, QCOW2_OPT_L2_CACHE_SIZE);
@@ -1895,6 +1899,8 @@ static int coroutine_fn qcow2_co_block_status(BlockDriverState *bs,
     unsigned int bytes;
     int status = 0;
 
+    qemu_co_mutex_lock(&s->lock);
+
     if (!s->metadata_preallocation_checked) {
         ret = qcow2_detect_metadata_preallocation(bs);
         s->metadata_preallocation = (ret == 1);
@@ -1902,7 +1908,6 @@ static int coroutine_fn qcow2_co_block_status(BlockDriverState *bs,
     }
 
     bytes = MIN(INT_MAX, count);
-    qemu_co_mutex_lock(&s->lock);
     ret = qcow2_get_cluster_offset(bs, offset, &bytes, &cluster_offset);
     qemu_co_mutex_unlock(&s->lock);
     if (ret < 0) {
diff --git a/block/qcow2.h b/block/qcow2.h
index fc1b0d3c1e..359197f89f 100644
--- a/block/qcow2.h
+++ b/block/qcow2.h
@@ -77,7 +77,7 @@
 
 /* Defined in the qcow2 spec (compressed cluster descriptor) */
 #define QCOW2_COMPRESSED_SECTOR_SIZE 512U
-#define QCOW2_COMPRESSED_SECTOR_MASK (~(QCOW2_COMPRESSED_SECTOR_SIZE - 1))
+#define QCOW2_COMPRESSED_SECTOR_MASK (~(QCOW2_COMPRESSED_SECTOR_SIZE - 1ULL))
 
 /* Must be at least 2 to cover COW */
 #define MIN_L2_CACHE_SIZE 2 /* cache entries */
diff --git a/block/snapshot.c b/block/snapshot.c
index f2f48f926a..8081616ae9 100644
--- a/block/snapshot.c
+++ b/block/snapshot.c
@@ -31,6 +31,7 @@
 #include "qapi/qmp/qerror.h"
 #include "qapi/qmp/qstring.h"
 #include "qemu/option.h"
+#include "sysemu/block-backend.h"
 
 QemuOptsList internal_snapshot_opts = {
     .name = "snapshot",
@@ -384,6 +385,16 @@ int bdrv_snapshot_load_tmp_by_id_or_name(BlockDriverState *bs,
     return ret;
 }
 
+static bool bdrv_all_snapshots_includes_bs(BlockDriverState *bs)
+{
+    if (!bdrv_is_inserted(bs) || bdrv_is_read_only(bs)) {
+        return false;
+    }
+
+    /* Include all nodes that are either in use by a BlockBackend, or that
+     * aren't attached to any node, but owned by the monitor. */
+    return bdrv_has_blk(bs) || QLIST_EMPTY(&bs->parents);
+}
 
 /* Group operations. All block drivers are involved.
  * These functions will properly handle dataplane (take aio_context_acquire
@@ -399,7 +410,7 @@ bool bdrv_all_can_snapshot(BlockDriverState **first_bad_bs)
         AioContext *ctx = bdrv_get_aio_context(bs);
 
         aio_context_acquire(ctx);
-        if (bdrv_is_inserted(bs) && !bdrv_is_read_only(bs)) {
+        if (bdrv_all_snapshots_includes_bs(bs)) {
             ok = bdrv_can_snapshot(bs);
         }
         aio_context_release(ctx);
@@ -426,8 +437,9 @@ int bdrv_all_delete_snapshot(const char *name, BlockDriverState **first_bad_bs,
         AioContext *ctx = bdrv_get_aio_context(bs);
 
         aio_context_acquire(ctx);
-        if (bdrv_can_snapshot(bs) &&
-                bdrv_snapshot_find(bs, snapshot, name) >= 0) {
+        if (bdrv_all_snapshots_includes_bs(bs) &&
+            bdrv_snapshot_find(bs, snapshot, name) >= 0)
+        {
             ret = bdrv_snapshot_delete(bs, snapshot->id_str,
                                        snapshot->name, err);
         }
@@ -455,7 +467,7 @@ int bdrv_all_goto_snapshot(const char *name, BlockDriverState **first_bad_bs,
         AioContext *ctx = bdrv_get_aio_context(bs);
 
         aio_context_acquire(ctx);
-        if (bdrv_can_snapshot(bs)) {
+        if (bdrv_all_snapshots_includes_bs(bs)) {
             ret = bdrv_snapshot_goto(bs, name, errp);
         }
         aio_context_release(ctx);
@@ -481,7 +493,7 @@ int bdrv_all_find_snapshot(const char *name, BlockDriverState **first_bad_bs)
         AioContext *ctx = bdrv_get_aio_context(bs);
 
         aio_context_acquire(ctx);
-        if (bdrv_can_snapshot(bs)) {
+        if (bdrv_all_snapshots_includes_bs(bs)) {
             err = bdrv_snapshot_find(bs, &sn, name);
         }
         aio_context_release(ctx);
@@ -512,7 +524,7 @@ int bdrv_all_create_snapshot(QEMUSnapshotInfo *sn,
         if (bs == vm_state_bs) {
             sn->vm_state_size = vm_state_size;
             err = bdrv_snapshot_create(bs, sn);
-        } else if (bdrv_can_snapshot(bs)) {
+        } else if (bdrv_all_snapshots_includes_bs(bs)) {
             sn->vm_state_size = 0;
             err = bdrv_snapshot_create(bs, sn);
         }
@@ -538,7 +550,7 @@ BlockDriverState *bdrv_all_find_vmstate_bs(void)
         bool found;
 
         aio_context_acquire(ctx);
-        found = bdrv_can_snapshot(bs);
+        found = bdrv_all_snapshots_includes_bs(bs) && bdrv_can_snapshot(bs);
         aio_context_release(ctx);
 
         if (found) {
diff --git a/block/vpc.c b/block/vpc.c
index d4776ee8a5..3a88e28e2b 100644
--- a/block/vpc.c
+++ b/block/vpc.c
@@ -885,6 +885,7 @@ static int create_dynamic_disk(BlockBackend *blk, uint8_t *buf,
         goto fail;
     }
 
+    ret = 0;
  fail:
     return ret;
 }
@@ -908,7 +909,7 @@ static int create_fixed_disk(BlockBackend *blk, uint8_t *buf,
         return ret;
     }
 
-    return ret;
+    return 0;
 }
 
 static int calculate_rounded_image_size(BlockdevCreateOptionsVpc *vpc_opts,
diff --git a/blockjob.c b/blockjob.c
index 20b7f557da..74abb97bfd 100644
--- a/blockjob.c
+++ b/blockjob.c
@@ -186,14 +186,23 @@ static const BdrvChildRole child_job = {
 
 void block_job_remove_all_bdrv(BlockJob *job)
 {
-    GSList *l;
-    for (l = job->nodes; l; l = l->next) {
+    /*
+     * bdrv_root_unref_child() may reach child_job_[can_]set_aio_ctx(),
+     * which will also traverse job->nodes, so consume the list one by
+     * one to make sure that such a concurrent access does not attempt
+     * to process an already freed BdrvChild.
+     */
+    while (job->nodes) {
+        GSList *l = job->nodes;
         BdrvChild *c = l->data;
+
+        job->nodes = l->next;
+
         bdrv_op_unblock_all(c->bs, job->blocker);
         bdrv_root_unref_child(c);
+
+        g_slist_free_1(l);
     }
-    g_slist_free(job->nodes);
-    job->nodes = NULL;
 }
 
 bool block_job_has_bdrv(BlockJob *job, BlockDriverState *bs)
diff --git a/contrib/libvhost-user/libvhost-user.c b/contrib/libvhost-user/libvhost-user.c
index 4b36e35a82..cb5f5770e4 100644
--- a/contrib/libvhost-user/libvhost-user.c
+++ b/contrib/libvhost-user/libvhost-user.c
@@ -1097,7 +1097,8 @@ bool vu_set_queue_host_notifier(VuDev *dev, VuVirtq *vq, int fd,
 
     vmsg.fd_num = fd_num;
 
-    if ((dev->protocol_features & VHOST_USER_PROTOCOL_F_SLAVE_SEND_FD) == 0) {
+    if (!has_feature(dev->protocol_features,
+                     VHOST_USER_PROTOCOL_F_SLAVE_SEND_FD)) {
         return false;
     }
 
diff --git a/dma-helpers.c b/dma-helpers.c
index 2d7e02d35e..d3871dc61e 100644
--- a/dma-helpers.c
+++ b/dma-helpers.c
@@ -90,6 +90,7 @@ static void reschedule_dma(void *opaque)
 {
     DMAAIOCB *dbs = (DMAAIOCB *)opaque;
 
+    assert(!dbs->acb && dbs->bh);
     qemu_bh_delete(dbs->bh);
     dbs->bh = NULL;
     dma_blk_cb(dbs, 0);
@@ -111,15 +112,12 @@ static void dma_complete(DMAAIOCB *dbs, int ret)
 {
     trace_dma_complete(dbs, ret, dbs->common.cb);
 
+    assert(!dbs->acb && !dbs->bh);
     dma_blk_unmap(dbs);
     if (dbs->common.cb) {
         dbs->common.cb(dbs->common.opaque, ret);
     }
     qemu_iovec_destroy(&dbs->iov);
-    if (dbs->bh) {
-        qemu_bh_delete(dbs->bh);
-        dbs->bh = NULL;
-    }
     qemu_aio_unref(dbs);
 }
 
@@ -179,14 +177,21 @@ static void dma_aio_cancel(BlockAIOCB *acb)
 
     trace_dma_aio_cancel(dbs);
 
+    assert(!(dbs->acb && dbs->bh));
     if (dbs->acb) {
+        /* This will invoke dma_blk_cb.  */
         blk_aio_cancel_async(dbs->acb);
+        return;
     }
+
     if (dbs->bh) {
         cpu_unregister_map_client(dbs->bh);
         qemu_bh_delete(dbs->bh);
         dbs->bh = NULL;
     }
+    if (dbs->common.cb) {
+        dbs->common.cb(dbs->common.opaque, -ECANCELED);
+    }
 }
 
 static AioContext *dma_get_aio_context(BlockAIOCB *acb)
diff --git a/hw/arm/boot.c b/hw/arm/boot.c
index c2b89b3bb9..fc4e021a38 100644
--- a/hw/arm/boot.c
+++ b/hw/arm/boot.c
@@ -754,6 +754,8 @@ static void do_cpu_reset(void *opaque)
                     (cs != first_cpu || !info->secure_board_setup)) {
                     /* Linux expects non-secure state */
                     env->cp15.scr_el3 |= SCR_NS;
+                    /* Set NSACR.{CP11,CP10} so NS can access the FPU */
+                    env->cp15.nsacr |= 3 << 10;
                 }
             }
 
diff --git a/hw/block/dataplane/virtio-blk.c b/hw/block/dataplane/virtio-blk.c
index 158c78f852..5fea76df85 100644
--- a/hw/block/dataplane/virtio-blk.c
+++ b/hw/block/dataplane/virtio-blk.c
@@ -297,6 +297,9 @@ void virtio_blk_data_plane_stop(VirtIODevice *vdev)
         virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
     }
 
+    qemu_bh_cancel(s->bh);
+    notify_guest_bh(s); /* final chance to notify guest */
+
     /* Clean up guest notifier (irq) */
     k->set_guest_notifiers(qbus->parent, nvqs, false);
 
diff --git a/hw/core/loader.c b/hw/core/loader.c
index 425bf69a99..838a34174a 100644
--- a/hw/core/loader.c
+++ b/hw/core/loader.c
@@ -1242,7 +1242,7 @@ int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
         if (rom->addr + rom->romsize < addr) {
             continue;
         }
-        if (rom->addr > end) {
+        if (rom->addr > end || rom->addr < addr) {
             break;
         }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 549c437050..d011733ff7 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -2403,6 +2403,14 @@ static void pc_cpu_pre_plug(HotplugHandler *hotplug_dev,
         int max_socket = (ms->smp.max_cpus - 1) /
                                 smp_threads / smp_cores / pcms->smp_dies;
 
+        /*
+         * die-id was optional in QEMU 4.0 and older, so keep it optional
+         * if there's only one die per socket.
+         */
+        if (cpu->die_id < 0 && pcms->smp_dies == 1) {
+            cpu->die_id = 0;
+        }
+
         if (cpu->socket_id < 0) {
             error_setg(errp, "CPU socket-id is not set");
             return;
@@ -2879,8 +2887,10 @@ static const CPUArchIdList *pc_possible_cpu_arch_ids(MachineState *ms)
                                  ms->smp.threads, &topo);
         ms->possible_cpus->cpus[i].props.has_socket_id = true;
         ms->possible_cpus->cpus[i].props.socket_id = topo.pkg_id;
-        ms->possible_cpus->cpus[i].props.has_die_id = true;
-        ms->possible_cpus->cpus[i].props.die_id = topo.die_id;
+        if (pcms->smp_dies > 1) {
+            ms->possible_cpus->cpus[i].props.has_die_id = true;
+            ms->possible_cpus->cpus[i].props.die_id = topo.die_id;
+        }
         ms->possible_cpus->cpus[i].props.has_core_id = true;
         ms->possible_cpus->cpus[i].props.core_id = topo.core_id;
         ms->possible_cpus->cpus[i].props.has_thread_id = true;
diff --git a/hw/ide/ahci.c b/hw/ide/ahci.c
index 00ba422a48..6aaf66534a 100644
--- a/hw/ide/ahci.c
+++ b/hw/ide/ahci.c
@@ -1023,9 +1023,6 @@ static void ncq_cb(void *opaque, int ret)
     IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];
 
     ncq_tfs->aiocb = NULL;
-    if (ret == -ECANCELED) {
-        return;
-    }
 
     if (ret < 0) {
         bool is_read = ncq_tfs->cmd == READ_FPDMA_QUEUED;
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 6afadf894f..8e1624f7ce 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -722,9 +722,6 @@ static void ide_sector_read_cb(void *opaque, int ret)
     s->pio_aiocb = NULL;
     s->status &= ~BUSY_STAT;
 
-    if (ret == -ECANCELED) {
-        return;
-    }
     if (ret != 0) {
         if (ide_handle_rw_error(s, -ret, IDE_RETRY_PIO |
                                 IDE_RETRY_READ)) {
@@ -840,10 +837,6 @@ static void ide_dma_cb(void *opaque, int ret)
     uint64_t offset;
     bool stay_active = false;
 
-    if (ret == -ECANCELED) {
-        return;
-    }
-
     if (ret == -EINVAL) {
         ide_dma_error(s);
         return;
@@ -975,10 +968,6 @@ static void ide_sector_write_cb(void *opaque, int ret)
     IDEState *s = opaque;
     int n;
 
-    if (ret == -ECANCELED) {
-        return;
-    }
-
     s->pio_aiocb = NULL;
     s->status &= ~BUSY_STAT;
 
@@ -1058,9 +1047,6 @@ static void ide_flush_cb(void *opaque, int ret)
 
     s->pio_aiocb = NULL;
 
-    if (ret == -ECANCELED) {
-        return;
-    }
     if (ret < 0) {
         /* XXX: What sector number to set here? */
         if (ide_handle_rw_error(s, -ret, IDE_RETRY_FLUSH)) {
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index b9e1cd71cf..6adb0fe252 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -2330,9 +2330,13 @@ static int virtio_net_post_load_device(void *opaque, int version_id)
         n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);
     }
 
-    if (peer_has_vnet_hdr(n)) {
-        virtio_net_apply_guest_offloads(n);
-    }
+    /*
+     * curr_guest_offloads will be later overwritten by the
+     * virtio_set_features_nocheck call done from the virtio_load.
+     * Here we make sure it is preserved and restored accordingly
+     * in the virtio_net_post_load_virtio callback.
+     */
+    n->saved_guest_offloads = n->curr_guest_offloads;
 
     virtio_net_set_queues(n);
 
@@ -2367,6 +2371,22 @@ static int virtio_net_post_load_device(void *opaque, int version_id)
     return 0;
 }
 
+static int virtio_net_post_load_virtio(VirtIODevice *vdev)
+{
+    VirtIONet *n = VIRTIO_NET(vdev);
+    /*
+     * The actual needed state is now in saved_guest_offloads,
+     * see virtio_net_post_load_device for detail.
+     * Restore it back and apply the desired offloads.
+     */
+    n->curr_guest_offloads = n->saved_guest_offloads;
+    if (peer_has_vnet_hdr(n)) {
+        virtio_net_apply_guest_offloads(n);
+    }
+
+    return 0;
+}
+
 /* tx_waiting field of a VirtIONetQueue */
 static const VMStateDescription vmstate_virtio_net_queue_tx_waiting = {
     .name = "virtio-net-queue-tx_waiting",
@@ -2909,6 +2929,7 @@ static void virtio_net_class_init(ObjectClass *klass, void *data)
     vdc->guest_notifier_mask = virtio_net_guest_notifier_mask;
     vdc->guest_notifier_pending = virtio_net_guest_notifier_pending;
     vdc->legacy_features |= (0x1 << VIRTIO_NET_F_GSO);
+    vdc->post_load = virtio_net_post_load_virtio;
     vdc->vmsd = &vmstate_virtio_net_device;
 }
 
diff --git a/hw/s390x/s390-pci-bus.c b/hw/s390x/s390-pci-bus.c
index 2c6e084e2c..9a935f22b5 100644
--- a/hw/s390x/s390-pci-bus.c
+++ b/hw/s390x/s390-pci-bus.c
@@ -694,10 +694,15 @@ static const MemoryRegionOps s390_msi_ctrl_ops = {
 
 void s390_pci_iommu_enable(S390PCIIOMMU *iommu)
 {
+    /*
+     * The iommu region is initialized against a 0-mapped address space,
+     * so the smallest IOMMU region we can define runs from 0 to the end
+     * of the PCI address space.
+     */
     char *name = g_strdup_printf("iommu-s390-%04x", iommu->pbdev->uid);
     memory_region_init_iommu(&iommu->iommu_mr, sizeof(iommu->iommu_mr),
                              TYPE_S390_IOMMU_MEMORY_REGION, OBJECT(&iommu->mr),
-                             name, iommu->pal - iommu->pba + 1);
+                             name, iommu->pal + 1);
     iommu->enabled = true;
     memory_region_add_subregion(&iommu->mr, 0, MEMORY_REGION(&iommu->iommu_mr));
     g_free(name);
diff --git a/hw/scsi/lsi53c895a.c b/hw/scsi/lsi53c895a.c
index 10468c1ec1..72f7b59ab5 100644
--- a/hw/scsi/lsi53c895a.c
+++ b/hw/scsi/lsi53c895a.c
@@ -185,6 +185,9 @@ static const char *names[] = {
 /* Flag set if this is a tagged command.  */
 #define LSI_TAG_VALID     (1 << 16)
 
+/* Maximum instructions to process. */
+#define LSI_MAX_INSN    10000
+
 typedef struct lsi_request {
     SCSIRequest *req;
     uint32_t tag;
@@ -1132,7 +1135,21 @@ static void lsi_execute_script(LSIState *s)
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
-    insn_processed++;
+    if (++insn_processed > LSI_MAX_INSN) {
+        /* Some windows drivers make the device spin waiting for a memory
+           location to change.  If we have been executed a lot of code then
+           assume this is the case and force an unexpected device disconnect.
+           This is apparently sufficient to beat the drivers into submission.
+         */
+        if (!(s->sien0 & LSI_SIST0_UDC)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "lsi_scsi: inf. loop with UDC masked");
+        }
+        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
+        lsi_disconnect(s);
+        trace_lsi_execute_script_stop();
+        return;
+    }
     insn = read_dword(s, s->dsp);
     if (!insn) {
         /* If we receive an empty opcode increment the DSP by 4 bytes
@@ -1569,19 +1586,7 @@ again:
             }
         }
     }
-    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
-        /* Some windows drivers make the device spin waiting for a memory
-           location to change.  If we have been executed a lot of code then
-           assume this is the case and force an unexpected device disconnect.
-           This is apparently sufficient to beat the drivers into submission.
-         */
-        if (!(s->sien0 & LSI_SIST0_UDC)) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          "lsi_scsi: inf. loop with UDC masked");
-        }
-        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
-        lsi_disconnect(s);
-    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
+    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
         if (s->dcntl & LSI_DCNTL_SSM) {
             lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);
         } else {
@@ -1969,6 +1974,10 @@ static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)
     case 0x2f: /* DSP[24:31] */
         s->dsp &= 0x00ffffff;
         s->dsp |= val << 24;
+        /*
+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one
+         * instruction.  Is this correct?
+         */
         if ((s->dmode & LSI_DMODE_MAN) == 0
             && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
             lsi_execute_script(s);
@@ -1987,6 +1996,10 @@ static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)
         break;
     case 0x3b: /* DCNTL */
         s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);
+        /*
+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one
+         * instruction.  Is this correct?
+         */
         if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
             lsi_execute_script(s);
         break;
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index bc899fc60e..2ef4bc720f 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -451,8 +451,13 @@ static void vhost_commit(MemoryListener *listener)
         changed = true;
     } else {
         /* Same size, lets check the contents */
-        changed = n_old_sections && memcmp(dev->mem_sections, old_sections,
-                         n_old_sections * sizeof(old_sections[0])) != 0;
+        for (int i = 0; i < n_old_sections; i++) {
+            if (!MemoryRegionSection_eq(&old_sections[i],
+                                        &dev->mem_sections[i])) {
+                changed = true;
+                break;
+            }
+        }
     }
 
     trace_vhost_commit(dev->started, changed);
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index a94ea18a9c..7c3822c3a0 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2287,6 +2287,13 @@ int virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)
     }
     rcu_read_unlock();
 
+    if (vdc->post_load) {
+        ret = vdc->post_load(vdev);
+        if (ret) {
+            return ret;
+        }
+    }
+
     return 0;
 }
 
diff --git a/hw/xen/xen-bus.c b/hw/xen/xen-bus.c
index 7503eea9e9..10b7e02b5c 100644
--- a/hw/xen/xen-bus.c
+++ b/hw/xen/xen-bus.c
@@ -516,6 +516,23 @@ static void xen_device_backend_set_online(XenDevice *xendev, bool online)
     xen_device_backend_printf(xendev, "online", "%u", online);
 }
 
+/*
+ * Tell from the state whether the frontend is likely alive,
+ * i.e. it will react to a change of state of the backend.
+ */
+static bool xen_device_state_is_active(enum xenbus_state state)
+{
+    switch (state) {
+    case XenbusStateInitWait:
+    case XenbusStateInitialised:
+    case XenbusStateConnected:
+    case XenbusStateClosing:
+        return true;
+    default:
+        return false;
+    }
+}
+
 static void xen_device_backend_changed(void *opaque)
 {
     XenDevice *xendev = opaque;
@@ -539,11 +556,11 @@ static void xen_device_backend_changed(void *opaque)
 
     /*
      * If the toolstack (or unplug request callback) has set the backend
-     * state to Closing, but there is no active frontend (i.e. the
-     * state is not Connected) then set the backend state to Closed.
+     * state to Closing, but there is no active frontend then set the
+     * backend state to Closed.
      */
     if (xendev->backend_state == XenbusStateClosing &&
-        xendev->frontend_state != XenbusStateConnected) {
+        !xen_device_state_is_active(xendev->frontend_state)) {
         xen_device_backend_set_state(xendev, XenbusStateClosed);
     }
 
diff --git a/include/block/block_int.h b/include/block/block_int.h
index 3aa1e832a8..05ee6b4866 100644
--- a/include/block/block_int.h
+++ b/include/block/block_int.h
@@ -962,6 +962,10 @@ extern unsigned int bdrv_drain_all_count;
 void bdrv_apply_subtree_drain(BdrvChild *child, BlockDriverState *new_parent);
 void bdrv_unapply_subtree_drain(BdrvChild *child, BlockDriverState *old_parent);
 
+bool coroutine_fn bdrv_wait_serialising_requests(BdrvTrackedRequest *self);
+void bdrv_mark_request_serialising(BdrvTrackedRequest *req, uint64_t align);
+BdrvTrackedRequest *coroutine_fn bdrv_co_get_self_request(BlockDriverState *bs);
+
 int get_tmp_filename(char *filename, int size);
 BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,
                             const char *filename);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index bb0961ddb9..611a89122d 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -487,15 +487,27 @@ static inline FlatView *address_space_to_flatview(AddressSpace *as)
  * @nonvolatile: this section is non-volatile
  */
 struct MemoryRegionSection {
+    Int128 size;
     MemoryRegion *mr;
     FlatView *fv;
     hwaddr offset_within_region;
-    Int128 size;
     hwaddr offset_within_address_space;
     bool readonly;
     bool nonvolatile;
 };
 
+static inline bool MemoryRegionSection_eq(MemoryRegionSection *a,
+                                          MemoryRegionSection *b)
+{
+    return a->mr == b->mr &&
+           a->fv == b->fv &&
+           a->offset_within_region == b->offset_within_region &&
+           a->offset_within_address_space == b->offset_within_address_space &&
+           int128_eq(a->size, b->size) &&
+           a->readonly == b->readonly &&
+           a->nonvolatile == b->nonvolatile;
+}
+
 /**
  * memory_region_init: Initialize a memory region
  *
diff --git a/include/hw/virtio/virtio-net.h b/include/hw/virtio/virtio-net.h
index b96f0c643f..07a9319f4b 100644
--- a/include/hw/virtio/virtio-net.h
+++ b/include/hw/virtio/virtio-net.h
@@ -182,6 +182,8 @@ struct VirtIONet {
     char *netclient_name;
     char *netclient_type;
     uint64_t curr_guest_offloads;
+    /* used on saved state restore phase to preserve the curr_guest_offloads */
+    uint64_t saved_guest_offloads;
     AnnounceTimer announce_timer;
     bool needs_vnet_hdr_swap;
     bool mtu_bypass_backend;
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index b189788cb2..f9f62370e9 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -158,6 +158,12 @@ typedef struct VirtioDeviceClass {
      */
     void (*save)(VirtIODevice *vdev, QEMUFile *f);
     int (*load)(VirtIODevice *vdev, QEMUFile *f, int version_id);
+    /* Post load hook in vmsd is called early while device is processed, and
+     * when VirtIODevice isn't fully initialized.  Devices should use this instead,
+     * unless they specifically want to verify the migration stream as it's
+     * processed, e.g. for bounds checking.
+     */
+    int (*post_load)(VirtIODevice *vdev);
     const VMStateDescription *vmsd;
 } VirtioDeviceClass;
 
diff --git a/include/qemu/coroutine.h b/include/qemu/coroutine.h
index 9801e7f5a4..f4843b5f59 100644
--- a/include/qemu/coroutine.h
+++ b/include/qemu/coroutine.h
@@ -167,6 +167,21 @@ void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex);
  */
 void coroutine_fn qemu_co_mutex_unlock(CoMutex *mutex);
 
+/**
+ * Assert that the current coroutine holds @mutex.
+ */
+static inline coroutine_fn void qemu_co_mutex_assert_locked(CoMutex *mutex)
+{
+    /*
+     * mutex->holder doesn't need any synchronisation if the assertion holds
+     * true because the mutex protects it. If it doesn't hold true, we still
+     * don't mind if another thread takes or releases mutex behind our back,
+     * because the condition will be false no matter whether we read NULL or
+     * the pointer for any other coroutine.
+     */
+    assert(atomic_read(&mutex->locked) &&
+           mutex->holder == qemu_coroutine_self());
+}
 
 /**
  * CoQueues are a mechanism to queue coroutines in order to continue executing
diff --git a/include/qemu/hbitmap.h b/include/qemu/hbitmap.h
index 4afbe6292e..1bf944ca3d 100644
--- a/include/qemu/hbitmap.h
+++ b/include/qemu/hbitmap.h
@@ -132,6 +132,11 @@ void hbitmap_set(HBitmap *hb, uint64_t start, uint64_t count);
  * @count: Number of bits to reset.
  *
  * Reset a consecutive range of bits in an HBitmap.
+ * @start and @count must be aligned to bitmap granularity. The only exception
+ * is resetting the tail of the bitmap: @count may be equal to hb->orig_size -
+ * @start, in this case @count may be not aligned. The sum of @start + @count is
+ * allowed to be greater than hb->orig_size, but only if @start < hb->orig_size
+ * and @start + @count = ALIGN_UP(hb->orig_size, granularity).
  */
 void hbitmap_reset(HBitmap *hb, uint64_t start, uint64_t count);
 
diff --git a/include/qemu/iov.h b/include/qemu/iov.h
index 48b45987b7..29957c8a72 100644
--- a/include/qemu/iov.h
+++ b/include/qemu/iov.h
@@ -199,13 +199,20 @@ static inline void *qemu_iovec_buf(QEMUIOVector *qiov)
 
 void qemu_iovec_init(QEMUIOVector *qiov, int alloc_hint);
 void qemu_iovec_init_external(QEMUIOVector *qiov, struct iovec *iov, int niov);
+void qemu_iovec_init_extended(
+        QEMUIOVector *qiov,
+        void *head_buf, size_t head_len,
+        QEMUIOVector *mid_qiov, size_t mid_offset, size_t mid_len,
+        void *tail_buf, size_t tail_len);
+void qemu_iovec_init_slice(QEMUIOVector *qiov, QEMUIOVector *source,
+                           size_t offset, size_t len);
 void qemu_iovec_add(QEMUIOVector *qiov, void *base, size_t len);
 void qemu_iovec_concat(QEMUIOVector *dst,
                        QEMUIOVector *src, size_t soffset, size_t sbytes);
 size_t qemu_iovec_concat_iov(QEMUIOVector *dst,
                              struct iovec *src_iov, unsigned int src_cnt,
                              size_t soffset, size_t sbytes);
-bool qemu_iovec_is_zero(QEMUIOVector *qiov);
+bool qemu_iovec_is_zero(QEMUIOVector *qiov, size_t qiov_offeset, size_t bytes);
 void qemu_iovec_destroy(QEMUIOVector *qiov);
 void qemu_iovec_reset(QEMUIOVector *qiov);
 size_t qemu_iovec_to_buf(QEMUIOVector *qiov, size_t offset,
diff --git a/net/colo-compare.c b/net/colo-compare.c
index 7489840bde..7ee17f2cf8 100644
--- a/net/colo-compare.c
+++ b/net/colo-compare.c
@@ -319,7 +319,7 @@ static bool colo_mark_tcp_pkt(Packet *ppkt, Packet *spkt,
     *mark = 0;
 
     if (ppkt->tcp_seq == spkt->tcp_seq && ppkt->seq_end == spkt->seq_end) {
-        if (colo_compare_packet_payload(ppkt, spkt,
+        if (!colo_compare_packet_payload(ppkt, spkt,
                                         ppkt->header_size, spkt->header_size,
                                         ppkt->payload_size)) {
             *mark = COLO_COMPARE_FREE_SECONDARY | COLO_COMPARE_FREE_PRIMARY;
@@ -329,7 +329,7 @@ static bool colo_mark_tcp_pkt(Packet *ppkt, Packet *spkt,
 
     /* one part of secondary packet payload still need to be compared */
     if (!after(ppkt->seq_end, spkt->seq_end)) {
-        if (colo_compare_packet_payload(ppkt, spkt,
+        if (!colo_compare_packet_payload(ppkt, spkt,
                                         ppkt->header_size + ppkt->offset,
                                         spkt->header_size + spkt->offset,
                                         ppkt->payload_size - ppkt->offset)) {
@@ -348,7 +348,7 @@ static bool colo_mark_tcp_pkt(Packet *ppkt, Packet *spkt,
         /* primary packet is longer than secondary packet, compare
          * the same part and mark the primary packet offset
          */
-        if (colo_compare_packet_payload(ppkt, spkt,
+        if (!colo_compare_packet_payload(ppkt, spkt,
                                         ppkt->header_size + ppkt->offset,
                                         spkt->header_size + spkt->offset,
                                         spkt->payload_size - spkt->offset)) {
diff --git a/net/vhost-user.c b/net/vhost-user.c
index 51921de443..014199d600 100644
--- a/net/vhost-user.c
+++ b/net/vhost-user.c
@@ -235,6 +235,10 @@ static void chr_closed_bh(void *opaque)
 
     s = DO_UPCAST(NetVhostUserState, nc, ncs[0]);
 
+    if (s->vhost_net) {
+        s->acked_features = vhost_net_get_acked_features(s->vhost_net);
+    }
+
     qmp_set_link(name, false, &err);
 
     qemu_chr_fe_set_handlers(&s->chr, NULL, NULL, net_vhost_user_event,
diff --git a/roms/Makefile.edk2 b/roms/Makefile.edk2
index c2f2ff59d5..33a074d3a4 100644
--- a/roms/Makefile.edk2
+++ b/roms/Makefile.edk2
@@ -46,8 +46,13 @@ all: $(foreach flashdev,$(flashdevs),../pc-bios/edk2-$(flashdev).fd.bz2) \
 # files.
 .INTERMEDIATE: $(foreach flashdev,$(flashdevs),../pc-bios/edk2-$(flashdev).fd)
 
+# Fetch edk2 submodule's submodules. If it is not in a git tree, assume
+# we're building from a tarball and that they've already been fetched by
+# make-release/tarball scripts.
 submodules:
-	cd edk2 && git submodule update --init --force
+	if test -d edk2/.git; then \
+		cd edk2 && git submodule update --init --force; \
+	fi
 
 # See notes on the ".NOTPARALLEL" target and the "+" indicator in
 # "tests/uefi-test-tools/Makefile".
diff --git a/scripts/make-release b/scripts/make-release
index b4af9c9e52..a2a8cda33c 100755
--- a/scripts/make-release
+++ b/scripts/make-release
@@ -20,6 +20,14 @@ git checkout "v${version}"
 git submodule update --init
 (cd roms/seabios && git describe --tags --long --dirty > .version)
 (cd roms/skiboot && ./make_version.sh > .version)
+# Fetch edk2 submodule's submodules, since it won't have access to them via
+# the tarball later.
+#
+# A more uniform way to handle this sort of situation would be nice, but we
+# don't necessarily have much control over how a submodule handles its
+# submodule dependencies, so we continue to handle these on a case-by-case
+# basis for now.
+(cd roms/edk2 && git submodule update --init)
 popd
 tar --exclude=.git -cjf ${destination}.tar.bz2 ${destination}
 rm -rf ${destination}
diff --git a/scsi/pr-manager.c b/scsi/pr-manager.c
index ee43663576..0c866e8698 100644
--- a/scsi/pr-manager.c
+++ b/scsi/pr-manager.c
@@ -39,7 +39,6 @@ static int pr_manager_worker(void *opaque)
     int fd = data->fd;
     int r;
 
-    g_free(data);
     trace_pr_manager_run(fd, hdr->cmdp[0], hdr->cmdp[1]);
 
     /* The reference was taken in pr_manager_execute.  */
diff --git a/target/alpha/helper.c b/target/alpha/helper.c
index 93b8e788b1..d0cc623192 100644
--- a/target/alpha/helper.c
+++ b/target/alpha/helper.c
@@ -283,7 +283,9 @@ bool alpha_cpu_tlb_fill(CPUState *cs, vaddr addr, int size,
         cs->exception_index = EXCP_MMFAULT;
         env->trap_arg0 = addr;
         env->trap_arg1 = fail;
-        env->trap_arg2 = (access_type == MMU_INST_FETCH ? -1 : access_type);
+        env->trap_arg2 = (access_type == MMU_DATA_LOAD ? 0ull :
+                          access_type == MMU_DATA_STORE ? 1ull :
+                          /* access_type == MMU_INST_FETCH */ -1ull);
         cpu_loop_exit_restore(cs, retaddr);
     }
 
diff --git a/target/arm/translate-vfp.inc.c b/target/arm/translate-vfp.inc.c
index 092eb5ec53..75406fd9db 100644
--- a/target/arm/translate-vfp.inc.c
+++ b/target/arm/translate-vfp.inc.c
@@ -704,9 +704,10 @@ static bool trans_VMSR_VMRS(DisasContext *s, arg_VMSR_VMRS *a)
     if (arm_dc_feature(s, ARM_FEATURE_M)) {
         /*
          * The only M-profile VFP vmrs/vmsr sysreg is FPSCR.
-         * Writes to R15 are UNPREDICTABLE; we choose to undef.
+         * Accesses to R15 are UNPREDICTABLE; we choose to undef.
+         * (FPSCR -> r15 is a special case which writes to the PSR flags.)
          */
-        if (a->rt == 15 || a->reg != ARM_VFP_FPSCR) {
+        if (a->rt == 15 && (!a->l || a->reg != ARM_VFP_FPSCR)) {
             return false;
         }
     }
@@ -881,8 +882,10 @@ static bool trans_VMOV_64_sp(DisasContext *s, arg_VMOV_64_sp *a)
         /* gpreg to fpreg */
         tmp = load_reg(s, a->rt);
         neon_store_reg32(tmp, a->vm);
+        tcg_temp_free_i32(tmp);
         tmp = load_reg(s, a->rt2);
         neon_store_reg32(tmp, a->vm + 1);
+        tcg_temp_free_i32(tmp);
     }
 
     return true;
diff --git a/target/arm/translate.c b/target/arm/translate.c
index 7853462b21..24cb4ba075 100644
--- a/target/arm/translate.c
+++ b/target/arm/translate.c
@@ -952,10 +952,27 @@ static inline void gen_bx(DisasContext *s, TCGv_i32 var)
     store_cpu_field(var, thumb);
 }
 
-/* Set PC and Thumb state from var. var is marked as dead.
+/*
+ * Set PC and Thumb state from var. var is marked as dead.
  * For M-profile CPUs, include logic to detect exception-return
  * branches and handle them. This is needed for Thumb POP/LDM to PC, LDR to PC,
  * and BX reg, and no others, and happens only for code in Handler mode.
+ * The Security Extension also requires us to check for the FNC_RETURN
+ * which signals a function return from non-secure state; this can happen
+ * in both Handler and Thread mode.
+ * To avoid having to do multiple comparisons in inline generated code,
+ * we make the check we do here loose, so it will match for EXC_RETURN
+ * in Thread mode. For system emulation do_v7m_exception_exit() checks
+ * for these spurious cases and returns without doing anything (giving
+ * the same behaviour as for a branch to a non-magic address).
+ *
+ * In linux-user mode it is unclear what the right behaviour for an
+ * attempted FNC_RETURN should be, because in real hardware this will go
+ * directly to Secure code (ie not the Linux kernel) which will then treat
+ * the error in any way it chooses. For QEMU we opt to make the FNC_RETURN
+ * attempt behave the way it would on a CPU without the security extension,
+ * which is to say "like a normal branch". That means we can simply treat
+ * all branches as normal with no magic address behaviour.
  */
 static inline void gen_bx_excret(DisasContext *s, TCGv_i32 var)
 {
@@ -963,10 +980,12 @@ static inline void gen_bx_excret(DisasContext *s, TCGv_i32 var)
      * s->base.is_jmp that we need to do the rest of the work later.
      */
     gen_bx(s, var);
+#ifndef CONFIG_USER_ONLY
     if (arm_dc_feature(s, ARM_FEATURE_M_SECURITY) ||
         (s->v7m_handler_mode && arm_dc_feature(s, ARM_FEATURE_M))) {
         s->base.is_jmp = DISAS_BX_EXCRET;
     }
+#endif
 }
 
 static inline void gen_bx_excret_final_code(DisasContext *s)
diff --git a/target/s390x/translate_vx.inc.c b/target/s390x/translate_vx.inc.c
index 41d5cf869f..0caddb3958 100644
--- a/target/s390x/translate_vx.inc.c
+++ b/target/s390x/translate_vx.inc.c
@@ -213,7 +213,7 @@ static void get_vec_element_ptr_i64(TCGv_ptr ptr, uint8_t reg, TCGv_i64 enr,
                        vec_full_reg_offset(v3), ptr, 16, 16, data, fn)
 #define gen_gvec_3i(v1, v2, v3, c, gen) \
     tcg_gen_gvec_3i(vec_full_reg_offset(v1), vec_full_reg_offset(v2), \
-                    vec_full_reg_offset(v3), c, 16, 16, gen)
+                    vec_full_reg_offset(v3), 16, 16, c, gen)
 #define gen_gvec_4(v1, v2, v3, v4, gen) \
     tcg_gen_gvec_4(vec_full_reg_offset(v1), vec_full_reg_offset(v2), \
                    vec_full_reg_offset(v3), vec_full_reg_offset(v4), \
diff --git a/target/xtensa/core-test_mmuhifi_c3.c b/target/xtensa/core-test_mmuhifi_c3.c
index 3a59fefa94..089ed7da5d 100644
--- a/target/xtensa/core-test_mmuhifi_c3.c
+++ b/target/xtensa/core-test_mmuhifi_c3.c
@@ -27,8 +27,8 @@
 
 #include "qemu/osdep.h"
 #include "cpu.h"
-#include "exec/exec-all.h"
 #include "exec/gdbstub.h"
+#include "qemu-common.h"
 #include "qemu/host-utils.h"
 
 #include "core-test_mmuhifi_c3/core-isa.h"
@@ -39,7 +39,6 @@
 
 static XtensaConfig test_mmuhifi_c3 __attribute__((unused)) = {
     .name = "test_mmuhifi_c3",
-    .options = XTENSA_OPTIONS,
     .gdb_regmap = {
         .reg = {
 #include "core-test_mmuhifi_c3/gdb-config.inc.c"
diff --git a/target/xtensa/core-test_mmuhifi_c3/core-isa.h b/target/xtensa/core-test_mmuhifi_c3/core-isa.h
index 704a31f7c8..838b1b09da 100644
--- a/target/xtensa/core-test_mmuhifi_c3/core-isa.h
+++ b/target/xtensa/core-test_mmuhifi_c3/core-isa.h
@@ -1,15 +1,37 @@
 /*
- * Xtensa processor core configuration information.
+ * xtensa/config/core-isa.h -- HAL definitions that are dependent on Xtensa
+ *				processor CORE configuration
  *
- * This file is subject to the terms and conditions of version 2.1 of the GNU
- * Lesser General Public License as published by the Free Software Foundation.
- *
- * Copyright (c) 1999-2009 Tensilica Inc.
+ *  See <xtensa/config/core.h>, which includes this file, for more details.
  */
 
+/* Xtensa processor core configuration information.
+
+   Copyright (c) 1999-2019 Tensilica Inc.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
 #ifndef XTENSA_CORE_TEST_MMUHIFI_C3_CORE_ISA_H
 #define XTENSA_CORE_TEST_MMUHIFI_C3_CORE_ISA_H
 
+
 /****************************************************************************
 	    Parameters Useful for Any Code, USER or PRIVILEGED
  ****************************************************************************/
@@ -32,6 +54,7 @@
 #define XCHAL_HAVE_DEBUG		1	/* debug option */
 #define XCHAL_HAVE_DENSITY		1	/* 16-bit instructions */
 #define XCHAL_HAVE_LOOPS		1	/* zero-overhead loops */
+#define XCHAL_LOOP_BUFFER_SIZE		0	/* zero-ov. loop instr buffer size */
 #define XCHAL_HAVE_NSA			1	/* NSA/NSAU instructions */
 #define XCHAL_HAVE_MINMAX		1	/* MIN/MAX instructions */
 #define XCHAL_HAVE_SEXT			1	/* SEXT instruction */
@@ -59,44 +82,73 @@
 #define XCHAL_HAVE_TAP_MASTER		0	/* JTAG TAP control instr's */
 #define XCHAL_HAVE_PRID			1	/* processor ID register */
 #define XCHAL_HAVE_EXTERN_REGS		1	/* WER/RER instructions */
+#define XCHAL_HAVE_MX			1	/* MX core (Tensilica internal) */
 #define XCHAL_HAVE_MP_INTERRUPTS	1	/* interrupt distributor port */
 #define XCHAL_HAVE_MP_RUNSTALL		1	/* core RunStall control port */
+#define XCHAL_HAVE_PSO			0	/* Power Shut-Off */
+#define XCHAL_HAVE_PSO_CDM		0	/* core/debug/mem pwr domains */
+#define XCHAL_HAVE_PSO_FULL_RETENTION	0	/* all regs preserved on PSO */
 #define XCHAL_HAVE_THREADPTR		1	/* THREADPTR register */
 #define XCHAL_HAVE_BOOLEANS		1	/* boolean registers */
 #define XCHAL_HAVE_CP			1	/* CPENABLE reg (coprocessor) */
 #define XCHAL_CP_MAXCFG			2	/* max allowed cp id plus one */
 #define XCHAL_HAVE_MAC16		0	/* MAC16 package */
 #define XCHAL_HAVE_VECTORFPU2005	0	/* vector floating-point pkg */
-#define XCHAL_HAVE_FP			0	/* floating point pkg */
+#define XCHAL_HAVE_FP			0	/* single prec floating point */
+#define XCHAL_HAVE_FP_DIV		0	/* FP with DIV instructions */
+#define XCHAL_HAVE_FP_RECIP		0	/* FP with RECIP instructions */
+#define XCHAL_HAVE_FP_SQRT		0	/* FP with SQRT instructions */
+#define XCHAL_HAVE_FP_RSQRT		0	/* FP with RSQRT instructions */
 #define XCHAL_HAVE_DFP			0	/* double precision FP pkg */
+#define XCHAL_HAVE_DFP_DIV		0	/* DFP with DIV instructions */
+#define XCHAL_HAVE_DFP_RECIP		0	/* DFP with RECIP instructions*/
+#define XCHAL_HAVE_DFP_SQRT		0	/* DFP with SQRT instructions */
+#define XCHAL_HAVE_DFP_RSQRT		0	/* DFP with RSQRT instructions*/
 #define XCHAL_HAVE_DFP_accel		0	/* double precision FP acceleration pkg */
 #define XCHAL_HAVE_VECTRA1		0	/* Vectra I  pkg */
 #define XCHAL_HAVE_VECTRALX		0	/* Vectra LX pkg */
 #define XCHAL_HAVE_HIFIPRO		0	/* HiFiPro Audio Engine pkg */
+#define XCHAL_HAVE_HIFI3		0	/* HiFi3 Audio Engine pkg */
 #define XCHAL_HAVE_HIFI2		1	/* HiFi2 Audio Engine pkg */
+#define XCHAL_HAVE_HIFI2EP		0	/* HiFi2EP */
+#define XCHAL_HAVE_HIFI_MINI		0	
 #define XCHAL_HAVE_CONNXD2		0	/* ConnX D2 pkg */
+#define XCHAL_HAVE_BBE16		0	/* ConnX BBE16 pkg */
+#define XCHAL_HAVE_BBE16_RSQRT		0	/* BBE16 & vector recip sqrt */
+#define XCHAL_HAVE_BBE16_VECDIV		0	/* BBE16 & vector divide */
+#define XCHAL_HAVE_BBE16_DESPREAD	0	/* BBE16 & despread */
+#define XCHAL_HAVE_BBENEP		0	/* ConnX BBENEP pkgs */
+#define XCHAL_HAVE_BSP3			0	/* ConnX BSP3 pkg */
+#define XCHAL_HAVE_BSP3_TRANSPOSE	0	/* BSP3 & transpose32x32 */
+#define XCHAL_HAVE_SSP16		0	/* ConnX SSP16 pkg */
+#define XCHAL_HAVE_SSP16_VITERBI	0	/* SSP16 & viterbi */
+#define XCHAL_HAVE_TURBO16		0	/* ConnX Turbo16 pkg */
+#define XCHAL_HAVE_BBP16		0	/* ConnX BBP16 pkg */
+#define XCHAL_HAVE_FLIX3		0	/* basic 3-way FLIX option */
 
 
 /*----------------------------------------------------------------------
 				MISC
   ----------------------------------------------------------------------*/
 
+#define XCHAL_NUM_LOADSTORE_UNITS	1	/* load/store units */
 #define XCHAL_NUM_WRITEBUFFER_ENTRIES	8	/* size of write buffer */
 #define XCHAL_INST_FETCH_WIDTH		8	/* instr-fetch width in bytes */
 #define XCHAL_DATA_WIDTH		8	/* data width in bytes */
+#define XCHAL_DATA_PIPE_DELAY		1	/* d-side pipeline delay
+						   (1 = 5-stage, 2 = 7-stage) */
 /*  In T1050, applies to selected core load and store instructions (see ISA): */
 #define XCHAL_UNALIGNED_LOAD_EXCEPTION	1	/* unaligned loads cause exc. */
 #define XCHAL_UNALIGNED_STORE_EXCEPTION	1	/* unaligned stores cause exc.*/
 #define XCHAL_UNALIGNED_LOAD_HW		0	/* unaligned loads work in hw */
 #define XCHAL_UNALIGNED_STORE_HW	0	/* unaligned stores work in hw*/
 
-#define XCHAL_SW_VERSION		800000	/* sw version of this header */
+#define XCHAL_SW_VERSION		1000006	/* sw version of this header */
 
 #define XCHAL_CORE_ID			"test_mmuhifi_c3"	/* alphanum core name
 						   (CoreID) set in the Xtensa
 						   Processor Generator */
 
-#define XCHAL_CORE_DESCRIPTION		"test_mmuhifi_c3"
 #define XCHAL_BUILD_UNIQUE_ID		0x00005A6A	/* 22-bit sw build ID */
 
 /*
@@ -136,6 +188,10 @@
 #define XCHAL_DCACHE_IS_WRITEBACK	1	/* writeback feature */
 #define XCHAL_DCACHE_IS_COHERENT	1	/* MP coherence feature */
 
+#define XCHAL_HAVE_PREFETCH		0	/* PREFCTL register */
+#define XCHAL_HAVE_PREFETCH_L1		0	/* prefetch to L1 dcache */
+#define XCHAL_PREFETCH_CASTOUT_LINES	0	/* dcache pref. castout bufsz */
+
 
 
 
@@ -172,6 +228,8 @@
 #define XCHAL_ICACHE_ACCESS_SIZE	8
 #define XCHAL_DCACHE_ACCESS_SIZE	8
 
+#define XCHAL_DCACHE_BANKS		1	/* number of banks */
+
 /*  Number of encoded cache attr bits (see <xtensa/hal.h> for decoded bits):  */
 #define XCHAL_CA_BITS			4
 
@@ -187,6 +245,8 @@
 #define XCHAL_NUM_URAM			0	/* number of core unified RAMs*/
 #define XCHAL_NUM_XLMI			0	/* number of core XLMI ports */
 
+#define XCHAL_HAVE_IMEM_LOADSTORE	1	/* can load/store to IROM/IRAM*/
+
 
 /*----------------------------------------------------------------------
 			INTERRUPTS and TIMERS
@@ -261,6 +321,7 @@
 #define XCHAL_INTTYPE_MASK_TIMER	0x00000140
 #define XCHAL_INTTYPE_MASK_NMI		0x00000000
 #define XCHAL_INTTYPE_MASK_WRITE_ERROR	0x00000000
+#define XCHAL_INTTYPE_MASK_PROFILING	0x00000000
 
 /*  Interrupt numbers assigned to specific interrupt sources:  */
 #define XCHAL_TIMER0_INTERRUPT		6	/* CCOMPARE0 */
@@ -273,7 +334,7 @@
 
 
 /*
- *  External interrupt vectors/levels.
+ *  External interrupt mapping.
  *  These macros describe how Xtensa processor interrupt numbers
  *  (as numbered internally, eg. in INTERRUPT and INTENABLE registers)
  *  map to external BInterrupt<n> pins, for those interrupts
@@ -281,7 +342,7 @@
  *  See the Xtensa processor databook for more details.
  */
 
-/*  Core interrupt numbers mapped to each EXTERNAL interrupt number:  */
+/*  Core interrupt numbers mapped to each EXTERNAL BInterrupt pin number:  */
 #define XCHAL_EXTINT0_NUM		0	/* (intlevel 1) */
 #define XCHAL_EXTINT1_NUM		1	/* (intlevel 1) */
 #define XCHAL_EXTINT2_NUM		2	/* (intlevel 1) */
@@ -291,6 +352,16 @@
 #define XCHAL_EXTINT6_NUM		9	/* (intlevel 1) */
 #define XCHAL_EXTINT7_NUM		10	/* (intlevel 1) */
 #define XCHAL_EXTINT8_NUM		11	/* (intlevel 1) */
+/*  EXTERNAL BInterrupt pin numbers mapped to each core interrupt number:  */
+#define XCHAL_INT0_EXTNUM		0	/* (intlevel 1) */
+#define XCHAL_INT1_EXTNUM		1	/* (intlevel 1) */
+#define XCHAL_INT2_EXTNUM		2	/* (intlevel 1) */
+#define XCHAL_INT3_EXTNUM		3	/* (intlevel 1) */
+#define XCHAL_INT4_EXTNUM		4	/* (intlevel 1) */
+#define XCHAL_INT5_EXTNUM		5	/* (intlevel 1) */
+#define XCHAL_INT9_EXTNUM		6	/* (intlevel 1) */
+#define XCHAL_INT10_EXTNUM		7	/* (intlevel 1) */
+#define XCHAL_INT11_EXTNUM		8	/* (intlevel 1) */
 
 
 /*----------------------------------------------------------------------
@@ -300,11 +371,13 @@
 #define XCHAL_XEA_VERSION		2	/* Xtensa Exception Architecture
 						   number: 1 == XEA1 (old)
 							   2 == XEA2 (new)
-							   0 == XEAX (extern) */
+							   0 == XEAX (extern) or TX */
 #define XCHAL_HAVE_XEA1			0	/* Exception Architecture 1 */
 #define XCHAL_HAVE_XEA2			1	/* Exception Architecture 2 */
 #define XCHAL_HAVE_XEAX			0	/* External Exception Arch. */
 #define XCHAL_HAVE_EXCEPTIONS		1	/* exception option */
+#define XCHAL_HAVE_HALT			0	/* halt architecture option */
+#define XCHAL_HAVE_BOOTLOADER		0	/* boot loader (for TX) */
 #define XCHAL_HAVE_MEM_ECC_PARITY	0	/* local memory ECC/parity */
 #define XCHAL_HAVE_VECTOR_SELECT	1	/* relocatable vectors */
 #define XCHAL_HAVE_VECBASE		1	/* relocatable vectors */
@@ -344,13 +417,30 @@
 
 
 /*----------------------------------------------------------------------
-				DEBUG
+				DEBUG MODULE
   ----------------------------------------------------------------------*/
 
+/*  Misc  */
+#define XCHAL_HAVE_DEBUG_ERI		0	/* ERI to debug module */
+#define XCHAL_HAVE_DEBUG_APB		0	/* APB to debug module */
+#define XCHAL_HAVE_DEBUG_JTAG		0	/* JTAG to debug module */
+
+/*  On-Chip Debug (OCD)  */
 #define XCHAL_HAVE_OCD			1	/* OnChipDebug option */
 #define XCHAL_NUM_IBREAK		0	/* number of IBREAKn regs */
 #define XCHAL_NUM_DBREAK		0	/* number of DBREAKn regs */
-#define XCHAL_HAVE_OCD_DIR_ARRAY	0	/* faster OCD option */
+#define XCHAL_HAVE_OCD_DIR_ARRAY	0	/* faster OCD option (to LX4) */
+#define XCHAL_HAVE_OCD_LS32DDR		0	/* L32DDR/S32DDR (faster OCD) */
+
+/*  TRAX (in core)  */
+#define XCHAL_HAVE_TRAX			0	/* TRAX in debug module */
+#define XCHAL_TRAX_MEM_SIZE		0	/* TRAX memory size in bytes */
+#define XCHAL_TRAX_MEM_SHAREABLE	0	/* start/end regs; ready sig. */
+#define XCHAL_TRAX_ATB_WIDTH		0	/* ATB width (bits), 0=no ATB */
+#define XCHAL_TRAX_TIME_WIDTH		0	/* timestamp bitwidth, 0=none */
+
+/*  Perf counters  */
+#define XCHAL_NUM_PERF_COUNTERS		0	/* performance counters */
 
 
 /*----------------------------------------------------------------------
diff --git a/target/xtensa/core-test_mmuhifi_c3/gdb-config.inc.c b/target/xtensa/core-test_mmuhifi_c3/gdb-config.inc.c
index 618d30dffa..0bca70b5af 100644
--- a/target/xtensa/core-test_mmuhifi_c3/gdb-config.inc.c
+++ b/target/xtensa/core-test_mmuhifi_c3/gdb-config.inc.c
@@ -1,23 +1,25 @@
 /* Configuration for the Xtensa architecture for GDB, the GNU debugger.
 
-   Copyright (C) 2003, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2003-2019 Tensilica Inc.
 
-   This file is part of GDB.
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-  /*    idx ofs bi sz al targno  flags cp typ group name  */
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
   XTREG(  0,  0,32, 4, 4,0x0020,0x0006,-2, 9,0x0100,pc,          0,0,0,0,0,0)
   XTREG(  1,  4,32, 4, 4,0x0100,0x0006,-2, 1,0x0002,ar0,         0,0,0,0,0,0)
   XTREG(  2,  8,32, 4, 4,0x0101,0x0006,-2, 1,0x0002,ar1,         0,0,0,0,0,0)
@@ -58,8 +60,8 @@
   XTREG( 37,148,32, 4, 4,0x0205,0x0006,-2, 2,0x1100,litbase,     0,0,0,0,0,0)
   XTREG( 38,152, 3, 4, 4,0x0248,0x0006,-2, 2,0x1002,windowbase,  0,0,0,0,0,0)
   XTREG( 39,156, 8, 4, 4,0x0249,0x0006,-2, 2,0x1002,windowstart, 0,0,0,0,0,0)
-  XTREG( 40,160,32, 4, 4,0x02b0,0x0002,-2, 2,0x1000,sr176,       0,0,0,0,0,0)
-  XTREG( 41,164,32, 4, 4,0x02d0,0x0002,-2, 2,0x1000,sr208,       0,0,0,0,0,0)
+  XTREG( 40,160,32, 4, 4,0x02b0,0x0002,-2, 2,0x1000,configid0,   0,0,0,0,0,0)
+  XTREG( 41,164,32, 4, 4,0x02d0,0x0002,-2, 2,0x1000,configid1,   0,0,0,0,0,0)
   XTREG( 42,168,19, 4, 4,0x02e6,0x0006,-2, 2,0x1100,ps,          0,0,0,0,0,0)
   XTREG( 43,172,32, 4, 4,0x03e7,0x0006,-2, 3,0x0110,threadptr,   0,0,0,0,0,0)
   XTREG( 44,176,16, 4, 4,0x0204,0x0006,-1, 2,0x1100,br,          0,0,0,0,0,0)
@@ -137,4 +139,82 @@
   XTREG(104,464,32, 4, 4,0x000d,0x0006,-2, 8,0x0100,a13,         0,0,0,0,0,0)
   XTREG(105,468,32, 4, 4,0x000e,0x0006,-2, 8,0x0100,a14,         0,0,0,0,0,0)
   XTREG(106,472,32, 4, 4,0x000f,0x0006,-2, 8,0x0100,a15,         0,0,0,0,0,0)
+  XTREG(107,476, 1, 1, 1,0x0010,0x0006,-2, 6,0x1010,b0,
+            0,0,&xtensa_mask0,0,0,0)
+  XTREG(108,477, 1, 1, 1,0x0011,0x0006,-2, 6,0x1010,b1,
+            0,0,&xtensa_mask1,0,0,0)
+  XTREG(109,478, 1, 1, 1,0x0012,0x0006,-2, 6,0x1010,b2,
+            0,0,&xtensa_mask2,0,0,0)
+  XTREG(110,479, 1, 1, 1,0x0013,0x0006,-2, 6,0x1010,b3,
+            0,0,&xtensa_mask3,0,0,0)
+  XTREG(111,480, 1, 1, 1,0x0014,0x0006,-2, 6,0x1010,b4,
+            0,0,&xtensa_mask4,0,0,0)
+  XTREG(112,481, 1, 1, 1,0x0015,0x0006,-2, 6,0x1010,b5,
+            0,0,&xtensa_mask5,0,0,0)
+  XTREG(113,482, 1, 1, 1,0x0016,0x0006,-2, 6,0x1010,b6,
+            0,0,&xtensa_mask6,0,0,0)
+  XTREG(114,483, 1, 1, 1,0x0017,0x0006,-2, 6,0x1010,b7,
+            0,0,&xtensa_mask7,0,0,0)
+  XTREG(115,484, 1, 1, 1,0x0018,0x0006,-2, 6,0x1010,b8,
+            0,0,&xtensa_mask8,0,0,0)
+  XTREG(116,485, 1, 1, 1,0x0019,0x0006,-2, 6,0x1010,b9,
+            0,0,&xtensa_mask9,0,0,0)
+  XTREG(117,486, 1, 1, 1,0x001a,0x0006,-2, 6,0x1010,b10,
+            0,0,&xtensa_mask10,0,0,0)
+  XTREG(118,487, 1, 1, 1,0x001b,0x0006,-2, 6,0x1010,b11,
+            0,0,&xtensa_mask11,0,0,0)
+  XTREG(119,488, 1, 1, 1,0x001c,0x0006,-2, 6,0x1010,b12,
+            0,0,&xtensa_mask12,0,0,0)
+  XTREG(120,489, 1, 1, 1,0x001d,0x0006,-2, 6,0x1010,b13,
+            0,0,&xtensa_mask13,0,0,0)
+  XTREG(121,490, 1, 1, 1,0x001e,0x0006,-2, 6,0x1010,b14,
+            0,0,&xtensa_mask14,0,0,0)
+  XTREG(122,491, 1, 1, 1,0x001f,0x0006,-2, 6,0x1010,b15,
+            0,0,&xtensa_mask15,0,0,0)
+  XTREG(123,492, 4, 4, 4,0x2003,0x0006,-2, 6,0x1010,psintlevel,
+            0,0,&xtensa_mask16,0,0,0)
+  XTREG(124,496, 1, 4, 4,0x2004,0x0006,-2, 6,0x1010,psum,
+            0,0,&xtensa_mask17,0,0,0)
+  XTREG(125,500, 1, 4, 4,0x2005,0x0006,-2, 6,0x1010,pswoe,
+            0,0,&xtensa_mask18,0,0,0)
+  XTREG(126,504, 2, 4, 4,0x2006,0x0006,-2, 6,0x1010,psring,
+            0,0,&xtensa_mask19,0,0,0)
+  XTREG(127,508, 1, 4, 4,0x2007,0x0006,-2, 6,0x1010,psexcm,
+            0,0,&xtensa_mask20,0,0,0)
+  XTREG(128,512, 2, 4, 4,0x2008,0x0006,-2, 6,0x1010,pscallinc,
+            0,0,&xtensa_mask21,0,0,0)
+  XTREG(129,516, 4, 4, 4,0x2009,0x0006,-2, 6,0x1010,psowb,
+            0,0,&xtensa_mask22,0,0,0)
+  XTREG(130,520,20, 4, 4,0x200a,0x0006,-2, 6,0x1010,litbaddr,
+            0,0,&xtensa_mask23,0,0,0)
+  XTREG(131,524, 1, 4, 4,0x200b,0x0006,-2, 6,0x1010,litben,
+            0,0,&xtensa_mask24,0,0,0)
+  XTREG(132,528, 4, 4, 4,0x200e,0x0006,-2, 6,0x1010,dbnum,
+            0,0,&xtensa_mask25,0,0,0)
+  XTREG(133,532, 8, 4, 4,0x200f,0x0006,-2, 6,0x1010,asid3,
+            0,0,&xtensa_mask26,0,0,0)
+  XTREG(134,536, 8, 4, 4,0x2010,0x0006,-2, 6,0x1010,asid2,
+            0,0,&xtensa_mask27,0,0,0)
+  XTREG(135,540, 8, 4, 4,0x2011,0x0006,-2, 6,0x1010,asid1,
+            0,0,&xtensa_mask28,0,0,0)
+  XTREG(136,544, 2, 4, 4,0x2012,0x0006,-2, 6,0x1010,instpgszid4,
+            0,0,&xtensa_mask29,0,0,0)
+  XTREG(137,548, 2, 4, 4,0x2013,0x0006,-2, 6,0x1010,datapgszid4,
+            0,0,&xtensa_mask30,0,0,0)
+  XTREG(138,552,10, 4, 4,0x2014,0x0006,-2, 6,0x1010,ptbase,
+            0,0,&xtensa_mask31,0,0,0)
+  XTREG(139,556, 1, 4, 4,0x201a,0x0006, 1, 5,0x1010,ae_overflow,
+            0,0,&xtensa_mask32,0,0,0)
+  XTREG(140,560, 6, 4, 4,0x201b,0x0006, 1, 5,0x1010,ae_sar,
+            0,0,&xtensa_mask33,0,0,0)
+  XTREG(141,564, 4, 4, 4,0x201c,0x0006, 1, 5,0x1010,ae_bitptr,
+            0,0,&xtensa_mask34,0,0,0)
+  XTREG(142,568, 4, 4, 4,0x201d,0x0006, 1, 5,0x1010,ae_bitsused,
+            0,0,&xtensa_mask35,0,0,0)
+  XTREG(143,572, 4, 4, 4,0x201e,0x0006, 1, 5,0x1010,ae_tablesize,
+            0,0,&xtensa_mask36,0,0,0)
+  XTREG(144,576, 4, 4, 4,0x201f,0x0006, 1, 5,0x1010,ae_first_ts,
+            0,0,&xtensa_mask37,0,0,0)
+  XTREG(145,580,27, 4, 4,0x2020,0x0006, 1, 5,0x1010,ae_nextoffset,
+            0,0,&xtensa_mask38,0,0,0)
   XTREG_END
diff --git a/target/xtensa/core-test_mmuhifi_c3/xtensa-modules.inc.c b/target/xtensa/core-test_mmuhifi_c3/xtensa-modules.inc.c
index 687631b8fb..28561147fc 100644
--- a/target/xtensa/core-test_mmuhifi_c3/xtensa-modules.inc.c
+++ b/target/xtensa/core-test_mmuhifi_c3/xtensa-modules.inc.c
@@ -1,24 +1,26 @@
 /* Xtensa configuration-specific ISA information.
-   Copyright 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
 
-   This file is part of BFD, the Binary File Descriptor library.
+   Copyright (c) 2003-2019 Tensilica Inc.
 
-   This program is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 3 of the
-   License, or (at your option) any later version.
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
 
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-   02110-1301, USA.  */
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
-#include "qemu/osdep.h"
 #include "xtensa-isa.h"
 #include "xtensa-isa-internal.h"
 
@@ -32,8 +34,8 @@ static xtensa_sysreg_internal sysregs[] = {
   { "BR", 4, 0 },
   { "PTEVADDR", 83, 0 },
   { "DDR", 104, 0 },
-  { "176", 176, 0 },
-  { "208", 208, 0 },
+  { "CONFIGID0", 176, 0 },
+  { "CONFIGID1", 208, 0 },
   { "INTERRUPT", 226, 0 },
   { "INTCLEAR", 227, 0 },
   { "CCOUNT", 234, 0 },
@@ -8633,6 +8635,38 @@ Field_ae_s20_Slot_inst_set (xtensa_insnbuf insn, uint32 val)
   insn[0] = (insn[0] & ~0x700) | (tie_t << 8);
 }
 
+static unsigned
+Field_ae_fld_ohba_Slot_inst_get (const xtensa_insnbuf insn)
+{
+  unsigned tie_t = 0;
+  tie_t = (tie_t << 4) | ((insn[0] << 12) >> 28);
+  return tie_t;
+}
+
+static void
+Field_ae_fld_ohba_Slot_inst_set (xtensa_insnbuf insn, uint32 val)
+{
+  uint32 tie_t;
+  tie_t = (val << 28) >> 28;
+  insn[0] = (insn[0] & ~0xf0000) | (tie_t << 16);
+}
+
+static unsigned
+Field_ae_fld_ohba2_Slot_inst_get (const xtensa_insnbuf insn)
+{
+  unsigned tie_t = 0;
+  tie_t = (tie_t << 4) | ((insn[0] << 12) >> 28);
+  return tie_t;
+}
+
+static void
+Field_ae_fld_ohba2_Slot_inst_set (xtensa_insnbuf insn, uint32 val)
+{
+  uint32 tie_t;
+  tie_t = (val << 28) >> 28;
+  insn[0] = (insn[0] & ~0xf0000) | (tie_t << 16);
+}
+
 static unsigned
 Field_ftsf12_Slot_inst_get (const xtensa_insnbuf insn)
 {
@@ -8794,6 +8828,8 @@ enum xtensa_field_id {
   FIELD_ae_r20,
   FIELD_ae_r10,
   FIELD_ae_s20,
+  FIELD_ae_fld_ohba,
+  FIELD_ae_fld_ohba2,
   FIELD_op0_s3,
   FIELD_ftsf12,
   FIELD_ftsf13,
@@ -9184,7 +9220,7 @@ enum xtensa_interface_id {
   INTERFACE_RMPINT_In
 };
 
-
+
 /* Constant tables.  */
 
 /* constant table ai4c */
@@ -9254,596 +9290,1044 @@ static const unsigned CONST_TBL_b4cu_0[] = {
 /* Instruction operands.  */
 
 static int
-Operand_soffsetx4_decode (uint32 *valp)
+OperandSem_opnd_sem_soffsetx4_decode (uint32 *valp)
 {
-  unsigned soffsetx4_0, offset_0;
-  offset_0 = *valp & 0x3ffff;
-  soffsetx4_0 = 0x4 + ((((int) offset_0 << 14) >> 14) << 2);
-  *valp = soffsetx4_0;
+  unsigned soffsetx4_out_0;
+  unsigned soffsetx4_in_0;
+  soffsetx4_in_0 = *valp & 0x3ffff;
+  soffsetx4_out_0 = 0x4 + ((((int) soffsetx4_in_0 << 14) >> 14) << 2);
+  *valp = soffsetx4_out_0;
   return 0;
 }
 
 static int
-Operand_soffsetx4_encode (uint32 *valp)
+OperandSem_opnd_sem_soffsetx4_encode (uint32 *valp)
 {
-  unsigned offset_0, soffsetx4_0;
-  soffsetx4_0 = *valp;
-  offset_0 = ((soffsetx4_0 - 0x4) >> 2) & 0x3ffff;
-  *valp = offset_0;
+  unsigned soffsetx4_in_0;
+  unsigned soffsetx4_out_0;
+  soffsetx4_out_0 = *valp;
+  soffsetx4_in_0 = ((soffsetx4_out_0 - 0x4) >> 2) & 0x3ffff;
+  *valp = soffsetx4_in_0;
   return 0;
 }
 
 static int
-Operand_soffsetx4_ator (uint32 *valp, uint32 pc)
+OperandSem_opnd_sem_uimm12x8_decode (uint32 *valp)
 {
-  *valp -= (pc & ~0x3);
+  unsigned uimm12x8_out_0;
+  unsigned uimm12x8_in_0;
+  uimm12x8_in_0 = *valp & 0xfff;
+  uimm12x8_out_0 = uimm12x8_in_0 << 3;
+  *valp = uimm12x8_out_0;
   return 0;
 }
 
 static int
-Operand_soffsetx4_rtoa (uint32 *valp, uint32 pc)
+OperandSem_opnd_sem_uimm12x8_encode (uint32 *valp)
 {
-  *valp += (pc & ~0x3);
+  unsigned uimm12x8_in_0;
+  unsigned uimm12x8_out_0;
+  uimm12x8_out_0 = *valp;
+  uimm12x8_in_0 = ((uimm12x8_out_0 >> 3) & 0xfff);
+  *valp = uimm12x8_in_0;
   return 0;
 }
 
 static int
-Operand_uimm12x8_decode (uint32 *valp)
+OperandSem_opnd_sem_simm4_decode (uint32 *valp)
 {
-  unsigned uimm12x8_0, imm12_0;
-  imm12_0 = *valp & 0xfff;
-  uimm12x8_0 = imm12_0 << 3;
-  *valp = uimm12x8_0;
+  unsigned simm4_out_0;
+  unsigned simm4_in_0;
+  simm4_in_0 = *valp & 0xf;
+  simm4_out_0 = ((int) simm4_in_0 << 28) >> 28;
+  *valp = simm4_out_0;
   return 0;
 }
 
 static int
-Operand_uimm12x8_encode (uint32 *valp)
+OperandSem_opnd_sem_simm4_encode (uint32 *valp)
 {
-  unsigned imm12_0, uimm12x8_0;
-  uimm12x8_0 = *valp;
-  imm12_0 = ((uimm12x8_0 >> 3) & 0xfff);
-  *valp = imm12_0;
+  unsigned simm4_in_0;
+  unsigned simm4_out_0;
+  simm4_out_0 = *valp;
+  simm4_in_0 = (simm4_out_0 & 0xf);
+  *valp = simm4_in_0;
   return 0;
 }
 
 static int
-Operand_simm4_decode (uint32 *valp)
+OperandSem_opnd_sem_AR_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
-  unsigned simm4_0, mn_0;
-  mn_0 = *valp & 0xf;
-  simm4_0 = ((int) mn_0 << 28) >> 28;
-  *valp = simm4_0;
   return 0;
 }
 
 static int
-Operand_simm4_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_encode (uint32 *valp)
 {
-  unsigned mn_0, simm4_0;
-  simm4_0 = *valp;
-  mn_0 = (simm4_0 & 0xf);
-  *valp = mn_0;
-  return 0;
+  int error;
+  error = (*valp >= 32);
+  return error;
 }
 
 static int
-Operand_arr_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_AR_0_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 static int
-Operand_arr_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_0_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0xf) != 0;
+  error = (*valp >= 32);
   return error;
 }
 
 static int
-Operand_ars_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_AR_1_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 static int
-Operand_ars_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_1_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0xf) != 0;
+  error = (*valp >= 32);
   return error;
 }
 
 static int
-Operand_art_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_AR_2_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 static int
-Operand_art_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_2_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0xf) != 0;
+  error = (*valp >= 32);
   return error;
 }
 
 static int
-Operand_ar0_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_AR_3_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 static int
-Operand_ar0_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_3_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0x1f) != 0;
+  error = (*valp >= 32);
   return error;
 }
 
 static int
-Operand_ar4_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_AR_4_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
   return 0;
 }
 
 static int
-Operand_ar4_encode (uint32 *valp)
+OperandSem_opnd_sem_AR_4_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0x1f) != 0;
+  error = (*valp >= 32);
   return error;
 }
 
 static int
-Operand_ar8_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_immrx4_decode (uint32 *valp)
 {
+  unsigned immrx4_out_0;
+  unsigned immrx4_in_0;
+  immrx4_in_0 = *valp & 0xf;
+  immrx4_out_0 = (((0xfffffff) << 4) | immrx4_in_0) << 2;
+  *valp = immrx4_out_0;
   return 0;
 }
 
 static int
-Operand_ar8_encode (uint32 *valp)
+OperandSem_opnd_sem_immrx4_encode (uint32 *valp)
+{
+  unsigned immrx4_in_0;
+  unsigned immrx4_out_0;
+  immrx4_out_0 = *valp;
+  immrx4_in_0 = ((immrx4_out_0 >> 2) & 0xf);
+  *valp = immrx4_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_lsi4x4_decode (uint32 *valp)
+{
+  unsigned lsi4x4_out_0;
+  unsigned lsi4x4_in_0;
+  lsi4x4_in_0 = *valp & 0xf;
+  lsi4x4_out_0 = lsi4x4_in_0 << 2;
+  *valp = lsi4x4_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_lsi4x4_encode (uint32 *valp)
+{
+  unsigned lsi4x4_in_0;
+  unsigned lsi4x4_out_0;
+  lsi4x4_out_0 = *valp;
+  lsi4x4_in_0 = ((lsi4x4_out_0 >> 2) & 0xf);
+  *valp = lsi4x4_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm7_decode (uint32 *valp)
+{
+  unsigned simm7_out_0;
+  unsigned simm7_in_0;
+  simm7_in_0 = *valp & 0x7f;
+  simm7_out_0 = ((((-((((simm7_in_0 >> 6) & 1)) & (((simm7_in_0 >> 5) & 1)))) & 0x1ffffff)) << 7) | simm7_in_0;
+  *valp = simm7_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm7_encode (uint32 *valp)
+{
+  unsigned simm7_in_0;
+  unsigned simm7_out_0;
+  simm7_out_0 = *valp;
+  simm7_in_0 = (simm7_out_0 & 0x7f);
+  *valp = simm7_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm6_decode (uint32 *valp)
+{
+  unsigned uimm6_out_0;
+  unsigned uimm6_in_0;
+  uimm6_in_0 = *valp & 0x3f;
+  uimm6_out_0 = 0x4 + (((0) << 6) | uimm6_in_0);
+  *valp = uimm6_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm6_encode (uint32 *valp)
+{
+  unsigned uimm6_in_0;
+  unsigned uimm6_out_0;
+  uimm6_out_0 = *valp;
+  uimm6_in_0 = (uimm6_out_0 - 0x4) & 0x3f;
+  *valp = uimm6_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_ai4const_decode (uint32 *valp)
+{
+  unsigned ai4const_out_0;
+  unsigned ai4const_in_0;
+  ai4const_in_0 = *valp & 0xf;
+  ai4const_out_0 = CONST_TBL_ai4c_0[ai4const_in_0 & 0xf];
+  *valp = ai4const_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_ai4const_encode (uint32 *valp)
+{
+  unsigned ai4const_in_0;
+  unsigned ai4const_out_0;
+  ai4const_out_0 = *valp;
+  switch (ai4const_out_0)
+    {
+    case 0xffffffff: ai4const_in_0 = 0; break;
+    case 0x1: ai4const_in_0 = 0x1; break;
+    case 0x2: ai4const_in_0 = 0x2; break;
+    case 0x3: ai4const_in_0 = 0x3; break;
+    case 0x4: ai4const_in_0 = 0x4; break;
+    case 0x5: ai4const_in_0 = 0x5; break;
+    case 0x6: ai4const_in_0 = 0x6; break;
+    case 0x7: ai4const_in_0 = 0x7; break;
+    case 0x8: ai4const_in_0 = 0x8; break;
+    case 0x9: ai4const_in_0 = 0x9; break;
+    case 0xa: ai4const_in_0 = 0xa; break;
+    case 0xb: ai4const_in_0 = 0xb; break;
+    case 0xc: ai4const_in_0 = 0xc; break;
+    case 0xd: ai4const_in_0 = 0xd; break;
+    case 0xe: ai4const_in_0 = 0xe; break;
+    default: ai4const_in_0 = 0xf; break;
+    }
+  *valp = ai4const_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_b4const_decode (uint32 *valp)
+{
+  unsigned b4const_out_0;
+  unsigned b4const_in_0;
+  b4const_in_0 = *valp & 0xf;
+  b4const_out_0 = CONST_TBL_b4c_0[b4const_in_0 & 0xf];
+  *valp = b4const_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_b4const_encode (uint32 *valp)
+{
+  unsigned b4const_in_0;
+  unsigned b4const_out_0;
+  b4const_out_0 = *valp;
+  switch (b4const_out_0)
+    {
+    case 0xffffffff: b4const_in_0 = 0; break;
+    case 0x1: b4const_in_0 = 0x1; break;
+    case 0x2: b4const_in_0 = 0x2; break;
+    case 0x3: b4const_in_0 = 0x3; break;
+    case 0x4: b4const_in_0 = 0x4; break;
+    case 0x5: b4const_in_0 = 0x5; break;
+    case 0x6: b4const_in_0 = 0x6; break;
+    case 0x7: b4const_in_0 = 0x7; break;
+    case 0x8: b4const_in_0 = 0x8; break;
+    case 0xa: b4const_in_0 = 0x9; break;
+    case 0xc: b4const_in_0 = 0xa; break;
+    case 0x10: b4const_in_0 = 0xb; break;
+    case 0x20: b4const_in_0 = 0xc; break;
+    case 0x40: b4const_in_0 = 0xd; break;
+    case 0x80: b4const_in_0 = 0xe; break;
+    default: b4const_in_0 = 0xf; break;
+    }
+  *valp = b4const_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_b4constu_decode (uint32 *valp)
+{
+  unsigned b4constu_out_0;
+  unsigned b4constu_in_0;
+  b4constu_in_0 = *valp & 0xf;
+  b4constu_out_0 = CONST_TBL_b4cu_0[b4constu_in_0 & 0xf];
+  *valp = b4constu_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_b4constu_encode (uint32 *valp)
+{
+  unsigned b4constu_in_0;
+  unsigned b4constu_out_0;
+  b4constu_out_0 = *valp;
+  switch (b4constu_out_0)
+    {
+    case 0x8000: b4constu_in_0 = 0; break;
+    case 0x10000: b4constu_in_0 = 0x1; break;
+    case 0x2: b4constu_in_0 = 0x2; break;
+    case 0x3: b4constu_in_0 = 0x3; break;
+    case 0x4: b4constu_in_0 = 0x4; break;
+    case 0x5: b4constu_in_0 = 0x5; break;
+    case 0x6: b4constu_in_0 = 0x6; break;
+    case 0x7: b4constu_in_0 = 0x7; break;
+    case 0x8: b4constu_in_0 = 0x8; break;
+    case 0xa: b4constu_in_0 = 0x9; break;
+    case 0xc: b4constu_in_0 = 0xa; break;
+    case 0x10: b4constu_in_0 = 0xb; break;
+    case 0x20: b4constu_in_0 = 0xc; break;
+    case 0x40: b4constu_in_0 = 0xd; break;
+    case 0x80: b4constu_in_0 = 0xe; break;
+    default: b4constu_in_0 = 0xf; break;
+    }
+  *valp = b4constu_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8_decode (uint32 *valp)
+{
+  unsigned uimm8_out_0;
+  unsigned uimm8_in_0;
+  uimm8_in_0 = *valp & 0xff;
+  uimm8_out_0 = uimm8_in_0;
+  *valp = uimm8_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8_encode (uint32 *valp)
+{
+  unsigned uimm8_in_0;
+  unsigned uimm8_out_0;
+  uimm8_out_0 = *valp;
+  uimm8_in_0 = (uimm8_out_0 & 0xff);
+  *valp = uimm8_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8x2_decode (uint32 *valp)
+{
+  unsigned uimm8x2_out_0;
+  unsigned uimm8x2_in_0;
+  uimm8x2_in_0 = *valp & 0xff;
+  uimm8x2_out_0 = uimm8x2_in_0 << 1;
+  *valp = uimm8x2_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8x2_encode (uint32 *valp)
+{
+  unsigned uimm8x2_in_0;
+  unsigned uimm8x2_out_0;
+  uimm8x2_out_0 = *valp;
+  uimm8x2_in_0 = ((uimm8x2_out_0 >> 1) & 0xff);
+  *valp = uimm8x2_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8x4_decode (uint32 *valp)
+{
+  unsigned uimm8x4_out_0;
+  unsigned uimm8x4_in_0;
+  uimm8x4_in_0 = *valp & 0xff;
+  uimm8x4_out_0 = uimm8x4_in_0 << 2;
+  *valp = uimm8x4_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm8x4_encode (uint32 *valp)
+{
+  unsigned uimm8x4_in_0;
+  unsigned uimm8x4_out_0;
+  uimm8x4_out_0 = *valp;
+  uimm8x4_in_0 = ((uimm8x4_out_0 >> 2) & 0xff);
+  *valp = uimm8x4_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm4x16_decode (uint32 *valp)
+{
+  unsigned uimm4x16_out_0;
+  unsigned uimm4x16_in_0;
+  uimm4x16_in_0 = *valp & 0xf;
+  uimm4x16_out_0 = uimm4x16_in_0 << 4;
+  *valp = uimm4x16_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm4x16_encode (uint32 *valp)
+{
+  unsigned uimm4x16_in_0;
+  unsigned uimm4x16_out_0;
+  uimm4x16_out_0 = *valp;
+  uimm4x16_in_0 = ((uimm4x16_out_0 >> 4) & 0xf);
+  *valp = uimm4x16_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm8_decode (uint32 *valp)
+{
+  unsigned simm8_out_0;
+  unsigned simm8_in_0;
+  simm8_in_0 = *valp & 0xff;
+  simm8_out_0 = ((int) simm8_in_0 << 24) >> 24;
+  *valp = simm8_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm8_encode (uint32 *valp)
+{
+  unsigned simm8_in_0;
+  unsigned simm8_out_0;
+  simm8_out_0 = *valp;
+  simm8_in_0 = (simm8_out_0 & 0xff);
+  *valp = simm8_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm8x256_decode (uint32 *valp)
+{
+  unsigned simm8x256_out_0;
+  unsigned simm8x256_in_0;
+  simm8x256_in_0 = *valp & 0xff;
+  simm8x256_out_0 = (((int) simm8x256_in_0 << 24) >> 24) << 8;
+  *valp = simm8x256_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm8x256_encode (uint32 *valp)
+{
+  unsigned simm8x256_in_0;
+  unsigned simm8x256_out_0;
+  simm8x256_out_0 = *valp;
+  simm8x256_in_0 = ((simm8x256_out_0 >> 8) & 0xff);
+  *valp = simm8x256_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm12b_decode (uint32 *valp)
+{
+  unsigned simm12b_out_0;
+  unsigned simm12b_in_0;
+  simm12b_in_0 = *valp & 0xfff;
+  simm12b_out_0 = ((int) simm12b_in_0 << 20) >> 20;
+  *valp = simm12b_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_simm12b_encode (uint32 *valp)
+{
+  unsigned simm12b_in_0;
+  unsigned simm12b_out_0;
+  simm12b_out_0 = *valp;
+  simm12b_in_0 = (simm12b_out_0 & 0xfff);
+  *valp = simm12b_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_msalp32_decode (uint32 *valp)
+{
+  unsigned msalp32_out_0;
+  unsigned msalp32_in_0;
+  msalp32_in_0 = *valp & 0x1f;
+  msalp32_out_0 = 0x20 - msalp32_in_0;
+  *valp = msalp32_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_msalp32_encode (uint32 *valp)
+{
+  unsigned msalp32_in_0;
+  unsigned msalp32_out_0;
+  msalp32_out_0 = *valp;
+  msalp32_in_0 = (0x20 - msalp32_out_0) & 0x1f;
+  *valp = msalp32_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_op2p1_decode (uint32 *valp)
+{
+  unsigned op2p1_out_0;
+  unsigned op2p1_in_0;
+  op2p1_in_0 = *valp & 0xf;
+  op2p1_out_0 = op2p1_in_0 + 0x1;
+  *valp = op2p1_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_op2p1_encode (uint32 *valp)
+{
+  unsigned op2p1_in_0;
+  unsigned op2p1_out_0;
+  op2p1_out_0 = *valp;
+  op2p1_in_0 = (op2p1_out_0 - 0x1) & 0xf;
+  *valp = op2p1_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_label8_decode (uint32 *valp)
+{
+  unsigned label8_out_0;
+  unsigned label8_in_0;
+  label8_in_0 = *valp & 0xff;
+  label8_out_0 = 0x4 + (((int) label8_in_0 << 24) >> 24);
+  *valp = label8_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_label8_encode (uint32 *valp)
+{
+  unsigned label8_in_0;
+  unsigned label8_out_0;
+  label8_out_0 = *valp;
+  label8_in_0 = (label8_out_0 - 0x4) & 0xff;
+  *valp = label8_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_ulabel8_decode (uint32 *valp)
+{
+  unsigned ulabel8_out_0;
+  unsigned ulabel8_in_0;
+  ulabel8_in_0 = *valp & 0xff;
+  ulabel8_out_0 = 0x4 + (((0) << 8) | ulabel8_in_0);
+  *valp = ulabel8_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_ulabel8_encode (uint32 *valp)
+{
+  unsigned ulabel8_in_0;
+  unsigned ulabel8_out_0;
+  ulabel8_out_0 = *valp;
+  ulabel8_in_0 = (ulabel8_out_0 - 0x4) & 0xff;
+  *valp = ulabel8_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_label12_decode (uint32 *valp)
+{
+  unsigned label12_out_0;
+  unsigned label12_in_0;
+  label12_in_0 = *valp & 0xfff;
+  label12_out_0 = 0x4 + (((int) label12_in_0 << 20) >> 20);
+  *valp = label12_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_label12_encode (uint32 *valp)
+{
+  unsigned label12_in_0;
+  unsigned label12_out_0;
+  label12_out_0 = *valp;
+  label12_in_0 = (label12_out_0 - 0x4) & 0xfff;
+  *valp = label12_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_soffset_decode (uint32 *valp)
+{
+  unsigned soffset_out_0;
+  unsigned soffset_in_0;
+  soffset_in_0 = *valp & 0x3ffff;
+  soffset_out_0 = 0x4 + (((int) soffset_in_0 << 14) >> 14);
+  *valp = soffset_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_soffset_encode (uint32 *valp)
+{
+  unsigned soffset_in_0;
+  unsigned soffset_out_0;
+  soffset_out_0 = *valp;
+  soffset_in_0 = (soffset_out_0 - 0x4) & 0x3ffff;
+  *valp = soffset_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm16x4_decode (uint32 *valp)
+{
+  unsigned uimm16x4_out_0;
+  unsigned uimm16x4_in_0;
+  uimm16x4_in_0 = *valp & 0xffff;
+  uimm16x4_out_0 = (((0xffff) << 16) | uimm16x4_in_0) << 2;
+  *valp = uimm16x4_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_uimm16x4_encode (uint32 *valp)
+{
+  unsigned uimm16x4_in_0;
+  unsigned uimm16x4_out_0;
+  uimm16x4_out_0 = *valp;
+  uimm16x4_in_0 = (uimm16x4_out_0 >> 2) & 0xffff;
+  *valp = uimm16x4_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_bbi_decode (uint32 *valp)
+{
+  unsigned bbi_out_0;
+  unsigned bbi_in_0;
+  bbi_in_0 = *valp & 0x1f;
+  bbi_out_0 = (0 << 5) | bbi_in_0;
+  *valp = bbi_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_bbi_encode (uint32 *valp)
+{
+  unsigned bbi_in_0;
+  unsigned bbi_out_0;
+  bbi_out_0 = *valp;
+  bbi_in_0 = (bbi_out_0 & 0x1f);
+  *valp = bbi_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_s_decode (uint32 *valp)
+{
+  unsigned s_out_0;
+  unsigned s_in_0;
+  s_in_0 = *valp & 0xf;
+  s_out_0 = (0 << 4) | s_in_0;
+  *valp = s_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_s_encode (uint32 *valp)
+{
+  unsigned s_in_0;
+  unsigned s_out_0;
+  s_out_0 = *valp;
+  s_in_0 = (s_out_0 & 0xf);
+  *valp = s_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_immt_decode (uint32 *valp)
+{
+  unsigned immt_out_0;
+  unsigned immt_in_0;
+  immt_in_0 = *valp & 0xf;
+  immt_out_0 = immt_in_0;
+  *valp = immt_out_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_immt_encode (uint32 *valp)
+{
+  unsigned immt_in_0;
+  unsigned immt_out_0;
+  immt_out_0 = *valp;
+  immt_in_0 = immt_out_0 & 0xf;
+  *valp = immt_in_0;
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_BR_decode (uint32 *valp ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+static int
+OperandSem_opnd_sem_BR_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0x1f) != 0;
+  error = (*valp >= 16);
   return error;
 }
 
 static int
-Operand_ar12_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_BR2_decode (uint32 *valp)
 {
+  *valp = *valp << 1;
   return 0;
 }
 
 static int
-Operand_ar12_encode (uint32 *valp)
+OperandSem_opnd_sem_BR2_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0x1f) != 0;
+  error = (*valp >= 16) || ((*valp & 1) != 0);
+  *valp = *valp >> 1;
   return error;
 }
 
 static int
-Operand_ars_entry_decode (uint32 *valp ATTRIBUTE_UNUSED)
+OperandSem_opnd_sem_BR4_decode (uint32 *valp)
 {
+  *valp = *valp << 2;
   return 0;
 }
 
 static int
-Operand_ars_entry_encode (uint32 *valp)
+OperandSem_opnd_sem_BR4_encode (uint32 *valp)
 {
   int error;
-  error = (*valp & ~0x1f) != 0;
+  error = (*valp >= 16) || ((*valp & 3) != 0);
+  *valp = *valp >> 2;
   return error;
 }
 
 static int
-Operand_immrx4_decode (uint32 *valp)
+OperandSem_opnd_sem_BR8_decode (uint32 *valp)
 {
-  unsigned immrx4_0, r_0;
-  r_0 = *valp & 0xf;
-  immrx4_0 = (((0xfffffff) << 4) | r_0) << 2;
-  *valp = immrx4_0;
+  *valp = *valp << 3;
   return 0;
 }
 
 static int
-Operand_immrx4_encode (uint32 *valp)
+OperandSem_opnd_sem_BR8_encode (uint32 *valp)
 {
-  unsigned r_0, immrx4_0;
-  immrx4_0 = *valp;
-  r_0 = ((immrx4_0 >> 2) & 0xf);
-  *valp = r_0;
-  return 0;
+  int error;
+  error = (*valp >= 16) || ((*valp & 7) != 0);
+  *valp = *valp >> 3;
+  return error;
 }
 
 static int
-Operand_lsi4x4_decode (uint32 *valp)
+OperandSem_opnd_sem_BR16_decode (uint32 *valp)
 {
-  unsigned lsi4x4_0, r_0;
-  r_0 = *valp & 0xf;
-  lsi4x4_0 = r_0 << 2;
-  *valp = lsi4x4_0;
+  *valp = *valp << 4;
   return 0;
 }
 
 static int
-Operand_lsi4x4_encode (uint32 *valp)
+OperandSem_opnd_sem_BR16_encode (uint32 *valp)
 {
-  unsigned r_0, lsi4x4_0;
-  lsi4x4_0 = *valp;
-  r_0 = ((lsi4x4_0 >> 2) & 0xf);
-  *valp = r_0;
-  return 0;
+  int error;
+  error = (*valp >= 16) || ((*valp & 15) != 0);
+  *valp = *valp >> 4;
+  return error;
 }
 
 static int
-Operand_simm7_decode (uint32 *valp)
+OperandSem_opnd_sem_tp7_decode (uint32 *valp)
 {
-  unsigned simm7_0, imm7_0;
-  imm7_0 = *valp & 0x7f;
-  simm7_0 = ((((-((((imm7_0 >> 6) & 1)) & (((imm7_0 >> 5) & 1)))) & 0x1ffffff)) << 7) | imm7_0;
-  *valp = simm7_0;
+  unsigned tp7_out_0;
+  unsigned tp7_in_0;
+  tp7_in_0 = *valp & 0xf;
+  tp7_out_0 = tp7_in_0 + 0x7;
+  *valp = tp7_out_0;
   return 0;
 }
 
 static int
-Operand_simm7_encode (uint32 *valp)
+OperandSem_opnd_sem_tp7_encode (uint32 *valp)
 {
-  unsigned imm7_0, simm7_0;
-  simm7_0 = *valp;
-  imm7_0 = (simm7_0 & 0x7f);
-  *valp = imm7_0;
+  unsigned tp7_in_0;
+  unsigned tp7_out_0;
+  tp7_out_0 = *valp;
+  tp7_in_0 = (tp7_out_0 - 0x7) & 0xf;
+  *valp = tp7_in_0;
   return 0;
 }
 
 static int
-Operand_uimm6_decode (uint32 *valp)
+OperandSem_opnd_sem_xt_wbr15_label_decode (uint32 *valp)
 {
-  unsigned uimm6_0, imm6_0;
-  imm6_0 = *valp & 0x3f;
-  uimm6_0 = 0x4 + (((0) << 6) | imm6_0);
-  *valp = uimm6_0;
+  unsigned xt_wbr15_label_out_0;
+  unsigned xt_wbr15_label_in_0;
+  xt_wbr15_label_in_0 = *valp & 0x7fff;
+  xt_wbr15_label_out_0 = 0x4 + (((int) xt_wbr15_label_in_0 << 17) >> 17);
+  *valp = xt_wbr15_label_out_0;
   return 0;
 }
 
 static int
-Operand_uimm6_encode (uint32 *valp)
+OperandSem_opnd_sem_xt_wbr15_label_encode (uint32 *valp)
 {
-  unsigned imm6_0, uimm6_0;
-  uimm6_0 = *valp;
-  imm6_0 = (uimm6_0 - 0x4) & 0x3f;
-  *valp = imm6_0;
+  unsigned xt_wbr15_label_in_0;
+  unsigned xt_wbr15_label_out_0;
+  xt_wbr15_label_out_0 = *valp;
+  xt_wbr15_label_in_0 = (xt_wbr15_label_out_0 - 0x4) & 0x7fff;
+  *valp = xt_wbr15_label_in_0;
   return 0;
 }
 
 static int
-Operand_uimm6_ator (uint32 *valp, uint32 pc)
+OperandSem_opnd_sem_ae_samt32_decode (uint32 *valp)
 {
-  *valp -= pc;
+  unsigned ae_samt32_out_0;
+  unsigned ae_samt32_in_0;
+  ae_samt32_in_0 = *valp & 0x1f;
+  ae_samt32_out_0 = (0 << 5) | ae_samt32_in_0;
+  *valp = ae_samt32_out_0;
   return 0;
 }
 
 static int
-Operand_uimm6_rtoa (uint32 *valp, uint32 pc)
+OperandSem_opnd_sem_ae_samt32_encode (uint32 *valp)
 {
-  *valp += pc;
+  unsigned ae_samt32_in_0;
+  unsigned ae_samt32_out_0;
+  ae_samt32_out_0 = *valp;
+  ae_samt32_in_0 = (ae_samt32_out_0 & 0x1f);
+  *valp = ae_samt32_in_0;
   return 0;
 }
 
 static int
-Operand_ai4const_decode (uint32 *valp)
+OperandSem_opnd_sem_AE_PR_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
-  unsigned ai4const_0, t_0;
-  t_0 = *valp & 0xf;
-  ai4const_0 = CONST_TBL_ai4c_0[t_0 & 0xf];
-  *valp = ai4const_0;
   return 0;
 }
 
 static int
-Operand_ai4const_encode (uint32 *valp)
+OperandSem_opnd_sem_AE_PR_encode (uint32 *valp)
 {
-  unsigned t_0, ai4const_0;
-  ai4const_0 = *valp;
-  switch (ai4const_0)
-    {
-    case 0xffffffff: t_0 = 0; break;
-    case 0x1: t_0 = 0x1; break;
-    case 0x2: t_0 = 0x2; break;
-    case 0x3: t_0 = 0x3; break;
-    case 0x4: t_0 = 0x4; break;
-    case 0x5: t_0 = 0x5; break;
-    case 0x6: t_0 = 0x6; break;
-    case 0x7: t_0 = 0x7; break;
-    case 0x8: t_0 = 0x8; break;
-    case 0x9: t_0 = 0x9; break;
-    case 0xa: t_0 = 0xa; break;
-    case 0xb: t_0 = 0xb; break;
-    case 0xc: t_0 = 0xc; break;
-    case 0xd: t_0 = 0xd; break;
-    case 0xe: t_0 = 0xe; break;
-    default: t_0 = 0xf; break;
-    }
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_b4const_decode (uint32 *valp)
-{
-  unsigned b4const_0, r_0;
-  r_0 = *valp & 0xf;
-  b4const_0 = CONST_TBL_b4c_0[r_0 & 0xf];
-  *valp = b4const_0;
-  return 0;
-}
-
-static int
-Operand_b4const_encode (uint32 *valp)
-{
-  unsigned r_0, b4const_0;
-  b4const_0 = *valp;
-  switch (b4const_0)
-    {
-    case 0xffffffff: r_0 = 0; break;
-    case 0x1: r_0 = 0x1; break;
-    case 0x2: r_0 = 0x2; break;
-    case 0x3: r_0 = 0x3; break;
-    case 0x4: r_0 = 0x4; break;
-    case 0x5: r_0 = 0x5; break;
-    case 0x6: r_0 = 0x6; break;
-    case 0x7: r_0 = 0x7; break;
-    case 0x8: r_0 = 0x8; break;
-    case 0xa: r_0 = 0x9; break;
-    case 0xc: r_0 = 0xa; break;
-    case 0x10: r_0 = 0xb; break;
-    case 0x20: r_0 = 0xc; break;
-    case 0x40: r_0 = 0xd; break;
-    case 0x80: r_0 = 0xe; break;
-    default: r_0 = 0xf; break;
-    }
-  *valp = r_0;
-  return 0;
-}
-
-static int
-Operand_b4constu_decode (uint32 *valp)
-{
-  unsigned b4constu_0, r_0;
-  r_0 = *valp & 0xf;
-  b4constu_0 = CONST_TBL_b4cu_0[r_0 & 0xf];
-  *valp = b4constu_0;
-  return 0;
-}
-
-static int
-Operand_b4constu_encode (uint32 *valp)
-{
-  unsigned r_0, b4constu_0;
-  b4constu_0 = *valp;
-  switch (b4constu_0)
-    {
-    case 0x8000: r_0 = 0; break;
-    case 0x10000: r_0 = 0x1; break;
-    case 0x2: r_0 = 0x2; break;
-    case 0x3: r_0 = 0x3; break;
-    case 0x4: r_0 = 0x4; break;
-    case 0x5: r_0 = 0x5; break;
-    case 0x6: r_0 = 0x6; break;
-    case 0x7: r_0 = 0x7; break;
-    case 0x8: r_0 = 0x8; break;
-    case 0xa: r_0 = 0x9; break;
-    case 0xc: r_0 = 0xa; break;
-    case 0x10: r_0 = 0xb; break;
-    case 0x20: r_0 = 0xc; break;
-    case 0x40: r_0 = 0xd; break;
-    case 0x80: r_0 = 0xe; break;
-    default: r_0 = 0xf; break;
-    }
-  *valp = r_0;
-  return 0;
-}
-
-static int
-Operand_uimm8_decode (uint32 *valp)
-{
-  unsigned uimm8_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  uimm8_0 = imm8_0;
-  *valp = uimm8_0;
-  return 0;
-}
-
-static int
-Operand_uimm8_encode (uint32 *valp)
-{
-  unsigned imm8_0, uimm8_0;
-  uimm8_0 = *valp;
-  imm8_0 = (uimm8_0 & 0xff);
-  *valp = imm8_0;
-  return 0;
-}
-
-static int
-Operand_uimm8x2_decode (uint32 *valp)
-{
-  unsigned uimm8x2_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  uimm8x2_0 = imm8_0 << 1;
-  *valp = uimm8x2_0;
-  return 0;
-}
-
-static int
-Operand_uimm8x2_encode (uint32 *valp)
-{
-  unsigned imm8_0, uimm8x2_0;
-  uimm8x2_0 = *valp;
-  imm8_0 = ((uimm8x2_0 >> 1) & 0xff);
-  *valp = imm8_0;
-  return 0;
+  int error;
+  error = (*valp >= 8);
+  return error;
 }
 
 static int
-Operand_uimm8x4_decode (uint32 *valp)
+OperandSem_opnd_sem_AE_QR_decode (uint32 *valp ATTRIBUTE_UNUSED)
 {
-  unsigned uimm8x4_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  uimm8x4_0 = imm8_0 << 2;
-  *valp = uimm8x4_0;
   return 0;
 }
 
 static int
-Operand_uimm8x4_encode (uint32 *valp)
+OperandSem_opnd_sem_AE_QR_encode (uint32 *valp)
 {
-  unsigned imm8_0, uimm8x4_0;
-  uimm8x4_0 = *valp;
-  imm8_0 = ((uimm8x4_0 >> 2) & 0xff);
-  *valp = imm8_0;
-  return 0;
+  int error;
+  error = (*valp >= 4);
+  return error;
 }
 
 static int
-Operand_uimm4x16_decode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm16_decode (uint32 *valp)
 {
-  unsigned uimm4x16_0, op2_0;
-  op2_0 = *valp & 0xf;
-  uimm4x16_0 = op2_0 << 4;
-  *valp = uimm4x16_0;
+  unsigned ae_lsimm16_out_0;
+  unsigned ae_lsimm16_in_0;
+  ae_lsimm16_in_0 = *valp & 0xf;
+  ae_lsimm16_out_0 = (((int) ae_lsimm16_in_0 << 28) >> 28) << 1;
+  *valp = ae_lsimm16_out_0;
   return 0;
 }
 
 static int
-Operand_uimm4x16_encode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm16_encode (uint32 *valp)
 {
-  unsigned op2_0, uimm4x16_0;
-  uimm4x16_0 = *valp;
-  op2_0 = ((uimm4x16_0 >> 4) & 0xf);
-  *valp = op2_0;
+  unsigned ae_lsimm16_in_0;
+  unsigned ae_lsimm16_out_0;
+  ae_lsimm16_out_0 = *valp;
+  ae_lsimm16_in_0 = ((ae_lsimm16_out_0 >> 1) & 0xf);
+  *valp = ae_lsimm16_in_0;
   return 0;
 }
 
 static int
-Operand_simm8_decode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm32_decode (uint32 *valp)
 {
-  unsigned simm8_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  simm8_0 = ((int) imm8_0 << 24) >> 24;
-  *valp = simm8_0;
+  unsigned ae_lsimm32_out_0;
+  unsigned ae_lsimm32_in_0;
+  ae_lsimm32_in_0 = *valp & 0xf;
+  ae_lsimm32_out_0 = (((int) ae_lsimm32_in_0 << 28) >> 28) << 2;
+  *valp = ae_lsimm32_out_0;
   return 0;
 }
 
 static int
-Operand_simm8_encode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm32_encode (uint32 *valp)
 {
-  unsigned imm8_0, simm8_0;
-  simm8_0 = *valp;
-  imm8_0 = (simm8_0 & 0xff);
-  *valp = imm8_0;
+  unsigned ae_lsimm32_in_0;
+  unsigned ae_lsimm32_out_0;
+  ae_lsimm32_out_0 = *valp;
+  ae_lsimm32_in_0 = ((ae_lsimm32_out_0 >> 2) & 0xf);
+  *valp = ae_lsimm32_in_0;
   return 0;
 }
 
 static int
-Operand_simm8x256_decode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm64_decode (uint32 *valp)
 {
-  unsigned simm8x256_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  simm8x256_0 = (((int) imm8_0 << 24) >> 24) << 8;
-  *valp = simm8x256_0;
+  unsigned ae_lsimm64_out_0;
+  unsigned ae_lsimm64_in_0;
+  ae_lsimm64_in_0 = *valp & 0xf;
+  ae_lsimm64_out_0 = (((int) ae_lsimm64_in_0 << 28) >> 28) << 3;
+  *valp = ae_lsimm64_out_0;
   return 0;
 }
 
 static int
-Operand_simm8x256_encode (uint32 *valp)
+OperandSem_opnd_sem_ae_lsimm64_encode (uint32 *valp)
 {
-  unsigned imm8_0, simm8x256_0;
-  simm8x256_0 = *valp;
-  imm8_0 = ((simm8x256_0 >> 8) & 0xff);
-  *valp = imm8_0;
+  unsigned ae_lsimm64_in_0;
+  unsigned ae_lsimm64_out_0;
+  ae_lsimm64_out_0 = *valp;
+  ae_lsimm64_in_0 = ((ae_lsimm64_out_0 >> 3) & 0xf);
+  *valp = ae_lsimm64_in_0;
   return 0;
 }
 
 static int
-Operand_simm12b_decode (uint32 *valp)
+OperandSem_opnd_sem_ae_samt64_decode (uint32 *valp)
 {
-  unsigned simm12b_0, imm12b_0;
-  imm12b_0 = *valp & 0xfff;
-  simm12b_0 = ((int) imm12b_0 << 20) >> 20;
-  *valp = simm12b_0;
+  unsigned ae_samt64_out_0;
+  unsigned ae_samt64_in_0;
+  ae_samt64_in_0 = *valp & 0x3f;
+  ae_samt64_out_0 = (0 << 6) | ae_samt64_in_0;
+  *valp = ae_samt64_out_0;
   return 0;
 }
 
 static int
-Operand_simm12b_encode (uint32 *valp)
+OperandSem_opnd_sem_ae_samt64_encode (uint32 *valp)
 {
-  unsigned imm12b_0, simm12b_0;
-  simm12b_0 = *valp;
-  imm12b_0 = (simm12b_0 & 0xfff);
-  *valp = imm12b_0;
+  unsigned ae_samt64_in_0;
+  unsigned ae_samt64_out_0;
+  ae_samt64_out_0 = *valp;
+  ae_samt64_in_0 = (ae_samt64_out_0 & 0x3f);
+  *valp = ae_samt64_in_0;
   return 0;
 }
 
 static int
-Operand_msalp32_decode (uint32 *valp)
+OperandSem_opnd_sem_ae_ohba_decode (uint32 *valp)
 {
-  unsigned msalp32_0, sal_0;
-  sal_0 = *valp & 0x1f;
-  msalp32_0 = 0x20 - sal_0;
-  *valp = msalp32_0;
+  unsigned ae_ohba_out_0;
+  unsigned ae_ohba_in_0;
+  ae_ohba_in_0 = *valp & 0xf;
+  ae_ohba_out_0 = (0 << 5) | (((((ae_ohba_in_0 & 0xf))) == 0) << 4) | ((ae_ohba_in_0 & 0xf));
+  *valp = ae_ohba_out_0;
   return 0;
 }
 
 static int
-Operand_msalp32_encode (uint32 *valp)
+OperandSem_opnd_sem_ae_ohba_encode (uint32 *valp)
 {
-  unsigned sal_0, msalp32_0;
-  msalp32_0 = *valp;
-  sal_0 = (0x20 - msalp32_0) & 0x1f;
-  *valp = sal_0;
+  unsigned ae_ohba_in_0;
+  unsigned ae_ohba_out_0;
+  ae_ohba_out_0 = *valp;
+  ae_ohba_in_0 = (ae_ohba_out_0 & 0xf);
+  *valp = ae_ohba_in_0;
   return 0;
 }
 
 static int
-Operand_op2p1_decode (uint32 *valp)
+Operand_soffsetx4_ator (uint32 *valp, uint32 pc)
 {
-  unsigned op2p1_0, op2_0;
-  op2_0 = *valp & 0xf;
-  op2p1_0 = op2_0 + 0x1;
-  *valp = op2p1_0;
+  *valp -= (pc & ~0x3);
   return 0;
 }
 
 static int
-Operand_op2p1_encode (uint32 *valp)
+Operand_soffsetx4_rtoa (uint32 *valp, uint32 pc)
 {
-  unsigned op2_0, op2p1_0;
-  op2p1_0 = *valp;
-  op2_0 = (op2p1_0 - 0x1) & 0xf;
-  *valp = op2_0;
+  *valp += (pc & ~0x3);
   return 0;
 }
 
 static int
-Operand_label8_decode (uint32 *valp)
+Operand_uimm6_ator (uint32 *valp, uint32 pc)
 {
-  unsigned label8_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  label8_0 = 0x4 + (((int) imm8_0 << 24) >> 24);
-  *valp = label8_0;
+  *valp -= pc;
   return 0;
 }
 
 static int
-Operand_label8_encode (uint32 *valp)
+Operand_uimm6_rtoa (uint32 *valp, uint32 pc)
 {
-  unsigned imm8_0, label8_0;
-  label8_0 = *valp;
-  imm8_0 = (label8_0 - 0x4) & 0xff;
-  *valp = imm8_0;
+  *valp += pc;
   return 0;
 }
 
@@ -9861,26 +10345,6 @@ Operand_label8_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_ulabel8_decode (uint32 *valp)
-{
-  unsigned ulabel8_0, imm8_0;
-  imm8_0 = *valp & 0xff;
-  ulabel8_0 = 0x4 + (((0) << 8) | imm8_0);
-  *valp = ulabel8_0;
-  return 0;
-}
-
-static int
-Operand_ulabel8_encode (uint32 *valp)
-{
-  unsigned imm8_0, ulabel8_0;
-  ulabel8_0 = *valp;
-  imm8_0 = (ulabel8_0 - 0x4) & 0xff;
-  *valp = imm8_0;
-  return 0;
-}
-
 static int
 Operand_ulabel8_ator (uint32 *valp, uint32 pc)
 {
@@ -9895,26 +10359,6 @@ Operand_ulabel8_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_label12_decode (uint32 *valp)
-{
-  unsigned label12_0, imm12_0;
-  imm12_0 = *valp & 0xfff;
-  label12_0 = 0x4 + (((int) imm12_0 << 20) >> 20);
-  *valp = label12_0;
-  return 0;
-}
-
-static int
-Operand_label12_encode (uint32 *valp)
-{
-  unsigned imm12_0, label12_0;
-  label12_0 = *valp;
-  imm12_0 = (label12_0 - 0x4) & 0xfff;
-  *valp = imm12_0;
-  return 0;
-}
-
 static int
 Operand_label12_ator (uint32 *valp, uint32 pc)
 {
@@ -9929,26 +10373,6 @@ Operand_label12_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_soffset_decode (uint32 *valp)
-{
-  unsigned soffset_0, offset_0;
-  offset_0 = *valp & 0x3ffff;
-  soffset_0 = 0x4 + (((int) offset_0 << 14) >> 14);
-  *valp = soffset_0;
-  return 0;
-}
-
-static int
-Operand_soffset_encode (uint32 *valp)
-{
-  unsigned offset_0, soffset_0;
-  soffset_0 = *valp;
-  offset_0 = (soffset_0 - 0x4) & 0x3ffff;
-  *valp = offset_0;
-  return 0;
-}
-
 static int
 Operand_soffset_ator (uint32 *valp, uint32 pc)
 {
@@ -9963,26 +10387,6 @@ Operand_soffset_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_uimm16x4_decode (uint32 *valp)
-{
-  unsigned uimm16x4_0, imm16_0;
-  imm16_0 = *valp & 0xffff;
-  uimm16x4_0 = (((0xffff) << 16) | imm16_0) << 2;
-  *valp = uimm16x4_0;
-  return 0;
-}
-
-static int
-Operand_uimm16x4_encode (uint32 *valp)
-{
-  unsigned imm16_0, uimm16x4_0;
-  uimm16x4_0 = *valp;
-  imm16_0 = (uimm16x4_0 >> 2) & 0xffff;
-  *valp = imm16_0;
-  return 0;
-}
-
 static int
 Operand_uimm16x4_ator (uint32 *valp, uint32 pc)
 {
@@ -9997,336 +10401,6 @@ Operand_uimm16x4_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_immt_decode (uint32 *valp)
-{
-  unsigned immt_0, t_0;
-  t_0 = *valp & 0xf;
-  immt_0 = t_0;
-  *valp = immt_0;
-  return 0;
-}
-
-static int
-Operand_immt_encode (uint32 *valp)
-{
-  unsigned t_0, immt_0;
-  immt_0 = *valp;
-  t_0 = immt_0 & 0xf;
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_imms_decode (uint32 *valp)
-{
-  unsigned imms_0, s_0;
-  s_0 = *valp & 0xf;
-  imms_0 = s_0;
-  *valp = imms_0;
-  return 0;
-}
-
-static int
-Operand_imms_encode (uint32 *valp)
-{
-  unsigned s_0, imms_0;
-  imms_0 = *valp;
-  s_0 = imms_0 & 0xf;
-  *valp = s_0;
-  return 0;
-}
-
-static int
-Operand_bt_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_bt_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0xf) != 0;
-  return error;
-}
-
-static int
-Operand_bs_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_bs_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0xf) != 0;
-  return error;
-}
-
-static int
-Operand_br_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_br_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0xf) != 0;
-  return error;
-}
-
-static int
-Operand_bt2_decode (uint32 *valp)
-{
-  *valp = *valp << 1;
-  return 0;
-}
-
-static int
-Operand_bt2_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x7 << 1)) != 0;
-  *valp = *valp >> 1;
-  return error;
-}
-
-static int
-Operand_bs2_decode (uint32 *valp)
-{
-  *valp = *valp << 1;
-  return 0;
-}
-
-static int
-Operand_bs2_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x7 << 1)) != 0;
-  *valp = *valp >> 1;
-  return error;
-}
-
-static int
-Operand_br2_decode (uint32 *valp)
-{
-  *valp = *valp << 1;
-  return 0;
-}
-
-static int
-Operand_br2_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x7 << 1)) != 0;
-  *valp = *valp >> 1;
-  return error;
-}
-
-static int
-Operand_bt4_decode (uint32 *valp)
-{
-  *valp = *valp << 2;
-  return 0;
-}
-
-static int
-Operand_bt4_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x3 << 2)) != 0;
-  *valp = *valp >> 2;
-  return error;
-}
-
-static int
-Operand_bs4_decode (uint32 *valp)
-{
-  *valp = *valp << 2;
-  return 0;
-}
-
-static int
-Operand_bs4_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x3 << 2)) != 0;
-  *valp = *valp >> 2;
-  return error;
-}
-
-static int
-Operand_br4_decode (uint32 *valp)
-{
-  *valp = *valp << 2;
-  return 0;
-}
-
-static int
-Operand_br4_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x3 << 2)) != 0;
-  *valp = *valp >> 2;
-  return error;
-}
-
-static int
-Operand_bt8_decode (uint32 *valp)
-{
-  *valp = *valp << 3;
-  return 0;
-}
-
-static int
-Operand_bt8_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x1 << 3)) != 0;
-  *valp = *valp >> 3;
-  return error;
-}
-
-static int
-Operand_bs8_decode (uint32 *valp)
-{
-  *valp = *valp << 3;
-  return 0;
-}
-
-static int
-Operand_bs8_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x1 << 3)) != 0;
-  *valp = *valp >> 3;
-  return error;
-}
-
-static int
-Operand_br8_decode (uint32 *valp)
-{
-  *valp = *valp << 3;
-  return 0;
-}
-
-static int
-Operand_br8_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0x1 << 3)) != 0;
-  *valp = *valp >> 3;
-  return error;
-}
-
-static int
-Operand_bt16_decode (uint32 *valp)
-{
-  *valp = *valp << 4;
-  return 0;
-}
-
-static int
-Operand_bt16_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0 << 4)) != 0;
-  *valp = *valp >> 4;
-  return error;
-}
-
-static int
-Operand_bs16_decode (uint32 *valp)
-{
-  *valp = *valp << 4;
-  return 0;
-}
-
-static int
-Operand_bs16_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0 << 4)) != 0;
-  *valp = *valp >> 4;
-  return error;
-}
-
-static int
-Operand_br16_decode (uint32 *valp)
-{
-  *valp = *valp << 4;
-  return 0;
-}
-
-static int
-Operand_br16_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0 << 4)) != 0;
-  *valp = *valp >> 4;
-  return error;
-}
-
-static int
-Operand_brall_decode (uint32 *valp)
-{
-  *valp = *valp << 4;
-  return 0;
-}
-
-static int
-Operand_brall_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~(0 << 4)) != 0;
-  *valp = *valp >> 4;
-  return error;
-}
-
-static int
-Operand_tp7_decode (uint32 *valp)
-{
-  unsigned tp7_0, t_0;
-  t_0 = *valp & 0xf;
-  tp7_0 = t_0 + 0x7;
-  *valp = tp7_0;
-  return 0;
-}
-
-static int
-Operand_tp7_encode (uint32 *valp)
-{
-  unsigned t_0, tp7_0;
-  tp7_0 = *valp;
-  t_0 = (tp7_0 - 0x7) & 0xf;
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_xt_wbr15_label_decode (uint32 *valp)
-{
-  unsigned xt_wbr15_label_0, xt_wbr15_imm_0;
-  xt_wbr15_imm_0 = *valp & 0x7fff;
-  xt_wbr15_label_0 = 0x4 + (((int) xt_wbr15_imm_0 << 17) >> 17);
-  *valp = xt_wbr15_label_0;
-  return 0;
-}
-
-static int
-Operand_xt_wbr15_label_encode (uint32 *valp)
-{
-  unsigned xt_wbr15_imm_0, xt_wbr15_label_0;
-  xt_wbr15_label_0 = *valp;
-  xt_wbr15_imm_0 = (xt_wbr15_label_0 - 0x4) & 0x7fff;
-  *valp = xt_wbr15_imm_0;
-  return 0;
-}
-
 static int
 Operand_xt_wbr15_label_ator (uint32 *valp, uint32 pc)
 {
@@ -10341,26 +10415,6 @@ Operand_xt_wbr15_label_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_xt_wbr18_label_decode (uint32 *valp)
-{
-  unsigned xt_wbr18_label_0, xt_wbr18_imm_0;
-  xt_wbr18_imm_0 = *valp & 0x3ffff;
-  xt_wbr18_label_0 = 0x4 + (((int) xt_wbr18_imm_0 << 14) >> 14);
-  *valp = xt_wbr18_label_0;
-  return 0;
-}
-
-static int
-Operand_xt_wbr18_label_encode (uint32 *valp)
-{
-  unsigned xt_wbr18_imm_0, xt_wbr18_label_0;
-  xt_wbr18_label_0 = *valp;
-  xt_wbr18_imm_0 = (xt_wbr18_label_0 - 0x4) & 0x3ffff;
-  *valp = xt_wbr18_imm_0;
-  return 0;
-}
-
 static int
 Operand_xt_wbr18_label_ator (uint32 *valp, uint32 pc)
 {
@@ -10375,481 +10429,323 @@ Operand_xt_wbr18_label_rtoa (uint32 *valp, uint32 pc)
   return 0;
 }
 
-static int
-Operand_ae_samt32_decode (uint32 *valp)
-{
-  unsigned ae_samt32_0, ftsf14_0;
-  ftsf14_0 = *valp & 0x1f;
-  ae_samt32_0 = (0 << 5) | ftsf14_0;
-  *valp = ae_samt32_0;
-  return 0;
-}
-
-static int
-Operand_ae_samt32_encode (uint32 *valp)
-{
-  unsigned ftsf14_0, ae_samt32_0;
-  ae_samt32_0 = *valp;
-  ftsf14_0 = (ae_samt32_0 & 0x1f);
-  *valp = ftsf14_0;
-  return 0;
-}
-
-static int
-Operand_pr0_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_pr0_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x7) != 0;
-  return error;
-}
-
-static int
-Operand_qr0_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_qr0_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x3) != 0;
-  return error;
-}
-
-static int
-Operand_ae_lsimm16_decode (uint32 *valp)
-{
-  unsigned ae_lsimm16_0, t_0;
-  t_0 = *valp & 0xf;
-  ae_lsimm16_0 = (((int) t_0 << 28) >> 28) << 1;
-  *valp = ae_lsimm16_0;
-  return 0;
-}
-
-static int
-Operand_ae_lsimm16_encode (uint32 *valp)
-{
-  unsigned t_0, ae_lsimm16_0;
-  ae_lsimm16_0 = *valp;
-  t_0 = ((ae_lsimm16_0 >> 1) & 0xf);
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_ae_lsimm32_decode (uint32 *valp)
-{
-  unsigned ae_lsimm32_0, t_0;
-  t_0 = *valp & 0xf;
-  ae_lsimm32_0 = (((int) t_0 << 28) >> 28) << 2;
-  *valp = ae_lsimm32_0;
-  return 0;
-}
-
-static int
-Operand_ae_lsimm32_encode (uint32 *valp)
-{
-  unsigned t_0, ae_lsimm32_0;
-  ae_lsimm32_0 = *valp;
-  t_0 = ((ae_lsimm32_0 >> 2) & 0xf);
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_ae_lsimm64_decode (uint32 *valp)
-{
-  unsigned ae_lsimm64_0, t_0;
-  t_0 = *valp & 0xf;
-  ae_lsimm64_0 = (((int) t_0 << 28) >> 28) << 3;
-  *valp = ae_lsimm64_0;
-  return 0;
-}
-
-static int
-Operand_ae_lsimm64_encode (uint32 *valp)
-{
-  unsigned t_0, ae_lsimm64_0;
-  ae_lsimm64_0 = *valp;
-  t_0 = ((ae_lsimm64_0 >> 3) & 0xf);
-  *valp = t_0;
-  return 0;
-}
-
-static int
-Operand_ae_samt64_decode (uint32 *valp)
-{
-  unsigned ae_samt64_0, ae_samt_s_t_0;
-  ae_samt_s_t_0 = *valp & 0x3f;
-  ae_samt64_0 = (0 << 6) | ae_samt_s_t_0;
-  *valp = ae_samt64_0;
-  return 0;
-}
-
-static int
-Operand_ae_samt64_encode (uint32 *valp)
-{
-  unsigned ae_samt_s_t_0, ae_samt64_0;
-  ae_samt64_0 = *valp;
-  ae_samt_s_t_0 = (ae_samt64_0 & 0x3f);
-  *valp = ae_samt_s_t_0;
-  return 0;
-}
-
-static int
-Operand_ae_ohba_decode (uint32 *valp)
-{
-  unsigned ae_ohba_0, op1_0;
-  op1_0 = *valp & 0xf;
-  ae_ohba_0 = (0 << 5) | (((((op1_0 & 0xf))) == 0) << 4) | ((op1_0 & 0xf));
-  *valp = ae_ohba_0;
-  return 0;
-}
-
-static int
-Operand_ae_ohba_encode (uint32 *valp)
-{
-  unsigned op1_0, ae_ohba_0;
-  ae_ohba_0 = *valp;
-  op1_0 = (ae_ohba_0 & 0xf);
-  *valp = op1_0;
-  return 0;
-}
-
-static int
-Operand_pr_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_pr_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x7) != 0;
-  return error;
-}
-
-static int
-Operand_qr0_rw_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_qr0_rw_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x3) != 0;
-  return error;
-}
-
-static int
-Operand_qr1_w_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_qr1_w_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x3) != 0;
-  return error;
-}
-
-static int
-Operand_ps_decode (uint32 *valp ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-static int
-Operand_ps_encode (uint32 *valp)
-{
-  int error;
-  error = (*valp & ~0x7) != 0;
-  return error;
-}
-
 static xtensa_operand_internal operands[] = {
   { "soffsetx4", FIELD_offset, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_soffsetx4_encode, Operand_soffsetx4_decode,
+    OperandSem_opnd_sem_soffsetx4_encode, OperandSem_opnd_sem_soffsetx4_decode,
     Operand_soffsetx4_ator, Operand_soffsetx4_rtoa },
   { "uimm12x8", FIELD_imm12, -1, 0,
     0,
-    Operand_uimm12x8_encode, Operand_uimm12x8_decode,
+    OperandSem_opnd_sem_uimm12x8_encode, OperandSem_opnd_sem_uimm12x8_decode,
     0, 0 },
   { "simm4", FIELD_mn, -1, 0,
     0,
-    Operand_simm4_encode, Operand_simm4_decode,
+    OperandSem_opnd_sem_simm4_encode, OperandSem_opnd_sem_simm4_decode,
     0, 0 },
   { "arr", FIELD_r, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_arr_encode, Operand_arr_decode,
+    OperandSem_opnd_sem_AR_encode, OperandSem_opnd_sem_AR_decode,
     0, 0 },
   { "ars", FIELD_s, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_ars_encode, Operand_ars_decode,
+    OperandSem_opnd_sem_AR_encode, OperandSem_opnd_sem_AR_decode,
     0, 0 },
   { "*ars_invisible", FIELD_s, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_ars_encode, Operand_ars_decode,
+    OperandSem_opnd_sem_AR_encode, OperandSem_opnd_sem_AR_decode,
     0, 0 },
   { "art", FIELD_t, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_art_encode, Operand_art_decode,
+    OperandSem_opnd_sem_AR_encode, OperandSem_opnd_sem_AR_decode,
     0, 0 },
   { "ar0", FIELD__ar0, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_ar0_encode, Operand_ar0_decode,
+    OperandSem_opnd_sem_AR_0_encode, OperandSem_opnd_sem_AR_0_decode,
     0, 0 },
   { "ar4", FIELD__ar4, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_ar4_encode, Operand_ar4_decode,
+    OperandSem_opnd_sem_AR_1_encode, OperandSem_opnd_sem_AR_1_decode,
     0, 0 },
   { "ar8", FIELD__ar8, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_ar8_encode, Operand_ar8_decode,
+    OperandSem_opnd_sem_AR_2_encode, OperandSem_opnd_sem_AR_2_decode,
     0, 0 },
   { "ar12", FIELD__ar12, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_ar12_encode, Operand_ar12_decode,
+    OperandSem_opnd_sem_AR_3_encode, OperandSem_opnd_sem_AR_3_decode,
     0, 0 },
   { "ars_entry", FIELD_s, REGFILE_AR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_ars_entry_encode, Operand_ars_entry_decode,
+    OperandSem_opnd_sem_AR_4_encode, OperandSem_opnd_sem_AR_4_decode,
     0, 0 },
   { "immrx4", FIELD_r, -1, 0,
     0,
-    Operand_immrx4_encode, Operand_immrx4_decode,
+    OperandSem_opnd_sem_immrx4_encode, OperandSem_opnd_sem_immrx4_decode,
     0, 0 },
   { "lsi4x4", FIELD_r, -1, 0,
     0,
-    Operand_lsi4x4_encode, Operand_lsi4x4_decode,
+    OperandSem_opnd_sem_lsi4x4_encode, OperandSem_opnd_sem_lsi4x4_decode,
     0, 0 },
   { "simm7", FIELD_imm7, -1, 0,
     0,
-    Operand_simm7_encode, Operand_simm7_decode,
+    OperandSem_opnd_sem_simm7_encode, OperandSem_opnd_sem_simm7_decode,
     0, 0 },
   { "uimm6", FIELD_imm6, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_uimm6_encode, Operand_uimm6_decode,
+    OperandSem_opnd_sem_uimm6_encode, OperandSem_opnd_sem_uimm6_decode,
     Operand_uimm6_ator, Operand_uimm6_rtoa },
   { "ai4const", FIELD_t, -1, 0,
     0,
-    Operand_ai4const_encode, Operand_ai4const_decode,
+    OperandSem_opnd_sem_ai4const_encode, OperandSem_opnd_sem_ai4const_decode,
     0, 0 },
   { "b4const", FIELD_r, -1, 0,
     0,
-    Operand_b4const_encode, Operand_b4const_decode,
+    OperandSem_opnd_sem_b4const_encode, OperandSem_opnd_sem_b4const_decode,
     0, 0 },
   { "b4constu", FIELD_r, -1, 0,
     0,
-    Operand_b4constu_encode, Operand_b4constu_decode,
+    OperandSem_opnd_sem_b4constu_encode, OperandSem_opnd_sem_b4constu_decode,
     0, 0 },
   { "uimm8", FIELD_imm8, -1, 0,
     0,
-    Operand_uimm8_encode, Operand_uimm8_decode,
+    OperandSem_opnd_sem_uimm8_encode, OperandSem_opnd_sem_uimm8_decode,
     0, 0 },
   { "uimm8x2", FIELD_imm8, -1, 0,
     0,
-    Operand_uimm8x2_encode, Operand_uimm8x2_decode,
+    OperandSem_opnd_sem_uimm8x2_encode, OperandSem_opnd_sem_uimm8x2_decode,
     0, 0 },
   { "uimm8x4", FIELD_imm8, -1, 0,
     0,
-    Operand_uimm8x4_encode, Operand_uimm8x4_decode,
+    OperandSem_opnd_sem_uimm8x4_encode, OperandSem_opnd_sem_uimm8x4_decode,
     0, 0 },
   { "uimm4x16", FIELD_op2, -1, 0,
     0,
-    Operand_uimm4x16_encode, Operand_uimm4x16_decode,
+    OperandSem_opnd_sem_uimm4x16_encode, OperandSem_opnd_sem_uimm4x16_decode,
+    0, 0 },
+  { "uimmrx4", FIELD_r, -1, 0,
+    0,
+    OperandSem_opnd_sem_lsi4x4_encode, OperandSem_opnd_sem_lsi4x4_decode,
     0, 0 },
   { "simm8", FIELD_imm8, -1, 0,
     0,
-    Operand_simm8_encode, Operand_simm8_decode,
+    OperandSem_opnd_sem_simm8_encode, OperandSem_opnd_sem_simm8_decode,
     0, 0 },
   { "simm8x256", FIELD_imm8, -1, 0,
     0,
-    Operand_simm8x256_encode, Operand_simm8x256_decode,
+    OperandSem_opnd_sem_simm8x256_encode, OperandSem_opnd_sem_simm8x256_decode,
     0, 0 },
   { "simm12b", FIELD_imm12b, -1, 0,
     0,
-    Operand_simm12b_encode, Operand_simm12b_decode,
+    OperandSem_opnd_sem_simm12b_encode, OperandSem_opnd_sem_simm12b_decode,
     0, 0 },
   { "msalp32", FIELD_sal, -1, 0,
     0,
-    Operand_msalp32_encode, Operand_msalp32_decode,
+    OperandSem_opnd_sem_msalp32_encode, OperandSem_opnd_sem_msalp32_decode,
     0, 0 },
   { "op2p1", FIELD_op2, -1, 0,
     0,
-    Operand_op2p1_encode, Operand_op2p1_decode,
+    OperandSem_opnd_sem_op2p1_encode, OperandSem_opnd_sem_op2p1_decode,
     0, 0 },
   { "label8", FIELD_imm8, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_label8_encode, Operand_label8_decode,
+    OperandSem_opnd_sem_label8_encode, OperandSem_opnd_sem_label8_decode,
     Operand_label8_ator, Operand_label8_rtoa },
   { "ulabel8", FIELD_imm8, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_ulabel8_encode, Operand_ulabel8_decode,
+    OperandSem_opnd_sem_ulabel8_encode, OperandSem_opnd_sem_ulabel8_decode,
     Operand_ulabel8_ator, Operand_ulabel8_rtoa },
   { "label12", FIELD_imm12, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_label12_encode, Operand_label12_decode,
+    OperandSem_opnd_sem_label12_encode, OperandSem_opnd_sem_label12_decode,
     Operand_label12_ator, Operand_label12_rtoa },
   { "soffset", FIELD_offset, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_soffset_encode, Operand_soffset_decode,
+    OperandSem_opnd_sem_soffset_encode, OperandSem_opnd_sem_soffset_decode,
     Operand_soffset_ator, Operand_soffset_rtoa },
   { "uimm16x4", FIELD_imm16, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_uimm16x4_encode, Operand_uimm16x4_decode,
+    OperandSem_opnd_sem_uimm16x4_encode, OperandSem_opnd_sem_uimm16x4_decode,
     Operand_uimm16x4_ator, Operand_uimm16x4_rtoa },
+  { "bbi", FIELD_bbi, -1, 0,
+    0,
+    OperandSem_opnd_sem_bbi_encode, OperandSem_opnd_sem_bbi_decode,
+    0, 0 },
+  { "sae", FIELD_sae, -1, 0,
+    0,
+    OperandSem_opnd_sem_bbi_encode, OperandSem_opnd_sem_bbi_decode,
+    0, 0 },
+  { "sas", FIELD_sas, -1, 0,
+    0,
+    OperandSem_opnd_sem_bbi_encode, OperandSem_opnd_sem_bbi_decode,
+    0, 0 },
+  { "sargt", FIELD_sargt, -1, 0,
+    0,
+    OperandSem_opnd_sem_bbi_encode, OperandSem_opnd_sem_bbi_decode,
+    0, 0 },
+  { "s", FIELD_s, -1, 0,
+    0,
+    OperandSem_opnd_sem_s_encode, OperandSem_opnd_sem_s_decode,
+    0, 0 },
   { "immt", FIELD_t, -1, 0,
     0,
-    Operand_immt_encode, Operand_immt_decode,
+    OperandSem_opnd_sem_immt_encode, OperandSem_opnd_sem_immt_decode,
     0, 0 },
   { "imms", FIELD_s, -1, 0,
     0,
-    Operand_imms_encode, Operand_imms_decode,
+    OperandSem_opnd_sem_immt_encode, OperandSem_opnd_sem_immt_decode,
     0, 0 },
   { "bt", FIELD_t, REGFILE_BR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bt_encode, Operand_bt_decode,
+    OperandSem_opnd_sem_BR_encode, OperandSem_opnd_sem_BR_decode,
     0, 0 },
   { "bs", FIELD_s, REGFILE_BR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bs_encode, Operand_bs_decode,
+    OperandSem_opnd_sem_BR_encode, OperandSem_opnd_sem_BR_decode,
     0, 0 },
   { "br", FIELD_r, REGFILE_BR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_br_encode, Operand_br_decode,
+    OperandSem_opnd_sem_BR_encode, OperandSem_opnd_sem_BR_decode,
     0, 0 },
   { "bt2", FIELD_t2, REGFILE_BR, 2,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bt2_encode, Operand_bt2_decode,
+    OperandSem_opnd_sem_BR2_encode, OperandSem_opnd_sem_BR2_decode,
     0, 0 },
   { "bs2", FIELD_s2, REGFILE_BR, 2,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bs2_encode, Operand_bs2_decode,
+    OperandSem_opnd_sem_BR2_encode, OperandSem_opnd_sem_BR2_decode,
     0, 0 },
   { "br2", FIELD_r2, REGFILE_BR, 2,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_br2_encode, Operand_br2_decode,
+    OperandSem_opnd_sem_BR2_encode, OperandSem_opnd_sem_BR2_decode,
     0, 0 },
   { "bt4", FIELD_t4, REGFILE_BR, 4,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bt4_encode, Operand_bt4_decode,
+    OperandSem_opnd_sem_BR4_encode, OperandSem_opnd_sem_BR4_decode,
     0, 0 },
   { "bs4", FIELD_s4, REGFILE_BR, 4,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bs4_encode, Operand_bs4_decode,
+    OperandSem_opnd_sem_BR4_encode, OperandSem_opnd_sem_BR4_decode,
     0, 0 },
   { "br4", FIELD_r4, REGFILE_BR, 4,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_br4_encode, Operand_br4_decode,
+    OperandSem_opnd_sem_BR4_encode, OperandSem_opnd_sem_BR4_decode,
     0, 0 },
   { "bt8", FIELD_t8, REGFILE_BR, 8,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bt8_encode, Operand_bt8_decode,
+    OperandSem_opnd_sem_BR8_encode, OperandSem_opnd_sem_BR8_decode,
     0, 0 },
   { "bs8", FIELD_s8, REGFILE_BR, 8,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bs8_encode, Operand_bs8_decode,
+    OperandSem_opnd_sem_BR8_encode, OperandSem_opnd_sem_BR8_decode,
     0, 0 },
   { "br8", FIELD_r8, REGFILE_BR, 8,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_br8_encode, Operand_br8_decode,
+    OperandSem_opnd_sem_BR8_encode, OperandSem_opnd_sem_BR8_decode,
     0, 0 },
   { "bt16", FIELD__bt16, REGFILE_BR, 16,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bt16_encode, Operand_bt16_decode,
+    OperandSem_opnd_sem_BR16_encode, OperandSem_opnd_sem_BR16_decode,
     0, 0 },
   { "bs16", FIELD__bs16, REGFILE_BR, 16,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_bs16_encode, Operand_bs16_decode,
+    OperandSem_opnd_sem_BR16_encode, OperandSem_opnd_sem_BR16_decode,
     0, 0 },
   { "br16", FIELD__br16, REGFILE_BR, 16,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_br16_encode, Operand_br16_decode,
+    OperandSem_opnd_sem_BR16_encode, OperandSem_opnd_sem_BR16_decode,
     0, 0 },
   { "brall", FIELD__brall, REGFILE_BR, 16,
     XTENSA_OPERAND_IS_REGISTER | XTENSA_OPERAND_IS_INVISIBLE,
-    Operand_brall_encode, Operand_brall_decode,
+    OperandSem_opnd_sem_BR16_encode, OperandSem_opnd_sem_BR16_decode,
     0, 0 },
   { "tp7", FIELD_t, -1, 0,
     0,
-    Operand_tp7_encode, Operand_tp7_decode,
+    OperandSem_opnd_sem_tp7_encode, OperandSem_opnd_sem_tp7_decode,
     0, 0 },
   { "xt_wbr15_label", FIELD_xt_wbr15_imm, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_xt_wbr15_label_encode, Operand_xt_wbr15_label_decode,
+    OperandSem_opnd_sem_xt_wbr15_label_encode, OperandSem_opnd_sem_xt_wbr15_label_decode,
     Operand_xt_wbr15_label_ator, Operand_xt_wbr15_label_rtoa },
   { "xt_wbr18_label", FIELD_xt_wbr18_imm, -1, 0,
     XTENSA_OPERAND_IS_PCRELATIVE,
-    Operand_xt_wbr18_label_encode, Operand_xt_wbr18_label_decode,
+    OperandSem_opnd_sem_soffset_encode, OperandSem_opnd_sem_soffset_decode,
     Operand_xt_wbr18_label_ator, Operand_xt_wbr18_label_rtoa },
   { "ae_samt32", FIELD_ftsf14, -1, 0,
     0,
-    Operand_ae_samt32_encode, Operand_ae_samt32_decode,
+    OperandSem_opnd_sem_ae_samt32_encode, OperandSem_opnd_sem_ae_samt32_decode,
     0, 0 },
   { "pr0", FIELD_ftsf12, REGFILE_AE_PR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_pr0_encode, Operand_pr0_decode,
+    OperandSem_opnd_sem_AE_PR_encode, OperandSem_opnd_sem_AE_PR_decode,
     0, 0 },
   { "qr0", FIELD_ftsf13, REGFILE_AE_QR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_qr0_encode, Operand_qr0_decode,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
+    0, 0 },
+  { "mac_qr0", FIELD_ftsf13, REGFILE_AE_QR, 1,
+    XTENSA_OPERAND_IS_REGISTER,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
     0, 0 },
   { "ae_lsimm16", FIELD_t, -1, 0,
     0,
-    Operand_ae_lsimm16_encode, Operand_ae_lsimm16_decode,
+    OperandSem_opnd_sem_ae_lsimm16_encode, OperandSem_opnd_sem_ae_lsimm16_decode,
     0, 0 },
   { "ae_lsimm32", FIELD_t, -1, 0,
     0,
-    Operand_ae_lsimm32_encode, Operand_ae_lsimm32_decode,
+    OperandSem_opnd_sem_ae_lsimm32_encode, OperandSem_opnd_sem_ae_lsimm32_decode,
     0, 0 },
   { "ae_lsimm64", FIELD_t, -1, 0,
     0,
-    Operand_ae_lsimm64_encode, Operand_ae_lsimm64_decode,
+    OperandSem_opnd_sem_ae_lsimm64_encode, OperandSem_opnd_sem_ae_lsimm64_decode,
     0, 0 },
   { "ae_samt64", FIELD_ae_samt_s_t, -1, 0,
     0,
-    Operand_ae_samt64_encode, Operand_ae_samt64_decode,
+    OperandSem_opnd_sem_ae_samt64_encode, OperandSem_opnd_sem_ae_samt64_decode,
     0, 0 },
-  { "ae_ohba", FIELD_op1, -1, 0,
+  { "ae_ohba", FIELD_ae_fld_ohba, -1, 0,
     0,
-    Operand_ae_ohba_encode, Operand_ae_ohba_decode,
+    OperandSem_opnd_sem_ae_ohba_encode, OperandSem_opnd_sem_ae_ohba_decode,
+    0, 0 },
+  { "ae_ohba2", FIELD_ae_fld_ohba2, -1, 0,
+    0,
+    OperandSem_opnd_sem_ae_ohba_encode, OperandSem_opnd_sem_ae_ohba_decode,
     0, 0 },
   { "pr", FIELD_ae_r20, REGFILE_AE_PR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_pr_encode, Operand_pr_decode,
+    OperandSem_opnd_sem_AE_PR_encode, OperandSem_opnd_sem_AE_PR_decode,
+    0, 0 },
+  { "cvt_pr", FIELD_ae_r20, REGFILE_AE_PR, 1,
+    XTENSA_OPERAND_IS_REGISTER,
+    OperandSem_opnd_sem_AE_PR_encode, OperandSem_opnd_sem_AE_PR_decode,
     0, 0 },
   { "qr0_rw", FIELD_ae_r10, REGFILE_AE_QR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_qr0_rw_encode, Operand_qr0_rw_decode,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
+    0, 0 },
+  { "mac_qr0_rw", FIELD_ae_r10, REGFILE_AE_QR, 1,
+    XTENSA_OPERAND_IS_REGISTER,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
     0, 0 },
   { "qr1_w", FIELD_ae_r32, REGFILE_AE_QR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_qr1_w_encode, Operand_qr1_w_decode,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
+    0, 0 },
+  { "mac_qr1_w", FIELD_ae_r32, REGFILE_AE_QR, 1,
+    XTENSA_OPERAND_IS_REGISTER,
+    OperandSem_opnd_sem_AE_QR_encode, OperandSem_opnd_sem_AE_QR_decode,
     0, 0 },
   { "ps", FIELD_ae_s20, REGFILE_AE_PR, 1,
     XTENSA_OPERAND_IS_REGISTER,
-    Operand_ps_encode, Operand_ps_decode,
+    OperandSem_opnd_sem_AE_PR_encode, OperandSem_opnd_sem_AE_PR_decode,
+    0, 0 },
+  { "alupppb_ps", FIELD_ae_s20, REGFILE_AE_PR, 1,
+    XTENSA_OPERAND_IS_REGISTER,
+    OperandSem_opnd_sem_AE_PR_encode, OperandSem_opnd_sem_AE_PR_decode,
     0, 0 },
   { "t", FIELD_t, -1, 0, 0, 0, 0, 0, 0 },
   { "bbi4", FIELD_bbi4, -1, 0, 0, 0, 0, 0, 0 },
-  { "bbi", FIELD_bbi, -1, 0, 0, 0, 0, 0, 0 },
   { "imm12", FIELD_imm12, -1, 0, 0, 0, 0, 0, 0 },
   { "imm8", FIELD_imm8, -1, 0, 0, 0, 0, 0, 0 },
-  { "s", FIELD_s, -1, 0, 0, 0, 0, 0, 0 },
   { "imm12b", FIELD_imm12b, -1, 0, 0, 0, 0, 0, 0 },
   { "imm16", FIELD_imm16, -1, 0, 0, 0, 0, 0, 0 },
   { "m", FIELD_m, -1, 0, 0, 0, 0, 0, 0 },
@@ -10861,11 +10757,8 @@ static xtensa_operand_internal operands[] = {
   { "r", FIELD_r, -1, 0, 0, 0, 0, 0, 0 },
   { "sa4", FIELD_sa4, -1, 0, 0, 0, 0, 0, 0 },
   { "sae4", FIELD_sae4, -1, 0, 0, 0, 0, 0, 0 },
-  { "sae", FIELD_sae, -1, 0, 0, 0, 0, 0, 0 },
   { "sal", FIELD_sal, -1, 0, 0, 0, 0, 0, 0 },
-  { "sargt", FIELD_sargt, -1, 0, 0, 0, 0, 0, 0 },
   { "sas4", FIELD_sas4, -1, 0, 0, 0, 0, 0, 0 },
-  { "sas", FIELD_sas, -1, 0, 0, 0, 0, 0, 0 },
   { "sr", FIELD_sr, -1, 0, 0, 0, 0, 0, 0 },
   { "st", FIELD_st, -1, 0, 0, 0, 0, 0, 0 },
   { "thi3", FIELD_thi3, -1, 0, 0, 0, 0, 0, 0 },
@@ -10898,6 +10791,8 @@ static xtensa_operand_internal operands[] = {
   { "ae_r20", FIELD_ae_r20, -1, 0, 0, 0, 0, 0, 0 },
   { "ae_r10", FIELD_ae_r10, -1, 0, 0, 0, 0, 0, 0 },
   { "ae_s20", FIELD_ae_s20, -1, 0, 0, 0, 0, 0, 0 },
+  { "ae_fld_ohba", FIELD_ae_fld_ohba, -1, 0, 0, 0, 0, 0, 0 },
+  { "ae_fld_ohba2", FIELD_ae_fld_ohba2, -1, 0, 0, 0, 0, 0, 0 },
   { "op0_s3", FIELD_op0_s3, -1, 0, 0, 0, 0, 0, 0 },
   { "ftsf12", FIELD_ftsf12, -1, 0, 0, 0, 0, 0, 0 },
   { "ftsf13", FIELD_ftsf13, -1, 0, 0, 0, 0, 0, 0 },
@@ -11249,6 +11144,7 @@ enum xtensa_operand_id {
   OPERAND_uimm8x2,
   OPERAND_uimm8x4,
   OPERAND_uimm4x16,
+  OPERAND_uimmrx4,
   OPERAND_simm8,
   OPERAND_simm8x256,
   OPERAND_simm12b,
@@ -11259,6 +11155,11 @@ enum xtensa_operand_id {
   OPERAND_label12,
   OPERAND_soffset,
   OPERAND_uimm16x4,
+  OPERAND_bbi,
+  OPERAND_sae,
+  OPERAND_sas,
+  OPERAND_sargt,
+  OPERAND_s,
   OPERAND_immt,
   OPERAND_imms,
   OPERAND_bt,
@@ -11283,21 +11184,25 @@ enum xtensa_operand_id {
   OPERAND_ae_samt32,
   OPERAND_pr0,
   OPERAND_qr0,
+  OPERAND_mac_qr0,
   OPERAND_ae_lsimm16,
   OPERAND_ae_lsimm32,
   OPERAND_ae_lsimm64,
   OPERAND_ae_samt64,
   OPERAND_ae_ohba,
+  OPERAND_ae_ohba2,
   OPERAND_pr,
+  OPERAND_cvt_pr,
   OPERAND_qr0_rw,
+  OPERAND_mac_qr0_rw,
   OPERAND_qr1_w,
+  OPERAND_mac_qr1_w,
   OPERAND_ps,
+  OPERAND_alupppb_ps,
   OPERAND_t,
   OPERAND_bbi4,
-  OPERAND_bbi,
   OPERAND_imm12,
   OPERAND_imm8,
-  OPERAND_s,
   OPERAND_imm12b,
   OPERAND_imm16,
   OPERAND_m,
@@ -11309,11 +11214,8 @@ enum xtensa_operand_id {
   OPERAND_r,
   OPERAND_sa4,
   OPERAND_sae4,
-  OPERAND_sae,
   OPERAND_sal,
-  OPERAND_sargt,
   OPERAND_sas4,
-  OPERAND_sas,
   OPERAND_sr,
   OPERAND_st,
   OPERAND_thi3,
@@ -11346,6 +11248,8 @@ enum xtensa_operand_id {
   OPERAND_ae_r20,
   OPERAND_ae_r10,
   OPERAND_ae_s20,
+  OPERAND_ae_fld_ohba,
+  OPERAND_ae_fld_ohba2,
   OPERAND_op0_s3,
   OPERAND_ftsf12,
   OPERAND_ftsf13,
@@ -12316,29 +12220,29 @@ static xtensa_arg_internal Iclass_xt_iclass_xsr_litbase_stateArgs[] = {
   { { STATE_LITBEN }, 'm' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_rsr_176_args[] = {
+static xtensa_arg_internal Iclass_xt_iclass_rsr_configid0_args[] = {
   { { OPERAND_art }, 'o' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_rsr_176_stateArgs[] = {
+static xtensa_arg_internal Iclass_xt_iclass_rsr_configid0_stateArgs[] = {
   { { STATE_PSEXCM }, 'i' },
   { { STATE_PSRING }, 'i' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_wsr_176_args[] = {
+static xtensa_arg_internal Iclass_xt_iclass_wsr_configid0_args[] = {
   { { OPERAND_art }, 'i' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_wsr_176_stateArgs[] = {
+static xtensa_arg_internal Iclass_xt_iclass_wsr_configid0_stateArgs[] = {
   { { STATE_PSEXCM }, 'i' },
   { { STATE_PSRING }, 'i' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_rsr_208_args[] = {
+static xtensa_arg_internal Iclass_xt_iclass_rsr_configid1_args[] = {
   { { OPERAND_art }, 'o' }
 };
 
-static xtensa_arg_internal Iclass_xt_iclass_rsr_208_stateArgs[] = {
+static xtensa_arg_internal Iclass_xt_iclass_rsr_configid1_stateArgs[] = {
   { { STATE_PSEXCM }, 'i' },
   { { STATE_PSRING }, 'i' }
 };
@@ -14759,7 +14663,7 @@ static xtensa_arg_internal Iclass_ae_iclass_cvtq48a32s_stateArgs[] = {
 
 static xtensa_arg_internal Iclass_ae_iclass_cvtq48p24s_l_args[] = {
   { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_pr }, 'i' }
+  { { OPERAND_cvt_pr }, 'i' }
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_cvtq48p24s_l_stateArgs[] = {
@@ -14768,7 +14672,7 @@ static xtensa_arg_internal Iclass_ae_iclass_cvtq48p24s_l_stateArgs[] = {
 
 static xtensa_arg_internal Iclass_ae_iclass_cvtq48p24s_h_args[] = {
   { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_pr }, 'i' }
+  { { OPERAND_cvt_pr }, 'i' }
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_cvtq48p24s_h_stateArgs[] = {
@@ -14918,7 +14822,7 @@ static xtensa_arg_internal Iclass_ae_iclass_minp24s_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_maxbp24s_args[] = {
-  { { OPERAND_ps }, 'o' },
+  { { OPERAND_alupppb_ps }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' },
   { { OPERAND_bt2 }, 'o' }
@@ -14929,7 +14833,7 @@ static xtensa_arg_internal Iclass_ae_iclass_maxbp24s_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_minbp24s_args[] = {
-  { { OPERAND_ps }, 'o' },
+  { { OPERAND_alupppb_ps }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' },
   { { OPERAND_bt2 }, 'o' }
@@ -15458,7 +15362,7 @@ static xtensa_arg_internal Iclass_ae_iclass_nsaq56s_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15469,7 +15373,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15479,7 +15383,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulp24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15489,7 +15393,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulp24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15500,7 +15404,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15510,7 +15414,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulp24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15520,7 +15424,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulp24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15531,7 +15435,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15541,7 +15445,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulp24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15551,7 +15455,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulp24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15562,7 +15466,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfs32p16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15572,7 +15476,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfp24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulp24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15582,7 +15486,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulp24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15593,7 +15497,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15603,7 +15507,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulap24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15613,7 +15517,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulap24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15624,7 +15528,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15634,7 +15538,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulap24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15644,7 +15548,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulap24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15655,7 +15559,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15665,7 +15569,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulap24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15675,7 +15579,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulap24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15686,7 +15590,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs32p16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15696,7 +15600,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafp24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulap24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15706,7 +15610,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulap24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15717,7 +15621,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15727,7 +15631,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15737,7 +15641,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15748,7 +15652,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15758,7 +15662,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15768,7 +15672,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15779,7 +15683,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15789,7 +15693,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15799,7 +15703,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15810,7 +15714,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs32p16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15820,7 +15724,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfp24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15830,7 +15734,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsp24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15841,7 +15745,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15852,7 +15756,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15863,7 +15767,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15874,7 +15778,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15885,7 +15789,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15896,7 +15800,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15907,7 +15811,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafs56p24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15918,7 +15822,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulas56p24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15929,7 +15833,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15940,7 +15844,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15951,7 +15855,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15962,7 +15866,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15973,7 +15877,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_hl_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15984,7 +15888,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_hl_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -15995,7 +15899,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfs56p24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16006,8 +15910,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulss56p24s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16016,8 +15920,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16026,8 +15930,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16036,8 +15940,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16046,8 +15950,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulfq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16056,8 +15960,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16066,8 +15970,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16076,8 +15980,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16086,8 +15990,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16096,8 +16000,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16106,8 +16010,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16116,8 +16020,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16126,8 +16030,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulafq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16136,8 +16040,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16146,8 +16050,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16156,8 +16060,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16166,8 +16070,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16176,8 +16080,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16186,8 +16090,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16196,8 +16100,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16206,8 +16110,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsfq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16s_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16216,8 +16120,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16s_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16s_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16226,8 +16130,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16s_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16u_l_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16236,8 +16140,8 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16u_l_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16u_h_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'm' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' }
 };
 
@@ -16246,10 +16150,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsq32sp16u_h_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16258,10 +16162,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16270,10 +16174,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16282,10 +16186,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16294,10 +16198,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16306,10 +16210,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16318,10 +16222,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16330,10 +16234,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16342,10 +16246,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16354,10 +16258,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16366,10 +16270,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16378,10 +16282,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaaq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16390,10 +16294,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16402,10 +16306,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16414,10 +16318,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16426,10 +16330,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16438,10 +16342,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16450,10 +16354,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16462,10 +16366,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16474,10 +16378,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16486,10 +16390,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16498,10 +16402,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16510,10 +16414,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16522,10 +16426,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16534,10 +16438,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16546,10 +16450,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16558,10 +16462,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16570,10 +16474,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16582,10 +16486,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16594,10 +16498,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16606,10 +16510,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16618,10 +16522,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16630,10 +16534,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16642,10 +16546,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16654,10 +16558,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16666,10 +16570,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsaq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16678,10 +16582,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16690,10 +16594,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16702,10 +16606,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16714,10 +16618,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16726,10 +16630,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16738,10 +16642,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16750,10 +16654,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16762,10 +16666,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_hh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16774,10 +16678,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_hh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16786,10 +16690,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16798,10 +16702,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16s_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16810,10 +16714,10 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
-  { { OPERAND_qr0_rw }, 'i' },
+  { { OPERAND_mac_qr1_w }, 'o' },
+  { { OPERAND_mac_qr0_rw }, 'i' },
   { { OPERAND_pr }, 'i' },
-  { { OPERAND_qr0 }, 'i' },
+  { { OPERAND_mac_qr0 }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
 
@@ -16822,7 +16726,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfq32sp16u_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16832,7 +16736,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaap24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16842,7 +16746,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaap24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaafp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16852,7 +16756,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaafp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzaap24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16862,7 +16766,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzaap24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16872,7 +16776,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16882,7 +16786,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasfp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16892,7 +16796,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasfp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzasp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16902,7 +16806,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzasp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16912,7 +16816,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsap24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16922,7 +16826,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsap24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsafp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16932,7 +16836,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsafp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzsap24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16942,7 +16846,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzsap24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16952,7 +16856,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16962,7 +16866,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssfp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16972,7 +16876,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssfp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulzssp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'o' },
+  { { OPERAND_mac_qr1_w }, 'o' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16982,7 +16886,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulzssp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaafp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -16992,7 +16896,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaafp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaap24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17002,7 +16906,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaap24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaafp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17012,7 +16916,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaafp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulaap24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17022,7 +16926,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulaap24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulasfp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17032,7 +16936,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulasfp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulasp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17042,7 +16946,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulasp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulasfp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17052,7 +16956,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulasfp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulasp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17062,7 +16966,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulasp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsafp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17072,7 +16976,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsafp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsap24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17082,7 +16986,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsap24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsafp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17092,7 +16996,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsafp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulsap24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17102,7 +17006,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulsap24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulssfp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17112,7 +17016,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulssfp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulssp24s_hh_ll_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17122,7 +17026,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulssp24s_hh_ll_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulssfp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17132,7 +17036,7 @@ static xtensa_arg_internal Iclass_ae_iclass_mulssfp24s_hl_lh_stateArgs[] = {
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_mulssp24s_hl_lh_args[] = {
-  { { OPERAND_qr1_w }, 'm' },
+  { { OPERAND_mac_qr1_w }, 'm' },
   { { OPERAND_pr }, 'i' },
   { { OPERAND_pr0 }, 'i' }
 };
@@ -17215,7 +17119,7 @@ static xtensa_arg_internal Iclass_ae_iclass_lb_stateArgs[] = {
 
 static xtensa_arg_internal Iclass_ae_iclass_lbi_args[] = {
   { { OPERAND_arr }, 'o' },
-  { { OPERAND_ae_ohba }, 'i' }
+  { { OPERAND_ae_ohba2 }, 'i' }
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_lbi_stateArgs[] = {
@@ -17239,7 +17143,7 @@ static xtensa_arg_internal Iclass_ae_iclass_lbk_stateArgs[] = {
 static xtensa_arg_internal Iclass_ae_iclass_lbki_args[] = {
   { { OPERAND_arr }, 'o' },
   { { OPERAND_ars }, 'i' },
-  { { OPERAND_ae_ohba }, 'i' }
+  { { OPERAND_ae_ohba2 }, 'i' }
 };
 
 static xtensa_arg_internal Iclass_ae_iclass_lbki_stateArgs[] = {
@@ -17349,8 +17253,6 @@ static xtensa_iclass_internal iclasses[] = {
     3, Iclass_xt_iclass_rfde_stateArgs, 0, 0 },
   { 0, 0 /* xt_iclass_syscall */,
     0, 0, 0, 0 },
-  { 0, 0 /* xt_iclass_simcall */,
-    0, 0, 0, 0 },
   { 2, Iclass_xt_iclass_call12_args,
     1, Iclass_xt_iclass_call12_stateArgs, 0, 0 },
   { 2, Iclass_xt_iclass_call8_args,
@@ -17467,6 +17369,8 @@ static xtensa_iclass_internal iclasses[] = {
     0, 0, 0, 0 },
   { 1, Iclass_xt_iclass_return_args,
     0, 0, 0, 0 },
+  { 0, 0 /* xt_iclass_simcall */,
+    0, 0, 0, 0 },
   { 3, Iclass_xt_iclass_s16i_args,
     0, 0, 0, 0 },
   { 3, Iclass_xt_iclass_s32i_args,
@@ -17529,12 +17433,12 @@ static xtensa_iclass_internal iclasses[] = {
     2, Iclass_xt_iclass_wsr_litbase_stateArgs, 0, 0 },
   { 1, Iclass_xt_iclass_xsr_litbase_args,
     2, Iclass_xt_iclass_xsr_litbase_stateArgs, 0, 0 },
-  { 1, Iclass_xt_iclass_rsr_176_args,
-    2, Iclass_xt_iclass_rsr_176_stateArgs, 0, 0 },
-  { 1, Iclass_xt_iclass_wsr_176_args,
-    2, Iclass_xt_iclass_wsr_176_stateArgs, 0, 0 },
-  { 1, Iclass_xt_iclass_rsr_208_args,
-    2, Iclass_xt_iclass_rsr_208_stateArgs, 0, 0 },
+  { 1, Iclass_xt_iclass_rsr_configid0_args,
+    2, Iclass_xt_iclass_rsr_configid0_stateArgs, 0, 0 },
+  { 1, Iclass_xt_iclass_wsr_configid0_args,
+    2, Iclass_xt_iclass_wsr_configid0_stateArgs, 0, 0 },
+  { 1, Iclass_xt_iclass_rsr_configid1_args,
+    2, Iclass_xt_iclass_rsr_configid1_stateArgs, 0, 0 },
   { 1, Iclass_xt_iclass_rsr_ps_args,
     7, Iclass_xt_iclass_rsr_ps_stateArgs, 0, 0 },
   { 1, Iclass_xt_iclass_wsr_ps_args,
@@ -18524,7 +18428,6 @@ enum xtensa_iclass_id {
   ICLASS_xt_iclass_rfe,
   ICLASS_xt_iclass_rfde,
   ICLASS_xt_iclass_syscall,
-  ICLASS_xt_iclass_simcall,
   ICLASS_xt_iclass_call12,
   ICLASS_xt_iclass_call8,
   ICLASS_xt_iclass_call4,
@@ -18583,6 +18486,7 @@ enum xtensa_iclass_id {
   ICLASS_xt_iclass_neg,
   ICLASS_xt_iclass_nop,
   ICLASS_xt_iclass_return,
+  ICLASS_xt_iclass_simcall,
   ICLASS_xt_iclass_s16i,
   ICLASS_xt_iclass_s32i,
   ICLASS_xt_iclass_s8i,
@@ -18614,9 +18518,9 @@ enum xtensa_iclass_id {
   ICLASS_xt_iclass_rsr_litbase,
   ICLASS_xt_iclass_wsr_litbase,
   ICLASS_xt_iclass_xsr_litbase,
-  ICLASS_xt_iclass_rsr_176,
-  ICLASS_xt_iclass_wsr_176,
-  ICLASS_xt_iclass_rsr_208,
+  ICLASS_xt_iclass_rsr_configid0,
+  ICLASS_xt_iclass_wsr_configid0,
+  ICLASS_xt_iclass_rsr_configid1,
   ICLASS_xt_iclass_rsr_ps,
   ICLASS_xt_iclass_wsr_ps,
   ICLASS_xt_iclass_xsr_ps,
@@ -19137,12 +19041,6 @@ Opcode_syscall_Slot_inst_encode (xtensa_insnbuf slotbuf)
   slotbuf[0] = 0x5000;
 }
 
-static void
-Opcode_simcall_Slot_inst_encode (xtensa_insnbuf slotbuf)
-{
-  slotbuf[0] = 0x5100;
-}
-
 static void
 Opcode_call12_Slot_inst_encode (xtensa_insnbuf slotbuf)
 {
@@ -20031,6 +19929,12 @@ Opcode_ret_Slot_inst_encode (xtensa_insnbuf slotbuf)
   slotbuf[0] = 0x80;
 }
 
+static void
+Opcode_simcall_Slot_inst_encode (xtensa_insnbuf slotbuf)
+{
+  slotbuf[0] = 0x5100;
+}
+
 static void
 Opcode_s16i_Slot_inst_encode (xtensa_insnbuf slotbuf)
 {
@@ -20344,19 +20248,19 @@ Opcode_xsr_litbase_Slot_inst_encode (xtensa_insnbuf slotbuf)
 }
 
 static void
-Opcode_rsr_176_Slot_inst_encode (xtensa_insnbuf slotbuf)
+Opcode_rsr_configid0_Slot_inst_encode (xtensa_insnbuf slotbuf)
 {
   slotbuf[0] = 0x3b000;
 }
 
 static void
-Opcode_wsr_176_Slot_inst_encode (xtensa_insnbuf slotbuf)
+Opcode_wsr_configid0_Slot_inst_encode (xtensa_insnbuf slotbuf)
 {
   slotbuf[0] = 0x13b000;
 }
 
 static void
-Opcode_rsr_208_Slot_inst_encode (xtensa_insnbuf slotbuf)
+Opcode_rsr_configid1_Slot_inst_encode (xtensa_insnbuf slotbuf)
 {
   slotbuf[0] = 0x3d000;
 }
@@ -24175,10 +24079,6 @@ static xtensa_opcode_encode_fn Opcode_syscall_encode_fns[] = {
   Opcode_syscall_Slot_inst_encode, 0, 0, 0, 0
 };
 
-static xtensa_opcode_encode_fn Opcode_simcall_encode_fns[] = {
-  Opcode_simcall_Slot_inst_encode, 0, 0, 0, 0
-};
-
 static xtensa_opcode_encode_fn Opcode_call12_encode_fns[] = {
   Opcode_call12_Slot_inst_encode, 0, 0, 0, 0
 };
@@ -24555,6 +24455,10 @@ static xtensa_opcode_encode_fn Opcode_ret_encode_fns[] = {
   Opcode_ret_Slot_inst_encode, 0, 0, 0, 0
 };
 
+static xtensa_opcode_encode_fn Opcode_simcall_encode_fns[] = {
+  Opcode_simcall_Slot_inst_encode, 0, 0, 0, 0
+};
+
 static xtensa_opcode_encode_fn Opcode_s16i_encode_fns[] = {
   Opcode_s16i_Slot_inst_encode, 0, 0, 0, Opcode_s16i_Slot_ae_slot0_encode
 };
@@ -24703,16 +24607,16 @@ static xtensa_opcode_encode_fn Opcode_xsr_litbase_encode_fns[] = {
   Opcode_xsr_litbase_Slot_inst_encode, 0, 0, 0, 0
 };
 
-static xtensa_opcode_encode_fn Opcode_rsr_176_encode_fns[] = {
-  Opcode_rsr_176_Slot_inst_encode, 0, 0, 0, 0
+static xtensa_opcode_encode_fn Opcode_rsr_configid0_encode_fns[] = {
+  Opcode_rsr_configid0_Slot_inst_encode, 0, 0, 0, 0
 };
 
-static xtensa_opcode_encode_fn Opcode_wsr_176_encode_fns[] = {
-  Opcode_wsr_176_Slot_inst_encode, 0, 0, 0, 0
+static xtensa_opcode_encode_fn Opcode_wsr_configid0_encode_fns[] = {
+  Opcode_wsr_configid0_Slot_inst_encode, 0, 0, 0, 0
 };
 
-static xtensa_opcode_encode_fn Opcode_rsr_208_encode_fns[] = {
-  Opcode_rsr_208_Slot_inst_encode, 0, 0, 0, 0
+static xtensa_opcode_encode_fn Opcode_rsr_configid1_encode_fns[] = {
+  Opcode_rsr_configid1_Slot_inst_encode, 0, 0, 0, 0
 };
 
 static xtensa_opcode_encode_fn Opcode_rsr_ps_encode_fns[] = {
@@ -26873,9 +26777,6 @@ static xtensa_opcode_internal opcodes[] = {
   { "syscall", ICLASS_xt_iclass_syscall,
     0,
     Opcode_syscall_encode_fns, 0, 0 },
-  { "simcall", ICLASS_xt_iclass_simcall,
-    0,
-    Opcode_simcall_encode_fns, 0, 0 },
   { "call12", ICLASS_xt_iclass_call12,
     XTENSA_OPCODE_IS_CALL,
     Opcode_call12_encode_fns, 0, 0 },
@@ -27158,6 +27059,9 @@ static xtensa_opcode_internal opcodes[] = {
   { "ret", ICLASS_xt_iclass_return,
     XTENSA_OPCODE_IS_JUMP,
     Opcode_ret_encode_fns, 0, 0 },
+  { "simcall", ICLASS_xt_iclass_simcall,
+    0,
+    Opcode_simcall_encode_fns, 0, 0 },
   { "s16i", ICLASS_xt_iclass_s16i,
     0,
     Opcode_s16i_encode_fns, 0, 0 },
@@ -27269,15 +27173,15 @@ static xtensa_opcode_internal opcodes[] = {
   { "xsr.litbase", ICLASS_xt_iclass_xsr_litbase,
     0,
     Opcode_xsr_litbase_encode_fns, 0, 0 },
-  { "rsr.176", ICLASS_xt_iclass_rsr_176,
+  { "rsr.configid0", ICLASS_xt_iclass_rsr_configid0,
     0,
-    Opcode_rsr_176_encode_fns, 0, 0 },
-  { "wsr.176", ICLASS_xt_iclass_wsr_176,
+    Opcode_rsr_configid0_encode_fns, 0, 0 },
+  { "wsr.configid0", ICLASS_xt_iclass_wsr_configid0,
     0,
-    Opcode_wsr_176_encode_fns, 0, 0 },
-  { "rsr.208", ICLASS_xt_iclass_rsr_208,
+    Opcode_wsr_configid0_encode_fns, 0, 0 },
+  { "rsr.configid1", ICLASS_xt_iclass_rsr_configid1,
     0,
-    Opcode_rsr_208_encode_fns, 0, 0 },
+    Opcode_rsr_configid1_encode_fns, 0, 0 },
   { "rsr.ps", ICLASS_xt_iclass_rsr_ps,
     0,
     Opcode_rsr_ps_encode_fns, 0, 0 },
@@ -28836,7 +28740,6 @@ enum xtensa_opcode_id {
   OPCODE_RFE,
   OPCODE_RFDE,
   OPCODE_SYSCALL,
-  OPCODE_SIMCALL,
   OPCODE_CALL12,
   OPCODE_CALL8,
   OPCODE_CALL4,
@@ -28931,6 +28834,7 @@ enum xtensa_opcode_id {
   OPCODE_ABS,
   OPCODE_NOP,
   OPCODE_RET,
+  OPCODE_SIMCALL,
   OPCODE_S16I,
   OPCODE_S32I,
   OPCODE_S8I,
@@ -28968,9 +28872,9 @@ enum xtensa_opcode_id {
   OPCODE_RSR_LITBASE,
   OPCODE_WSR_LITBASE,
   OPCODE_XSR_LITBASE,
-  OPCODE_RSR_176,
-  OPCODE_WSR_176,
-  OPCODE_RSR_208,
+  OPCODE_RSR_CONFIGID0,
+  OPCODE_WSR_CONFIGID0,
+  OPCODE_RSR_CONFIGID1,
   OPCODE_RSR_PS,
   OPCODE_WSR_PS,
   OPCODE_XSR_PS,
@@ -29496,1327 +29400,1252 @@ enum xtensa_opcode_id {
 static int
 Slot_inst_decode (const xtensa_insnbuf insn)
 {
-  switch (Field_op0_Slot_inst_get (insn))
+  if (Field_op0_Slot_inst_get (insn) == 0)
     {
-    case 0:
-      switch (Field_op1_Slot_inst_get (insn))
+      if (Field_op1_Slot_inst_get (insn) == 0)
 	{
-	case 0:
-	  switch (Field_op2_Slot_inst_get (insn))
+	  if (Field_op2_Slot_inst_get (insn) == 0)
 	    {
-	    case 0:
-	      switch (Field_r_Slot_inst_get (insn))
+	      if (Field_r_Slot_inst_get (insn) == 0)
 		{
-		case 0:
-		  switch (Field_m_Slot_inst_get (insn))
-		    {
-		    case 0:
-		      if (Field_s_Slot_inst_get (insn) == 0 &&
-			  Field_n_Slot_inst_get (insn) == 0)
-			return OPCODE_ILL;
-		      break;
-		    case 2:
-		      switch (Field_n_Slot_inst_get (insn))
-			{
-			case 0:
-			  return OPCODE_RET;
-			case 1:
-			  return OPCODE_RETW;
-			case 2:
-			  return OPCODE_JX;
-			}
-		      break;
-		    case 3:
-		      switch (Field_n_Slot_inst_get (insn))
-			{
-			case 0:
-			  return OPCODE_CALLX0;
-			case 1:
-			  return OPCODE_CALLX4;
-			case 2:
-			  return OPCODE_CALLX8;
-			case 3:
-			  return OPCODE_CALLX12;
-			}
-		      break;
-		    }
-		  break;
-		case 1:
-		  return OPCODE_MOVSP;
-		case 2:
-		  if (Field_s_Slot_inst_get (insn) == 0)
-		    {
-		      switch (Field_t_Slot_inst_get (insn))
-			{
-			case 0:
-			  return OPCODE_ISYNC;
-			case 1:
-			  return OPCODE_RSYNC;
-			case 2:
-			  return OPCODE_ESYNC;
-			case 3:
-			  return OPCODE_DSYNC;
-			case 8:
-			  return OPCODE_EXCW;
-			case 12:
-			  return OPCODE_MEMW;
-			case 13:
-			  return OPCODE_EXTW;
-			case 15:
-			  return OPCODE_NOP;
-			}
-		    }
-		  break;
-		case 3:
-		  switch (Field_t_Slot_inst_get (insn))
+		  if (Field_m_Slot_inst_get (insn) == 0 &&
+		      Field_s_Slot_inst_get (insn) == 0 &&
+		      Field_n_Slot_inst_get (insn) == 0)
+		    return OPCODE_ILL;
+		  if (Field_m_Slot_inst_get (insn) == 2)
 		    {
-		    case 0:
-		      switch (Field_s_Slot_inst_get (insn))
-			{
-			case 0:
-			  return OPCODE_RFE;
-			case 2:
-			  return OPCODE_RFDE;
-			case 4:
-			  return OPCODE_RFWO;
-			case 5:
-			  return OPCODE_RFWU;
-			}
-		      break;
-		    case 1:
-		      return OPCODE_RFI;
+		      if (Field_n_Slot_inst_get (insn) == 0)
+			return OPCODE_RET;
+		      if (Field_n_Slot_inst_get (insn) == 1)
+			return OPCODE_RETW;
+		      if (Field_n_Slot_inst_get (insn) == 2)
+			return OPCODE_JX;
 		    }
-		  break;
-		case 4:
-		  return OPCODE_BREAK;
-		case 5:
-		  switch (Field_s_Slot_inst_get (insn))
+		  if (Field_m_Slot_inst_get (insn) == 3)
 		    {
-		    case 0:
-		      if (Field_t_Slot_inst_get (insn) == 0)
-			return OPCODE_SYSCALL;
-		      break;
-		    case 1:
-		      if (Field_t_Slot_inst_get (insn) == 0)
-			return OPCODE_SIMCALL;
-		      break;
+		      if (Field_n_Slot_inst_get (insn) == 0)
+			return OPCODE_CALLX0;
+		      if (Field_n_Slot_inst_get (insn) == 1)
+			return OPCODE_CALLX4;
+		      if (Field_n_Slot_inst_get (insn) == 2)
+			return OPCODE_CALLX8;
+		      if (Field_n_Slot_inst_get (insn) == 3)
+			return OPCODE_CALLX12;
 		    }
-		  break;
-		case 6:
-		  return OPCODE_RSIL;
-		case 7:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_WAITI;
-		  break;
-		case 8:
-		  return OPCODE_ANY4;
-		case 9:
-		  return OPCODE_ALL4;
-		case 10:
-		  return OPCODE_ANY8;
-		case 11:
-		  return OPCODE_ALL8;
 		}
-	      break;
-	    case 1:
-	      return OPCODE_AND;
-	    case 2:
-	      return OPCODE_OR;
-	    case 3:
-	      return OPCODE_XOR;
-	    case 4:
-	      switch (Field_r_Slot_inst_get (insn))
+	      if (Field_r_Slot_inst_get (insn) == 1)
+		return OPCODE_MOVSP;
+	      if (Field_r_Slot_inst_get (insn) == 2)
 		{
-		case 0:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_SSR;
-		  break;
-		case 1:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_SSL;
-		  break;
-		case 2:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_SSA8L;
-		  break;
-		case 3:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_SSA8B;
-		  break;
-		case 4:
-		  if (Field_thi3_Slot_inst_get (insn) == 0)
-		    return OPCODE_SSAI;
-		  break;
-		case 6:
-		  return OPCODE_RER;
-		case 7:
-		  return OPCODE_WER;
-		case 8:
 		  if (Field_s_Slot_inst_get (insn) == 0)
-		    return OPCODE_ROTW;
-		  break;
-		case 14:
-		  return OPCODE_NSA;
-		case 15:
-		  return OPCODE_NSAU;
+		    {
+		      if (Field_t_Slot_inst_get (insn) == 0)
+			return OPCODE_ISYNC;
+		      if (Field_t_Slot_inst_get (insn) == 1)
+			return OPCODE_RSYNC;
+		      if (Field_t_Slot_inst_get (insn) == 2)
+			return OPCODE_ESYNC;
+		      if (Field_t_Slot_inst_get (insn) == 3)
+			return OPCODE_DSYNC;
+		      if (Field_t_Slot_inst_get (insn) == 8)
+			return OPCODE_EXCW;
+		      if (Field_t_Slot_inst_get (insn) == 12)
+			return OPCODE_MEMW;
+		      if (Field_t_Slot_inst_get (insn) == 13)
+			return OPCODE_EXTW;
+		      if (Field_t_Slot_inst_get (insn) == 15)
+			return OPCODE_NOP;
+		    }
 		}
-	      break;
-	    case 5:
-	      switch (Field_r_Slot_inst_get (insn))
+	      if (Field_r_Slot_inst_get (insn) == 3)
 		{
-		case 1:
-		  return OPCODE_HWWITLBA;
-		case 3:
-		  return OPCODE_RITLB0;
-		case 4:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_IITLB;
-		  break;
-		case 5:
-		  return OPCODE_PITLB;
-		case 6:
-		  return OPCODE_WITLB;
-		case 7:
-		  return OPCODE_RITLB1;
-		case 9:
-		  return OPCODE_HWWDTLBA;
-		case 11:
-		  return OPCODE_RDTLB0;
-		case 12:
 		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_IDTLB;
-		  break;
-		case 13:
-		  return OPCODE_PDTLB;
-		case 14:
-		  return OPCODE_WDTLB;
-		case 15:
-		  return OPCODE_RDTLB1;
-		}
-	      break;
-	    case 6:
-	      switch (Field_s_Slot_inst_get (insn))
-		{
-		case 0:
-		  return OPCODE_NEG;
-		case 1:
-		  return OPCODE_ABS;
-		}
-	      break;
-	    case 8:
-	      return OPCODE_ADD;
-	    case 9:
-	      return OPCODE_ADDX2;
-	    case 10:
-	      return OPCODE_ADDX4;
-	    case 11:
-	      return OPCODE_ADDX8;
-	    case 12:
-	      return OPCODE_SUB;
-	    case 13:
-	      return OPCODE_SUBX2;
-	    case 14:
-	      return OPCODE_SUBX4;
-	    case 15:
-	      return OPCODE_SUBX8;
-	    }
-	  break;
-	case 1:
-	  switch (Field_op2_Slot_inst_get (insn))
-	    {
-	    case 0:
-	    case 1:
-	      return OPCODE_SLLI;
-	    case 2:
-	    case 3:
-	      return OPCODE_SRAI;
-	    case 4:
-	      return OPCODE_SRLI;
-	    case 6:
-	      switch (Field_sr_Slot_inst_get (insn))
-		{
-		case 0:
-		  return OPCODE_XSR_LBEG;
-		case 1:
-		  return OPCODE_XSR_LEND;
-		case 2:
-		  return OPCODE_XSR_LCOUNT;
-		case 3:
-		  return OPCODE_XSR_SAR;
-		case 4:
-		  return OPCODE_XSR_BR;
-		case 5:
-		  return OPCODE_XSR_LITBASE;
-		case 12:
-		  return OPCODE_XSR_SCOMPARE1;
-		case 72:
-		  return OPCODE_XSR_WINDOWBASE;
-		case 73:
-		  return OPCODE_XSR_WINDOWSTART;
-		case 83:
-		  return OPCODE_XSR_PTEVADDR;
-		case 90:
-		  return OPCODE_XSR_RASID;
-		case 91:
-		  return OPCODE_XSR_ITLBCFG;
-		case 92:
-		  return OPCODE_XSR_DTLBCFG;
-		case 99:
-		  return OPCODE_XSR_ATOMCTL;
-		case 104:
-		  return OPCODE_XSR_DDR;
-		case 177:
-		  return OPCODE_XSR_EPC1;
-		case 178:
-		  return OPCODE_XSR_EPC2;
-		case 192:
-		  return OPCODE_XSR_DEPC;
-		case 194:
-		  return OPCODE_XSR_EPS2;
-		case 209:
-		  return OPCODE_XSR_EXCSAVE1;
-		case 210:
-		  return OPCODE_XSR_EXCSAVE2;
-		case 224:
-		  return OPCODE_XSR_CPENABLE;
-		case 228:
-		  return OPCODE_XSR_INTENABLE;
-		case 230:
-		  return OPCODE_XSR_PS;
-		case 231:
-		  return OPCODE_XSR_VECBASE;
-		case 232:
-		  return OPCODE_XSR_EXCCAUSE;
-		case 233:
-		  return OPCODE_XSR_DEBUGCAUSE;
-		case 234:
-		  return OPCODE_XSR_CCOUNT;
-		case 236:
-		  return OPCODE_XSR_ICOUNT;
-		case 237:
-		  return OPCODE_XSR_ICOUNTLEVEL;
-		case 238:
-		  return OPCODE_XSR_EXCVADDR;
-		case 240:
-		  return OPCODE_XSR_CCOMPARE0;
-		case 241:
-		  return OPCODE_XSR_CCOMPARE1;
-		case 244:
-		  return OPCODE_XSR_MISC0;
-		case 245:
-		  return OPCODE_XSR_MISC1;
+		    {
+		      if (Field_s_Slot_inst_get (insn) == 0)
+			return OPCODE_RFE;
+		      if (Field_s_Slot_inst_get (insn) == 2)
+			return OPCODE_RFDE;
+		      if (Field_s_Slot_inst_get (insn) == 4)
+			return OPCODE_RFWO;
+		      if (Field_s_Slot_inst_get (insn) == 5)
+			return OPCODE_RFWU;
+		    }
+		  if (Field_t_Slot_inst_get (insn) == 1)
+		    return OPCODE_RFI;
 		}
-	      break;
-	    case 8:
-	      return OPCODE_SRC;
-	    case 9:
-	      if (Field_s_Slot_inst_get (insn) == 0)
-		return OPCODE_SRL;
-	      break;
-	    case 10:
-	      if (Field_t_Slot_inst_get (insn) == 0)
-		return OPCODE_SLL;
-	      break;
-	    case 11:
-	      if (Field_s_Slot_inst_get (insn) == 0)
-		return OPCODE_SRA;
-	      break;
-	    case 12:
-	      return OPCODE_MUL16U;
-	    case 13:
-	      return OPCODE_MUL16S;
-	    case 15:
-	      switch (Field_r_Slot_inst_get (insn))
+	      if (Field_r_Slot_inst_get (insn) == 4)
+		return OPCODE_BREAK;
+	      if (Field_r_Slot_inst_get (insn) == 5)
 		{
-		case 0:
-		  return OPCODE_LICT;
-		case 1:
-		  return OPCODE_SICT;
-		case 2:
-		  return OPCODE_LICW;
-		case 3:
-		  return OPCODE_SICW;
-		case 8:
-		  return OPCODE_LDCT;
-		case 9:
-		  return OPCODE_SDCT;
-		case 14:
-		  if (Field_t_Slot_inst_get (insn) == 0)
-		    return OPCODE_RFDO;
-		  if (Field_t_Slot_inst_get (insn) == 1)
-		    return OPCODE_RFDD;
-		  break;
-		case 15:
-		  return OPCODE_LDPTE;
+		  if (Field_s_Slot_inst_get (insn) == 0 &&
+		      Field_t_Slot_inst_get (insn) == 0)
+		    return OPCODE_SYSCALL;
+		  if (Field_s_Slot_inst_get (insn) == 1 &&
+		      Field_t_Slot_inst_get (insn) == 0)
+		    return OPCODE_SIMCALL;
 		}
-	      break;
+	      if (Field_r_Slot_inst_get (insn) == 6)
+		return OPCODE_RSIL;
+	      if (Field_r_Slot_inst_get (insn) == 7 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_WAITI;
+	      if (Field_r_Slot_inst_get (insn) == 8)
+		return OPCODE_ANY4;
+	      if (Field_r_Slot_inst_get (insn) == 9)
+		return OPCODE_ALL4;
+	      if (Field_r_Slot_inst_get (insn) == 10)
+		return OPCODE_ANY8;
+	      if (Field_r_Slot_inst_get (insn) == 11)
+		return OPCODE_ALL8;
 	    }
-	  break;
-	case 2:
-	  switch (Field_op2_Slot_inst_get (insn))
+	  if (Field_op2_Slot_inst_get (insn) == 1)
+	    return OPCODE_AND;
+	  if (Field_op2_Slot_inst_get (insn) == 2)
+	    return OPCODE_OR;
+	  if (Field_op2_Slot_inst_get (insn) == 3)
+	    return OPCODE_XOR;
+	  if (Field_op2_Slot_inst_get (insn) == 4)
 	    {
-	    case 0:
-	      return OPCODE_ANDB;
-	    case 1:
-	      return OPCODE_ANDBC;
-	    case 2:
-	      return OPCODE_ORB;
-	    case 3:
-	      return OPCODE_ORBC;
-	    case 4:
-	      return OPCODE_XORB;
-	    case 8:
-	      return OPCODE_MULL;
+	      if (Field_r_Slot_inst_get (insn) == 0 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_SSR;
+	      if (Field_r_Slot_inst_get (insn) == 1 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_SSL;
+	      if (Field_r_Slot_inst_get (insn) == 2 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_SSA8L;
+	      if (Field_r_Slot_inst_get (insn) == 3 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_SSA8B;
+	      if (Field_r_Slot_inst_get (insn) == 4 &&
+		  Field_thi3_Slot_inst_get (insn) == 0)
+		return OPCODE_SSAI;
+	      if (Field_r_Slot_inst_get (insn) == 6)
+		return OPCODE_RER;
+	      if (Field_r_Slot_inst_get (insn) == 7)
+		return OPCODE_WER;
+	      if (Field_r_Slot_inst_get (insn) == 8 &&
+		  Field_s_Slot_inst_get (insn) == 0)
+		return OPCODE_ROTW;
+	      if (Field_r_Slot_inst_get (insn) == 14)
+		return OPCODE_NSA;
+	      if (Field_r_Slot_inst_get (insn) == 15)
+		return OPCODE_NSAU;
 	    }
-	  break;
-	case 3:
-	  switch (Field_op2_Slot_inst_get (insn))
+	  if (Field_op2_Slot_inst_get (insn) == 5)
 	    {
-	    case 0:
-	      switch (Field_sr_Slot_inst_get (insn))
-		{
-		case 0:
-		  return OPCODE_RSR_LBEG;
-		case 1:
-		  return OPCODE_RSR_LEND;
-		case 2:
-		  return OPCODE_RSR_LCOUNT;
-		case 3:
-		  return OPCODE_RSR_SAR;
-		case 4:
-		  return OPCODE_RSR_BR;
-		case 5:
-		  return OPCODE_RSR_LITBASE;
-		case 12:
-		  return OPCODE_RSR_SCOMPARE1;
-		case 72:
-		  return OPCODE_RSR_WINDOWBASE;
-		case 73:
-		  return OPCODE_RSR_WINDOWSTART;
-		case 83:
-		  return OPCODE_RSR_PTEVADDR;
-		case 90:
-		  return OPCODE_RSR_RASID;
-		case 91:
-		  return OPCODE_RSR_ITLBCFG;
-		case 92:
-		  return OPCODE_RSR_DTLBCFG;
-		case 99:
-		  return OPCODE_RSR_ATOMCTL;
-		case 104:
-		  return OPCODE_RSR_DDR;
-		case 176:
-		  return OPCODE_RSR_176;
-		case 177:
-		  return OPCODE_RSR_EPC1;
-		case 178:
-		  return OPCODE_RSR_EPC2;
-		case 192:
-		  return OPCODE_RSR_DEPC;
-		case 194:
-		  return OPCODE_RSR_EPS2;
-		case 208:
-		  return OPCODE_RSR_208;
-		case 209:
-		  return OPCODE_RSR_EXCSAVE1;
-		case 210:
-		  return OPCODE_RSR_EXCSAVE2;
-		case 224:
-		  return OPCODE_RSR_CPENABLE;
-		case 226:
-		  return OPCODE_RSR_INTERRUPT;
-		case 228:
-		  return OPCODE_RSR_INTENABLE;
-		case 230:
-		  return OPCODE_RSR_PS;
-		case 231:
-		  return OPCODE_RSR_VECBASE;
-		case 232:
-		  return OPCODE_RSR_EXCCAUSE;
-		case 233:
-		  return OPCODE_RSR_DEBUGCAUSE;
-		case 234:
-		  return OPCODE_RSR_CCOUNT;
-		case 235:
-		  return OPCODE_RSR_PRID;
-		case 236:
-		  return OPCODE_RSR_ICOUNT;
-		case 237:
-		  return OPCODE_RSR_ICOUNTLEVEL;
-		case 238:
-		  return OPCODE_RSR_EXCVADDR;
-		case 240:
-		  return OPCODE_RSR_CCOMPARE0;
-		case 241:
-		  return OPCODE_RSR_CCOMPARE1;
-		case 244:
-		  return OPCODE_RSR_MISC0;
-		case 245:
-		  return OPCODE_RSR_MISC1;
-		}
-	      break;
-	    case 1:
-	      switch (Field_sr_Slot_inst_get (insn))
-		{
-		case 0:
-		  return OPCODE_WSR_LBEG;
-		case 1:
-		  return OPCODE_WSR_LEND;
-		case 2:
-		  return OPCODE_WSR_LCOUNT;
-		case 3:
-		  return OPCODE_WSR_SAR;
-		case 4:
-		  return OPCODE_WSR_BR;
-		case 5:
-		  return OPCODE_WSR_LITBASE;
-		case 12:
-		  return OPCODE_WSR_SCOMPARE1;
-		case 72:
-		  return OPCODE_WSR_WINDOWBASE;
-		case 73:
-		  return OPCODE_WSR_WINDOWSTART;
-		case 83:
-		  return OPCODE_WSR_PTEVADDR;
-		case 90:
-		  return OPCODE_WSR_RASID;
-		case 91:
-		  return OPCODE_WSR_ITLBCFG;
-		case 92:
-		  return OPCODE_WSR_DTLBCFG;
-		case 99:
-		  return OPCODE_WSR_ATOMCTL;
-		case 104:
-		  return OPCODE_WSR_DDR;
-		case 176:
-		  return OPCODE_WSR_176;
-		case 177:
-		  return OPCODE_WSR_EPC1;
-		case 178:
-		  return OPCODE_WSR_EPC2;
-		case 192:
-		  return OPCODE_WSR_DEPC;
-		case 194:
-		  return OPCODE_WSR_EPS2;
-		case 209:
-		  return OPCODE_WSR_EXCSAVE1;
-		case 210:
-		  return OPCODE_WSR_EXCSAVE2;
-		case 224:
-		  return OPCODE_WSR_CPENABLE;
-		case 226:
-		  return OPCODE_WSR_INTSET;
-		case 227:
-		  return OPCODE_WSR_INTCLEAR;
-		case 228:
-		  return OPCODE_WSR_INTENABLE;
-		case 230:
-		  return OPCODE_WSR_PS;
-		case 231:
-		  return OPCODE_WSR_VECBASE;
-		case 232:
-		  return OPCODE_WSR_EXCCAUSE;
-		case 233:
-		  return OPCODE_WSR_DEBUGCAUSE;
-		case 234:
-		  return OPCODE_WSR_CCOUNT;
-		case 236:
-		  return OPCODE_WSR_ICOUNT;
-		case 237:
-		  return OPCODE_WSR_ICOUNTLEVEL;
-		case 238:
-		  return OPCODE_WSR_EXCVADDR;
-		case 240:
-		  return OPCODE_WSR_CCOMPARE0;
-		case 241:
-		  return OPCODE_WSR_CCOMPARE1;
-		case 244:
-		  return OPCODE_WSR_MISC0;
-		case 245:
-		  return OPCODE_WSR_MISC1;
-		}
-	      break;
-	    case 2:
-	      return OPCODE_SEXT;
-	    case 3:
-	      return OPCODE_CLAMPS;
-	    case 4:
-	      return OPCODE_MIN;
-	    case 5:
-	      return OPCODE_MAX;
-	    case 6:
-	      return OPCODE_MINU;
-	    case 7:
-	      return OPCODE_MAXU;
-	    case 8:
-	      return OPCODE_MOVEQZ;
-	    case 9:
-	      return OPCODE_MOVNEZ;
-	    case 10:
-	      return OPCODE_MOVLTZ;
-	    case 11:
-	      return OPCODE_MOVGEZ;
-	    case 12:
-	      return OPCODE_MOVF;
-	    case 13:
-	      return OPCODE_MOVT;
-	    case 14:
-	      switch (Field_st_Slot_inst_get (insn))
-		{
-		case 231:
-		  return OPCODE_RUR_THREADPTR;
-		case 240:
-		  return OPCODE_RUR_AE_OVF_SAR;
-		case 241:
-		  return OPCODE_RUR_AE_BITHEAD;
-		case 242:
-		  return OPCODE_RUR_AE_TS_FTS_BU_BP;
-		case 243:
-		  return OPCODE_RUR_AE_SD_NO;
-		}
-	      break;
-	    case 15:
-	      switch (Field_sr_Slot_inst_get (insn))
-		{
-		case 231:
-		  return OPCODE_WUR_THREADPTR;
-		case 240:
-		  return OPCODE_WUR_AE_OVF_SAR;
-		case 241:
-		  return OPCODE_WUR_AE_BITHEAD;
-		case 242:
-		  return OPCODE_WUR_AE_TS_FTS_BU_BP;
-		case 243:
-		  return OPCODE_WUR_AE_SD_NO;
-		}
-	      break;
+	      if (Field_r_Slot_inst_get (insn) == 1)
+		return OPCODE_HWWITLBA;
+	      if (Field_r_Slot_inst_get (insn) == 3)
+		return OPCODE_RITLB0;
+	      if (Field_r_Slot_inst_get (insn) == 4 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_IITLB;
+	      if (Field_r_Slot_inst_get (insn) == 5)
+		return OPCODE_PITLB;
+	      if (Field_r_Slot_inst_get (insn) == 6)
+		return OPCODE_WITLB;
+	      if (Field_r_Slot_inst_get (insn) == 7)
+		return OPCODE_RITLB1;
+	      if (Field_r_Slot_inst_get (insn) == 9)
+		return OPCODE_HWWDTLBA;
+	      if (Field_r_Slot_inst_get (insn) == 11)
+		return OPCODE_RDTLB0;
+	      if (Field_r_Slot_inst_get (insn) == 12 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_IDTLB;
+	      if (Field_r_Slot_inst_get (insn) == 13)
+		return OPCODE_PDTLB;
+	      if (Field_r_Slot_inst_get (insn) == 14)
+		return OPCODE_WDTLB;
+	      if (Field_r_Slot_inst_get (insn) == 15)
+		return OPCODE_RDTLB1;
 	    }
-	  break;
-	case 4:
-	case 5:
-	  return OPCODE_EXTUI;
-	case 9:
-	  switch (Field_op2_Slot_inst_get (insn))
+	  if (Field_op2_Slot_inst_get (insn) == 6)
 	    {
-	    case 0:
-	      return OPCODE_L32E;
-	    case 4:
-	      return OPCODE_S32E;
+	      if (Field_s_Slot_inst_get (insn) == 0)
+		return OPCODE_NEG;
+	      if (Field_s_Slot_inst_get (insn) == 1)
+		return OPCODE_ABS;
 	    }
-	  break;
+	  if (Field_op2_Slot_inst_get (insn) == 8)
+	    return OPCODE_ADD;
+	  if (Field_op2_Slot_inst_get (insn) == 9)
+	    return OPCODE_ADDX2;
+	  if (Field_op2_Slot_inst_get (insn) == 10)
+	    return OPCODE_ADDX4;
+	  if (Field_op2_Slot_inst_get (insn) == 11)
+	    return OPCODE_ADDX8;
+	  if (Field_op2_Slot_inst_get (insn) == 12)
+	    return OPCODE_SUB;
+	  if (Field_op2_Slot_inst_get (insn) == 13)
+	    return OPCODE_SUBX2;
+	  if (Field_op2_Slot_inst_get (insn) == 14)
+	    return OPCODE_SUBX4;
+	  if (Field_op2_Slot_inst_get (insn) == 15)
+	    return OPCODE_SUBX8;
 	}
-      break;
-    case 1:
-      return OPCODE_L32R;
-    case 2:
-      switch (Field_r_Slot_inst_get (insn))
+      if (Field_op1_Slot_inst_get (insn) == 1)
 	{
-	case 0:
-	  return OPCODE_L8UI;
-	case 1:
-	  return OPCODE_L16UI;
-	case 2:
-	  return OPCODE_L32I;
-	case 4:
-	  return OPCODE_S8I;
-	case 5:
-	  return OPCODE_S16I;
-	case 6:
-	  return OPCODE_S32I;
-	case 7:
-	  switch (Field_t_Slot_inst_get (insn))
+	  if ((Field_op2_Slot_inst_get (insn) == 0 ||
+	       Field_op2_Slot_inst_get (insn) == 1))
+	    return OPCODE_SLLI;
+	  if ((Field_op2_Slot_inst_get (insn) == 2 ||
+	       Field_op2_Slot_inst_get (insn) == 3))
+	    return OPCODE_SRAI;
+	  if (Field_op2_Slot_inst_get (insn) == 4)
+	    return OPCODE_SRLI;
+	  if (Field_op2_Slot_inst_get (insn) == 6)
 	    {
-	    case 0:
-	      return OPCODE_DPFR;
-	    case 1:
-	      return OPCODE_DPFW;
-	    case 2:
-	      return OPCODE_DPFRO;
-	    case 3:
-	      return OPCODE_DPFWO;
-	    case 4:
-	      return OPCODE_DHWB;
-	    case 5:
-	      return OPCODE_DHWBI;
-	    case 6:
-	      return OPCODE_DHI;
-	    case 7:
-	      return OPCODE_DII;
-	    case 8:
-	      switch (Field_op1_Slot_inst_get (insn))
-		{
-		case 4:
-		  return OPCODE_DIWB;
-		case 5:
-		  return OPCODE_DIWBI;
-		}
-	      break;
-	    case 12:
-	      return OPCODE_IPF;
-	    case 14:
-	      return OPCODE_IHI;
-	    case 15:
-	      return OPCODE_III;
+	      if (Field_sr_Slot_inst_get (insn) == 0)
+		return OPCODE_XSR_LBEG;
+	      if (Field_sr_Slot_inst_get (insn) == 1)
+		return OPCODE_XSR_LEND;
+	      if (Field_sr_Slot_inst_get (insn) == 2)
+		return OPCODE_XSR_LCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 3)
+		return OPCODE_XSR_SAR;
+	      if (Field_sr_Slot_inst_get (insn) == 4)
+		return OPCODE_XSR_BR;
+	      if (Field_sr_Slot_inst_get (insn) == 5)
+		return OPCODE_XSR_LITBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 12)
+		return OPCODE_XSR_SCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 72)
+		return OPCODE_XSR_WINDOWBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 73)
+		return OPCODE_XSR_WINDOWSTART;
+	      if (Field_sr_Slot_inst_get (insn) == 83)
+		return OPCODE_XSR_PTEVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 90)
+		return OPCODE_XSR_RASID;
+	      if (Field_sr_Slot_inst_get (insn) == 91)
+		return OPCODE_XSR_ITLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 92)
+		return OPCODE_XSR_DTLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 99)
+		return OPCODE_XSR_ATOMCTL;
+	      if (Field_sr_Slot_inst_get (insn) == 104)
+		return OPCODE_XSR_DDR;
+	      if (Field_sr_Slot_inst_get (insn) == 177)
+		return OPCODE_XSR_EPC1;
+	      if (Field_sr_Slot_inst_get (insn) == 178)
+		return OPCODE_XSR_EPC2;
+	      if (Field_sr_Slot_inst_get (insn) == 192)
+		return OPCODE_XSR_DEPC;
+	      if (Field_sr_Slot_inst_get (insn) == 194)
+		return OPCODE_XSR_EPS2;
+	      if (Field_sr_Slot_inst_get (insn) == 209)
+		return OPCODE_XSR_EXCSAVE1;
+	      if (Field_sr_Slot_inst_get (insn) == 210)
+		return OPCODE_XSR_EXCSAVE2;
+	      if (Field_sr_Slot_inst_get (insn) == 224)
+		return OPCODE_XSR_CPENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 228)
+		return OPCODE_XSR_INTENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 230)
+		return OPCODE_XSR_PS;
+	      if (Field_sr_Slot_inst_get (insn) == 231)
+		return OPCODE_XSR_VECBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 232)
+		return OPCODE_XSR_EXCCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 233)
+		return OPCODE_XSR_DEBUGCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 234)
+		return OPCODE_XSR_CCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 236)
+		return OPCODE_XSR_ICOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 237)
+		return OPCODE_XSR_ICOUNTLEVEL;
+	      if (Field_sr_Slot_inst_get (insn) == 238)
+		return OPCODE_XSR_EXCVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 240)
+		return OPCODE_XSR_CCOMPARE0;
+	      if (Field_sr_Slot_inst_get (insn) == 241)
+		return OPCODE_XSR_CCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 244)
+		return OPCODE_XSR_MISC0;
+	      if (Field_sr_Slot_inst_get (insn) == 245)
+		return OPCODE_XSR_MISC1;
+	    }
+	  if (Field_op2_Slot_inst_get (insn) == 8)
+	    return OPCODE_SRC;
+	  if (Field_op2_Slot_inst_get (insn) == 9 &&
+	      Field_s_Slot_inst_get (insn) == 0)
+	    return OPCODE_SRL;
+	  if (Field_op2_Slot_inst_get (insn) == 10 &&
+	      Field_t_Slot_inst_get (insn) == 0)
+	    return OPCODE_SLL;
+	  if (Field_op2_Slot_inst_get (insn) == 11 &&
+	      Field_s_Slot_inst_get (insn) == 0)
+	    return OPCODE_SRA;
+	  if (Field_op2_Slot_inst_get (insn) == 12)
+	    return OPCODE_MUL16U;
+	  if (Field_op2_Slot_inst_get (insn) == 13)
+	    return OPCODE_MUL16S;
+	  if (Field_op2_Slot_inst_get (insn) == 15)
+	    {
+	      if (Field_r_Slot_inst_get (insn) == 0)
+		return OPCODE_LICT;
+	      if (Field_r_Slot_inst_get (insn) == 1)
+		return OPCODE_SICT;
+	      if (Field_r_Slot_inst_get (insn) == 2)
+		return OPCODE_LICW;
+	      if (Field_r_Slot_inst_get (insn) == 3)
+		return OPCODE_SICW;
+	      if (Field_r_Slot_inst_get (insn) == 8)
+		return OPCODE_LDCT;
+	      if (Field_r_Slot_inst_get (insn) == 9)
+		return OPCODE_SDCT;
+	      if (Field_r_Slot_inst_get (insn) == 14 &&
+		  Field_t_Slot_inst_get (insn) == 0)
+		return OPCODE_RFDO;
+	      if (Field_r_Slot_inst_get (insn) == 14 &&
+		  Field_t_Slot_inst_get (insn) == 1)
+		return OPCODE_RFDD;
+	      if (Field_r_Slot_inst_get (insn) == 15)
+		return OPCODE_LDPTE;
 	    }
-	  break;
-	case 9:
-	  return OPCODE_L16SI;
-	case 10:
-	  return OPCODE_MOVI;
-	case 11:
-	  return OPCODE_L32AI;
-	case 12:
-	  return OPCODE_ADDI;
-	case 13:
-	  return OPCODE_ADDMI;
-	case 14:
-	  return OPCODE_S32C1I;
-	case 15:
-	  return OPCODE_S32RI;
-	}
-      break;
-    case 4:
-      switch (Field_ae_r10_Slot_inst_get (insn))
-	{
-	case 0:
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ56_I;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ56_X;
-	  break;
-	case 1:
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ32F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ32F_X;
-	  break;
-	case 2:
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ56_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ56_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_CVTQ48A32S;
-	  break;
-	case 3:
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ32F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LQ32F_XU;
-	  break;
-	}
-      switch (Field_ae_r3_Slot_inst_get (insn))
-	{
-	case 0:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 12 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 15 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 6 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 13 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_LP24F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 14 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_LP24X2F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16X2F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16X2F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 8 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16X2F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16X2F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 6 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 12 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24S_L_I;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24S_L_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24S_L_X;
-	  if (Field_op1_Slot_inst_get (insn) == 13 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24S_L_XU;
-	  if (Field_ae_s3_Slot_inst_get (insn) == 0 &&
-	      Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_MOVP48;
-	  if (Field_op1_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_MOVPA24X2;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_CVTA32P24_L;
-	  if (Field_op1_Slot_inst_get (insn) == 14 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_CVTP24A16X2_LL;
-	  if (Field_op1_Slot_inst_get (insn) == 15 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_CVTP24A16X2_HL;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_MOVAP24S_L;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 8 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_TRUNCA16P24S_L;
-	  break;
-	case 1:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24_I;
-	  if (Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 12 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24_X;
-	  if (Field_op1_Slot_inst_get (insn) == 15 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 6 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16X2F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16X2F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 13 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP16X2F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_LP16X2F_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2_I;
-	  if (Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 14 &&
-	      Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LP24X2_X;
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_LP24X2_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2S_I;
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2S_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 8 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2S_X;
-	  if (Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24X2S_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16F_L_I;
-	  if (Field_op1_Slot_inst_get (insn) == 6 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16F_L_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16F_L_X;
-	  if (Field_op1_Slot_inst_get (insn) == 12 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP16F_L_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24F_L_I;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24F_L_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24F_L_X;
-	  if (Field_op1_Slot_inst_get (insn) == 13 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_SP24F_L_XU;
-	  if (Field_op1_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_TRUNCP24A32X2;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 11 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_CVTA32P24_H;
-	  if (Field_op1_Slot_inst_get (insn) == 14 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_CVTP24A16X2_LH;
-	  if (Field_op1_Slot_inst_get (insn) == 15 &&
-	      Field_op2_Slot_inst_get (insn) == 11)
-	    return OPCODE_AE_CVTP24A16X2_HH;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_MOVAP24S_H;
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 8 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_TRUNCA16P24S_H;
-	  break;
-	}
-      switch (Field_ae_r32_Slot_inst_get (insn))
-	{
-	case 0:
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ56S_I;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ56S_X;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_TRUNCA32Q48;
-	  break;
-	case 1:
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ32F_I;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ32F_X;
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_NSAQ56S;
-	  break;
-	case 2:
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ56S_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ56S_XU;
-	  break;
-	case 3:
-	  if (Field_op1_Slot_inst_get (insn) == 3 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ32F_IU;
-	  if (Field_op1_Slot_inst_get (insn) == 4 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SQ32F_XU;
-	  break;
 	}
-      switch (Field_ae_s_non_samt_Slot_inst_get (insn))
+      if (Field_op1_Slot_inst_get (insn) == 2)
 	{
-	case 0:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SLLIQ56;
-	  break;
-	case 1:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SRLIQ56;
-	  break;
-	case 2:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SRAIQ56;
-	  break;
-	case 3:
-	  if (Field_op1_Slot_inst_get (insn) == 5 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SLLISQ56S;
-	  break;
+	  if (Field_op2_Slot_inst_get (insn) == 0)
+	    return OPCODE_ANDB;
+	  if (Field_op2_Slot_inst_get (insn) == 1)
+	    return OPCODE_ANDBC;
+	  if (Field_op2_Slot_inst_get (insn) == 2)
+	    return OPCODE_ORB;
+	  if (Field_op2_Slot_inst_get (insn) == 3)
+	    return OPCODE_ORBC;
+	  if (Field_op2_Slot_inst_get (insn) == 4)
+	    return OPCODE_XORB;
+	  if (Field_op2_Slot_inst_get (insn) == 8)
+	    return OPCODE_MULL;
 	}
-      switch (Field_op1_Slot_inst_get (insn))
+      if (Field_op1_Slot_inst_get (insn) == 3)
 	{
-	case 0:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SHA32;
-	  if (Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_VLDL32T;
-	  break;
-	case 1:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SLLAQ56;
-	  if (Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_VLDL16T;
-	  break;
-	case 2:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SRLAQ56;
-	  if (Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_LBK;
-	  break;
-	case 3:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SRAAQ56;
-	  if (Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_VLEL32T;
-	  break;
-	case 4:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SLLASQ56S;
+	  if (Field_op2_Slot_inst_get (insn) == 0)
+	    {
+	      if (Field_sr_Slot_inst_get (insn) == 0)
+		return OPCODE_RSR_LBEG;
+	      if (Field_sr_Slot_inst_get (insn) == 1)
+		return OPCODE_RSR_LEND;
+	      if (Field_sr_Slot_inst_get (insn) == 2)
+		return OPCODE_RSR_LCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 3)
+		return OPCODE_RSR_SAR;
+	      if (Field_sr_Slot_inst_get (insn) == 4)
+		return OPCODE_RSR_BR;
+	      if (Field_sr_Slot_inst_get (insn) == 5)
+		return OPCODE_RSR_LITBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 12)
+		return OPCODE_RSR_SCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 72)
+		return OPCODE_RSR_WINDOWBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 73)
+		return OPCODE_RSR_WINDOWSTART;
+	      if (Field_sr_Slot_inst_get (insn) == 83)
+		return OPCODE_RSR_PTEVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 90)
+		return OPCODE_RSR_RASID;
+	      if (Field_sr_Slot_inst_get (insn) == 91)
+		return OPCODE_RSR_ITLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 92)
+		return OPCODE_RSR_DTLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 99)
+		return OPCODE_RSR_ATOMCTL;
+	      if (Field_sr_Slot_inst_get (insn) == 104)
+		return OPCODE_RSR_DDR;
+	      if (Field_sr_Slot_inst_get (insn) == 176)
+		return OPCODE_RSR_CONFIGID0;
+	      if (Field_sr_Slot_inst_get (insn) == 177)
+		return OPCODE_RSR_EPC1;
+	      if (Field_sr_Slot_inst_get (insn) == 178)
+		return OPCODE_RSR_EPC2;
+	      if (Field_sr_Slot_inst_get (insn) == 192)
+		return OPCODE_RSR_DEPC;
+	      if (Field_sr_Slot_inst_get (insn) == 194)
+		return OPCODE_RSR_EPS2;
+	      if (Field_sr_Slot_inst_get (insn) == 208)
+		return OPCODE_RSR_CONFIGID1;
+	      if (Field_sr_Slot_inst_get (insn) == 209)
+		return OPCODE_RSR_EXCSAVE1;
+	      if (Field_sr_Slot_inst_get (insn) == 210)
+		return OPCODE_RSR_EXCSAVE2;
+	      if (Field_sr_Slot_inst_get (insn) == 224)
+		return OPCODE_RSR_CPENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 226)
+		return OPCODE_RSR_INTERRUPT;
+	      if (Field_sr_Slot_inst_get (insn) == 228)
+		return OPCODE_RSR_INTENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 230)
+		return OPCODE_RSR_PS;
+	      if (Field_sr_Slot_inst_get (insn) == 231)
+		return OPCODE_RSR_VECBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 232)
+		return OPCODE_RSR_EXCCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 233)
+		return OPCODE_RSR_DEBUGCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 234)
+		return OPCODE_RSR_CCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 235)
+		return OPCODE_RSR_PRID;
+	      if (Field_sr_Slot_inst_get (insn) == 236)
+		return OPCODE_RSR_ICOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 237)
+		return OPCODE_RSR_ICOUNTLEVEL;
+	      if (Field_sr_Slot_inst_get (insn) == 238)
+		return OPCODE_RSR_EXCVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 240)
+		return OPCODE_RSR_CCOMPARE0;
+	      if (Field_sr_Slot_inst_get (insn) == 241)
+		return OPCODE_RSR_CCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 244)
+		return OPCODE_RSR_MISC0;
+	      if (Field_sr_Slot_inst_get (insn) == 245)
+		return OPCODE_RSR_MISC1;
+	    }
+	  if (Field_op2_Slot_inst_get (insn) == 1)
+	    {
+	      if (Field_sr_Slot_inst_get (insn) == 0)
+		return OPCODE_WSR_LBEG;
+	      if (Field_sr_Slot_inst_get (insn) == 1)
+		return OPCODE_WSR_LEND;
+	      if (Field_sr_Slot_inst_get (insn) == 2)
+		return OPCODE_WSR_LCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 3)
+		return OPCODE_WSR_SAR;
+	      if (Field_sr_Slot_inst_get (insn) == 4)
+		return OPCODE_WSR_BR;
+	      if (Field_sr_Slot_inst_get (insn) == 5)
+		return OPCODE_WSR_LITBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 12)
+		return OPCODE_WSR_SCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 72)
+		return OPCODE_WSR_WINDOWBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 73)
+		return OPCODE_WSR_WINDOWSTART;
+	      if (Field_sr_Slot_inst_get (insn) == 83)
+		return OPCODE_WSR_PTEVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 90)
+		return OPCODE_WSR_RASID;
+	      if (Field_sr_Slot_inst_get (insn) == 91)
+		return OPCODE_WSR_ITLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 92)
+		return OPCODE_WSR_DTLBCFG;
+	      if (Field_sr_Slot_inst_get (insn) == 99)
+		return OPCODE_WSR_ATOMCTL;
+	      if (Field_sr_Slot_inst_get (insn) == 104)
+		return OPCODE_WSR_DDR;
+	      if (Field_sr_Slot_inst_get (insn) == 176)
+		return OPCODE_WSR_CONFIGID0;
+	      if (Field_sr_Slot_inst_get (insn) == 177)
+		return OPCODE_WSR_EPC1;
+	      if (Field_sr_Slot_inst_get (insn) == 178)
+		return OPCODE_WSR_EPC2;
+	      if (Field_sr_Slot_inst_get (insn) == 192)
+		return OPCODE_WSR_DEPC;
+	      if (Field_sr_Slot_inst_get (insn) == 194)
+		return OPCODE_WSR_EPS2;
+	      if (Field_sr_Slot_inst_get (insn) == 209)
+		return OPCODE_WSR_EXCSAVE1;
+	      if (Field_sr_Slot_inst_get (insn) == 210)
+		return OPCODE_WSR_EXCSAVE2;
+	      if (Field_sr_Slot_inst_get (insn) == 224)
+		return OPCODE_WSR_CPENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 226)
+		return OPCODE_WSR_INTSET;
+	      if (Field_sr_Slot_inst_get (insn) == 227)
+		return OPCODE_WSR_INTCLEAR;
+	      if (Field_sr_Slot_inst_get (insn) == 228)
+		return OPCODE_WSR_INTENABLE;
+	      if (Field_sr_Slot_inst_get (insn) == 230)
+		return OPCODE_WSR_PS;
+	      if (Field_sr_Slot_inst_get (insn) == 231)
+		return OPCODE_WSR_VECBASE;
+	      if (Field_sr_Slot_inst_get (insn) == 232)
+		return OPCODE_WSR_EXCCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 233)
+		return OPCODE_WSR_DEBUGCAUSE;
+	      if (Field_sr_Slot_inst_get (insn) == 234)
+		return OPCODE_WSR_CCOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 236)
+		return OPCODE_WSR_ICOUNT;
+	      if (Field_sr_Slot_inst_get (insn) == 237)
+		return OPCODE_WSR_ICOUNTLEVEL;
+	      if (Field_sr_Slot_inst_get (insn) == 238)
+		return OPCODE_WSR_EXCVADDR;
+	      if (Field_sr_Slot_inst_get (insn) == 240)
+		return OPCODE_WSR_CCOMPARE0;
+	      if (Field_sr_Slot_inst_get (insn) == 241)
+		return OPCODE_WSR_CCOMPARE1;
+	      if (Field_sr_Slot_inst_get (insn) == 244)
+		return OPCODE_WSR_MISC0;
+	      if (Field_sr_Slot_inst_get (insn) == 245)
+		return OPCODE_WSR_MISC1;
+	    }
+	  if (Field_op2_Slot_inst_get (insn) == 2)
+	    return OPCODE_SEXT;
+	  if (Field_op2_Slot_inst_get (insn) == 3)
+	    return OPCODE_CLAMPS;
+	  if (Field_op2_Slot_inst_get (insn) == 4)
+	    return OPCODE_MIN;
+	  if (Field_op2_Slot_inst_get (insn) == 5)
+	    return OPCODE_MAX;
+	  if (Field_op2_Slot_inst_get (insn) == 6)
+	    return OPCODE_MINU;
+	  if (Field_op2_Slot_inst_get (insn) == 7)
+	    return OPCODE_MAXU;
+	  if (Field_op2_Slot_inst_get (insn) == 8)
+	    return OPCODE_MOVEQZ;
+	  if (Field_op2_Slot_inst_get (insn) == 9)
+	    return OPCODE_MOVNEZ;
 	  if (Field_op2_Slot_inst_get (insn) == 10)
-	    return OPCODE_AE_VLEL16T;
-	  break;
-	case 5:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_MOVTQ56;
-	  break;
-	case 6:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_MOVFQ56;
-	  break;
+	    return OPCODE_MOVLTZ;
+	  if (Field_op2_Slot_inst_get (insn) == 11)
+	    return OPCODE_MOVGEZ;
+	  if (Field_op2_Slot_inst_get (insn) == 12)
+	    return OPCODE_MOVF;
+	  if (Field_op2_Slot_inst_get (insn) == 13)
+	    return OPCODE_MOVT;
+	  if (Field_op2_Slot_inst_get (insn) == 14)
+	    {
+	      if (Field_st_Slot_inst_get (insn) == 231)
+		return OPCODE_RUR_THREADPTR;
+	      if (Field_st_Slot_inst_get (insn) == 240)
+		return OPCODE_RUR_AE_OVF_SAR;
+	      if (Field_st_Slot_inst_get (insn) == 241)
+		return OPCODE_RUR_AE_BITHEAD;
+	      if (Field_st_Slot_inst_get (insn) == 242)
+		return OPCODE_RUR_AE_TS_FTS_BU_BP;
+	      if (Field_st_Slot_inst_get (insn) == 243)
+		return OPCODE_RUR_AE_SD_NO;
+	    }
+	  if (Field_op2_Slot_inst_get (insn) == 15)
+	    {
+	      if (Field_sr_Slot_inst_get (insn) == 231)
+		return OPCODE_WUR_THREADPTR;
+	      if (Field_sr_Slot_inst_get (insn) == 240)
+		return OPCODE_WUR_AE_OVF_SAR;
+	      if (Field_sr_Slot_inst_get (insn) == 241)
+		return OPCODE_WUR_AE_BITHEAD;
+	      if (Field_sr_Slot_inst_get (insn) == 242)
+		return OPCODE_WUR_AE_TS_FTS_BU_BP;
+	      if (Field_sr_Slot_inst_get (insn) == 243)
+		return OPCODE_WUR_AE_SD_NO;
+	    }
 	}
-      switch (Field_r_Slot_inst_get (insn))
+      if ((Field_op1_Slot_inst_get (insn) == 4 ||
+	   Field_op1_Slot_inst_get (insn) == 5))
+	return OPCODE_EXTUI;
+      if (Field_op1_Slot_inst_get (insn) == 9)
 	{
-	case 0:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_OVERFLOW;
-	  if (Field_op2_Slot_inst_get (insn) == 15)
-	    return OPCODE_AE_SBI;
-	  break;
-	case 1:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_SAR;
-	  if (Field_op1_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 15)
-	    return OPCODE_AE_DB;
-	  if (Field_op1_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 15)
-	    return OPCODE_AE_SB;
-	  break;
-	case 2:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_BITPTR;
-	  break;
-	case 3:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_BITSUSED;
-	  break;
-	case 4:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_TABLESIZE;
-	  break;
-	case 5:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_FIRST_TS;
-	  break;
-	case 6:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_NEXTOFFSET;
-	  break;
-	case 7:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_WUR_AE_SEARCHDONE;
-	  break;
-	case 8:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 10 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_VLDSHT;
-	  break;
-	case 12:
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_VLES16C;
-	  break;
-	case 13:
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_SBF;
-	  break;
-	case 14:
-	  if (Field_op1_Slot_inst_get (insn) == 7 &&
-	      Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_VLDL16C;
-	  break;
+	  if (Field_op2_Slot_inst_get (insn) == 0)
+	    return OPCODE_L32E;
+	  if (Field_op2_Slot_inst_get (insn) == 4)
+	    return OPCODE_S32E;
 	}
-      switch (Field_s_Slot_inst_get (insn))
+    }
+  if (Field_op0_Slot_inst_get (insn) == 1)
+    return OPCODE_L32R;
+  if (Field_op0_Slot_inst_get (insn) == 2)
+    {
+      if (Field_r_Slot_inst_get (insn) == 0)
+	return OPCODE_L8UI;
+      if (Field_r_Slot_inst_get (insn) == 1)
+	return OPCODE_L16UI;
+      if (Field_r_Slot_inst_get (insn) == 2)
+	return OPCODE_L32I;
+      if (Field_r_Slot_inst_get (insn) == 4)
+	return OPCODE_S8I;
+      if (Field_r_Slot_inst_get (insn) == 5)
+	return OPCODE_S16I;
+      if (Field_r_Slot_inst_get (insn) == 6)
+	return OPCODE_S32I;
+      if (Field_r_Slot_inst_get (insn) == 7)
 	{
-	case 0:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SLLSQ56;
-	  if (Field_op1_Slot_inst_get (insn) == 6 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_LB;
-	  break;
-	case 1:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SRLSQ56;
-	  break;
-	case 2:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SRASQ56;
-	  break;
-	case 3:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_SLLSSQ56S;
-	  break;
-	case 4:
-	  if (Field_t_Slot_inst_get (insn) == 1 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_AE_MOVQ56;
-	  break;
-	case 8:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_OVERFLOW;
-	  break;
-	case 9:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_SAR;
-	  break;
-	case 10:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_BITPTR;
-	  break;
-	case 11:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_BITSUSED;
-	  break;
-	case 12:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_TABLESIZE;
-	  break;
-	case 13:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_FIRST_TS;
-	  break;
-	case 14:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_NEXTOFFSET;
-	  break;
-	case 15:
-	  if (Field_t_Slot_inst_get (insn) == 0 &&
-	      Field_op1_Slot_inst_get (insn) == 9 &&
-	      Field_op2_Slot_inst_get (insn) == 12)
-	    return OPCODE_RUR_AE_SEARCHDONE;
-	  break;
+	  if (Field_t_Slot_inst_get (insn) == 0)
+	    return OPCODE_DPFR;
+	  if (Field_t_Slot_inst_get (insn) == 1)
+	    return OPCODE_DPFW;
+	  if (Field_t_Slot_inst_get (insn) == 2)
+	    return OPCODE_DPFRO;
+	  if (Field_t_Slot_inst_get (insn) == 3)
+	    return OPCODE_DPFWO;
+	  if (Field_t_Slot_inst_get (insn) == 4)
+	    return OPCODE_DHWB;
+	  if (Field_t_Slot_inst_get (insn) == 5)
+	    return OPCODE_DHWBI;
+	  if (Field_t_Slot_inst_get (insn) == 6)
+	    return OPCODE_DHI;
+	  if (Field_t_Slot_inst_get (insn) == 7)
+	    return OPCODE_DII;
+	  if (Field_t_Slot_inst_get (insn) == 8)
+	    {
+	      if (Field_op1_Slot_inst_get (insn) == 4)
+		return OPCODE_DIWB;
+	      if (Field_op1_Slot_inst_get (insn) == 5)
+		return OPCODE_DIWBI;
+	    }
+	  if (Field_t_Slot_inst_get (insn) == 12)
+	    return OPCODE_IPF;
+	  if (Field_t_Slot_inst_get (insn) == 14)
+	    return OPCODE_IHI;
+	  if (Field_t_Slot_inst_get (insn) == 15)
+	    return OPCODE_III;
 	}
-      switch (Field_t_Slot_inst_get (insn))
+      if (Field_r_Slot_inst_get (insn) == 9)
+	return OPCODE_L16SI;
+      if (Field_r_Slot_inst_get (insn) == 10)
+	return OPCODE_MOVI;
+      if (Field_r_Slot_inst_get (insn) == 11)
+	return OPCODE_L32AI;
+      if (Field_r_Slot_inst_get (insn) == 12)
+	return OPCODE_ADDI;
+      if (Field_r_Slot_inst_get (insn) == 13)
+	return OPCODE_ADDMI;
+      if (Field_r_Slot_inst_get (insn) == 14)
+	return OPCODE_S32C1I;
+      if (Field_r_Slot_inst_get (insn) == 15)
+	return OPCODE_S32RI;
+    }
+  if (Field_op0_Slot_inst_get (insn) == 4)
+    {
+      if (Field_ae_r10_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ56_I;
+      if (Field_ae_r10_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ56_X;
+      if (Field_ae_r10_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ32F_I;
+      if (Field_ae_r10_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ32F_X;
+      if (Field_ae_r10_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ56_IU;
+      if (Field_ae_r10_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ56_XU;
+      if (Field_ae_r10_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_CVTQ48A32S;
+      if (Field_ae_r10_Slot_inst_get (insn) == 3 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ32F_IU;
+      if (Field_ae_r10_Slot_inst_get (insn) == 3 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LQ32F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 12 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 15 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 13 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_LP24F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 14 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_LP24X2F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16X2F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16X2F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 8 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16X2F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16X2F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 12 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24S_L_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24S_L_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24S_L_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 13 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24S_L_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_ae_s3_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_MOVP48;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_MOVPA24X2;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_CVTA32P24_L;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 14 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_CVTP24A16X2_LL;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 15 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_CVTP24A16X2_HL;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_MOVAP24S_L;
+      if (Field_ae_r3_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 8 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_TRUNCA16P24S_L;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 12 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 15 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16X2F_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16X2F_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 13 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP16X2F_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_LP16X2F_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 14 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LP24X2_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_LP24X2_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2S_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2S_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 8 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2S_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24X2S_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16F_L_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16F_L_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16F_L_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 12 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP16F_L_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24F_L_I;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24F_L_IU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24F_L_X;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 13 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_SP24F_L_XU;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_TRUNCP24A32X2;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 11 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_CVTA32P24_H;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 14 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_CVTP24A16X2_LH;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 15 &&
+	  Field_op2_Slot_inst_get (insn) == 11)
+	return OPCODE_AE_CVTP24A16X2_HH;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_MOVAP24S_H;
+      if (Field_ae_r3_Slot_inst_get (insn) == 1 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 8 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_TRUNCA16P24S_H;
+      if (Field_ae_r32_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ56S_I;
+      if (Field_ae_r32_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ56S_X;
+      if (Field_ae_r32_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_TRUNCA32Q48;
+      if (Field_ae_r32_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ32F_I;
+      if (Field_ae_r32_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ32F_X;
+      if (Field_ae_r32_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_NSAQ56S;
+      if (Field_ae_r32_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ56S_IU;
+      if (Field_ae_r32_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ56S_XU;
+      if (Field_ae_r32_Slot_inst_get (insn) == 3 &&
+	  Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ32F_IU;
+      if (Field_ae_r32_Slot_inst_get (insn) == 3 &&
+	  Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SQ32F_XU;
+      if (Field_ae_s_non_samt_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SLLIQ56;
+      if (Field_ae_s_non_samt_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SRLIQ56;
+      if (Field_ae_s_non_samt_Slot_inst_get (insn) == 2 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SRAIQ56;
+      if (Field_ae_s_non_samt_Slot_inst_get (insn) == 3 &&
+	  Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SLLISQ56S;
+      if (Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SHA32;
+      if (Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_VLDL32T;
+      if (Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SLLAQ56;
+      if (Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_VLDL16T;
+      if (Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SRLAQ56;
+      if (Field_op1_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_LBK;
+      if (Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SRAAQ56;
+      if (Field_op1_Slot_inst_get (insn) == 3 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_VLEL32T;
+      if (Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SLLASQ56S;
+      if (Field_op1_Slot_inst_get (insn) == 4 &&
+	  Field_op2_Slot_inst_get (insn) == 10)
+	return OPCODE_AE_VLEL16T;
+      if (Field_op1_Slot_inst_get (insn) == 5 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_MOVTQ56;
+      if (Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_MOVFQ56;
+      if (Field_r_Slot_inst_get (insn) == 0 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_OVERFLOW;
+      if (Field_r_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 15)
+	return OPCODE_AE_SBI;
+      if (Field_r_Slot_inst_get (insn) == 1 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_SAR;
+      if (Field_r_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 15)
+	return OPCODE_AE_DB;
+      if (Field_r_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 15)
+	return OPCODE_AE_SB;
+      if (Field_r_Slot_inst_get (insn) == 2 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_BITPTR;
+      if (Field_r_Slot_inst_get (insn) == 3 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_BITSUSED;
+      if (Field_r_Slot_inst_get (insn) == 4 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_TABLESIZE;
+      if (Field_r_Slot_inst_get (insn) == 5 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_FIRST_TS;
+      if (Field_r_Slot_inst_get (insn) == 6 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_NEXTOFFSET;
+      if (Field_r_Slot_inst_get (insn) == 7 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_WUR_AE_SEARCHDONE;
+      if (Field_r_Slot_inst_get (insn) == 8 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 10 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_VLDSHT;
+      if (Field_r_Slot_inst_get (insn) == 12 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_VLES16C;
+      if (Field_r_Slot_inst_get (insn) == 13 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_SBF;
+      if (Field_r_Slot_inst_get (insn) == 14 &&
+	  Field_op1_Slot_inst_get (insn) == 7 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_VLDL16C;
+      if (Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SLLSQ56;
+      if (Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 6 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_LB;
+      if (Field_s_Slot_inst_get (insn) == 1 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SRLSQ56;
+      if (Field_s_Slot_inst_get (insn) == 2 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SRASQ56;
+      if (Field_s_Slot_inst_get (insn) == 3 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_SLLSSQ56S;
+      if (Field_s_Slot_inst_get (insn) == 4 &&
+	  Field_t_Slot_inst_get (insn) == 1 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_AE_MOVQ56;
+      if (Field_s_Slot_inst_get (insn) == 8 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_OVERFLOW;
+      if (Field_s_Slot_inst_get (insn) == 9 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_SAR;
+      if (Field_s_Slot_inst_get (insn) == 10 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_BITPTR;
+      if (Field_s_Slot_inst_get (insn) == 11 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_BITSUSED;
+      if (Field_s_Slot_inst_get (insn) == 12 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_TABLESIZE;
+      if (Field_s_Slot_inst_get (insn) == 13 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_FIRST_TS;
+      if (Field_s_Slot_inst_get (insn) == 14 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_NEXTOFFSET;
+      if (Field_s_Slot_inst_get (insn) == 15 &&
+	  Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op1_Slot_inst_get (insn) == 9 &&
+	  Field_op2_Slot_inst_get (insn) == 12)
+	return OPCODE_RUR_AE_SEARCHDONE;
+      if (Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_LBKI;
+      if (Field_t_Slot_inst_get (insn) == 0 &&
+	  Field_r_Slot_inst_get (insn) == 2 &&
+	  Field_op2_Slot_inst_get (insn) == 15)
+	return OPCODE_AE_DBI;
+      if (Field_t_Slot_inst_get (insn) == 2 &&
+	  Field_s_Slot_inst_get (insn) == 0 &&
+	  Field_op2_Slot_inst_get (insn) == 14)
+	return OPCODE_AE_LBI;
+    }
+  if (Field_op0_Slot_inst_get (insn) == 5)
+    {
+      if (Field_n_Slot_inst_get (insn) == 0)
+	return OPCODE_CALL0;
+      if (Field_n_Slot_inst_get (insn) == 1)
+	return OPCODE_CALL4;
+      if (Field_n_Slot_inst_get (insn) == 2)
+	return OPCODE_CALL8;
+      if (Field_n_Slot_inst_get (insn) == 3)
+	return OPCODE_CALL12;
+    }
+  if (Field_op0_Slot_inst_get (insn) == 6)
+    {
+      if (Field_n_Slot_inst_get (insn) == 0)
+	return OPCODE_J;
+      if (Field_n_Slot_inst_get (insn) == 1)
 	{
-	case 0:
-	  if (Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_LBKI;
-	  if (Field_r_Slot_inst_get (insn) == 2 &&
-	      Field_op2_Slot_inst_get (insn) == 15)
-	    return OPCODE_AE_DBI;
-	  break;
-	case 2:
-	  if (Field_s_Slot_inst_get (insn) == 0 &&
-	      Field_op2_Slot_inst_get (insn) == 14)
-	    return OPCODE_AE_LBI;
-	  break;
+	  if (Field_m_Slot_inst_get (insn) == 0)
+	    return OPCODE_BEQZ;
+	  if (Field_m_Slot_inst_get (insn) == 1)
+	    return OPCODE_BNEZ;
+	  if (Field_m_Slot_inst_get (insn) == 2)
+	    return OPCODE_BLTZ;
+	  if (Field_m_Slot_inst_get (insn) == 3)
+	    return OPCODE_BGEZ;
 	}
-      break;
-    case 5:
-      switch (Field_n_Slot_inst_get (insn))
+      if (Field_n_Slot_inst_get (insn) == 2)
 	{
-	case 0:
-	  return OPCODE_CALL0;
-	case 1:
-	  return OPCODE_CALL4;
-	case 2:
-	  return OPCODE_CALL8;
-	case 3:
-	  return OPCODE_CALL12;
+	  if (Field_m_Slot_inst_get (insn) == 0)
+	    return OPCODE_BEQI;
+	  if (Field_m_Slot_inst_get (insn) == 1)
+	    return OPCODE_BNEI;
+	  if (Field_m_Slot_inst_get (insn) == 2)
+	    return OPCODE_BLTI;
+	  if (Field_m_Slot_inst_get (insn) == 3)
+	    return OPCODE_BGEI;
 	}
-      break;
-    case 6:
-      switch (Field_n_Slot_inst_get (insn))
+      if (Field_n_Slot_inst_get (insn) == 3)
 	{
-	case 0:
-	  return OPCODE_J;
-	case 1:
-	  switch (Field_m_Slot_inst_get (insn))
-	    {
-	    case 0:
-	      return OPCODE_BEQZ;
-	    case 1:
-	      return OPCODE_BNEZ;
-	    case 2:
-	      return OPCODE_BLTZ;
-	    case 3:
-	      return OPCODE_BGEZ;
-	    }
-	  break;
-	case 2:
-	  switch (Field_m_Slot_inst_get (insn))
-	    {
-	    case 0:
-	      return OPCODE_BEQI;
-	    case 1:
-	      return OPCODE_BNEI;
-	    case 2:
-	      return OPCODE_BLTI;
-	    case 3:
-	      return OPCODE_BGEI;
-	    }
-	  break;
-	case 3:
-	  switch (Field_m_Slot_inst_get (insn))
+	  if (Field_m_Slot_inst_get (insn) == 0)
+	    return OPCODE_ENTRY;
+	  if (Field_m_Slot_inst_get (insn) == 1)
 	    {
-	    case 0:
-	      return OPCODE_ENTRY;
-	    case 1:
-	      switch (Field_r_Slot_inst_get (insn))
-		{
-		case 0:
-		  return OPCODE_BF;
-		case 1:
-		  return OPCODE_BT;
-		case 8:
-		  return OPCODE_LOOP;
-		case 9:
-		  return OPCODE_LOOPNEZ;
-		case 10:
-		  return OPCODE_LOOPGTZ;
-		}
-	      break;
-	    case 2:
-	      return OPCODE_BLTUI;
-	    case 3:
-	      return OPCODE_BGEUI;
+	      if (Field_r_Slot_inst_get (insn) == 0)
+		return OPCODE_BF;
+	      if (Field_r_Slot_inst_get (insn) == 1)
+		return OPCODE_BT;
+	      if (Field_r_Slot_inst_get (insn) == 8)
+		return OPCODE_LOOP;
+	      if (Field_r_Slot_inst_get (insn) == 9)
+		return OPCODE_LOOPNEZ;
+	      if (Field_r_Slot_inst_get (insn) == 10)
+		return OPCODE_LOOPGTZ;
 	    }
-	  break;
+	  if (Field_m_Slot_inst_get (insn) == 2)
+	    return OPCODE_BLTUI;
+	  if (Field_m_Slot_inst_get (insn) == 3)
+	    return OPCODE_BGEUI;
 	}
-      break;
-    case 7:
-      switch (Field_r_Slot_inst_get (insn))
-	{
-	case 0:
-	  return OPCODE_BNONE;
-	case 1:
-	  return OPCODE_BEQ;
-	case 2:
-	  return OPCODE_BLT;
-	case 3:
-	  return OPCODE_BLTU;
-	case 4:
-	  return OPCODE_BALL;
-	case 5:
-	  return OPCODE_BBC;
-	case 6:
-	case 7:
-	  return OPCODE_BBCI;
-	case 8:
-	  return OPCODE_BANY;
-	case 9:
-	  return OPCODE_BNE;
-	case 10:
-	  return OPCODE_BGE;
-	case 11:
-	  return OPCODE_BGEU;
-	case 12:
-	  return OPCODE_BNALL;
-	case 13:
-	  return OPCODE_BBS;
-	case 14:
-	case 15:
-	  return OPCODE_BBSI;
-	}
-      break;
+    }
+  if (Field_op0_Slot_inst_get (insn) == 7)
+    {
+      if (Field_r_Slot_inst_get (insn) == 0)
+	return OPCODE_BNONE;
+      if (Field_r_Slot_inst_get (insn) == 1)
+	return OPCODE_BEQ;
+      if (Field_r_Slot_inst_get (insn) == 2)
+	return OPCODE_BLT;
+      if (Field_r_Slot_inst_get (insn) == 3)
+	return OPCODE_BLTU;
+      if (Field_r_Slot_inst_get (insn) == 4)
+	return OPCODE_BALL;
+      if (Field_r_Slot_inst_get (insn) == 5)
+	return OPCODE_BBC;
+      if ((Field_r_Slot_inst_get (insn) == 6 ||
+	   Field_r_Slot_inst_get (insn) == 7))
+	return OPCODE_BBCI;
+      if (Field_r_Slot_inst_get (insn) == 8)
+	return OPCODE_BANY;
+      if (Field_r_Slot_inst_get (insn) == 9)
+	return OPCODE_BNE;
+      if (Field_r_Slot_inst_get (insn) == 10)
+	return OPCODE_BGE;
+      if (Field_r_Slot_inst_get (insn) == 11)
+	return OPCODE_BGEU;
+      if (Field_r_Slot_inst_get (insn) == 12)
+	return OPCODE_BNALL;
+      if (Field_r_Slot_inst_get (insn) == 13)
+	return OPCODE_BBS;
+      if ((Field_r_Slot_inst_get (insn) == 14 ||
+	   Field_r_Slot_inst_get (insn) == 15))
+	return OPCODE_BBSI;
     }
   return XTENSA_UNDEFINED;
 }
@@ -30824,50 +30653,37 @@ Slot_inst_decode (const xtensa_insnbuf insn)
 static int
 Slot_inst16b_decode (const xtensa_insnbuf insn)
 {
-  switch (Field_op0_Slot_inst16b_get (insn))
+  if (Field_op0_Slot_inst16b_get (insn) == 12)
     {
-    case 12:
-      switch (Field_i_Slot_inst16b_get (insn))
+      if (Field_i_Slot_inst16b_get (insn) == 0)
+	return OPCODE_MOVI_N;
+      if (Field_i_Slot_inst16b_get (insn) == 1)
 	{
-	case 0:
-	  return OPCODE_MOVI_N;
-	case 1:
-	  switch (Field_z_Slot_inst16b_get (insn))
-	    {
-	    case 0:
-	      return OPCODE_BEQZ_N;
-	    case 1:
-	      return OPCODE_BNEZ_N;
-	    }
-	  break;
+	  if (Field_z_Slot_inst16b_get (insn) == 0)
+	    return OPCODE_BEQZ_N;
+	  if (Field_z_Slot_inst16b_get (insn) == 1)
+	    return OPCODE_BNEZ_N;
 	}
-      break;
-    case 13:
-      switch (Field_r_Slot_inst16b_get (insn))
+    }
+  if (Field_op0_Slot_inst16b_get (insn) == 13)
+    {
+      if (Field_r_Slot_inst16b_get (insn) == 0)
+	return OPCODE_MOV_N;
+      if (Field_r_Slot_inst16b_get (insn) == 15)
 	{
-	case 0:
-	  return OPCODE_MOV_N;
-	case 15:
-	  switch (Field_t_Slot_inst16b_get (insn))
-	    {
-	    case 0:
-	      return OPCODE_RET_N;
-	    case 1:
-	      return OPCODE_RETW_N;
-	    case 2:
-	      return OPCODE_BREAK_N;
-	    case 3:
-	      if (Field_s_Slot_inst16b_get (insn) == 0)
-		return OPCODE_NOP_N;
-	      break;
-	    case 6:
-	      if (Field_s_Slot_inst16b_get (insn) == 0)
-		return OPCODE_ILL_N;
-	      break;
-	    }
-	  break;
+	  if (Field_t_Slot_inst16b_get (insn) == 0)
+	    return OPCODE_RET_N;
+	  if (Field_t_Slot_inst16b_get (insn) == 1)
+	    return OPCODE_RETW_N;
+	  if (Field_t_Slot_inst16b_get (insn) == 2)
+	    return OPCODE_BREAK_N;
+	  if (Field_t_Slot_inst16b_get (insn) == 3 &&
+	      Field_s_Slot_inst16b_get (insn) == 0)
+	    return OPCODE_NOP_N;
+	  if (Field_t_Slot_inst16b_get (insn) == 6 &&
+	      Field_s_Slot_inst16b_get (insn) == 0)
+	    return OPCODE_ILL_N;
 	}
-      break;
     }
   return XTENSA_UNDEFINED;
 }
@@ -30875,17 +30691,14 @@ Slot_inst16b_decode (const xtensa_insnbuf insn)
 static int
 Slot_inst16a_decode (const xtensa_insnbuf insn)
 {
-  switch (Field_op0_Slot_inst16a_get (insn))
-    {
-    case 8:
-      return OPCODE_L32I_N;
-    case 9:
-      return OPCODE_S32I_N;
-    case 10:
-      return OPCODE_ADD_N;
-    case 11:
-      return OPCODE_ADDI_N;
-    }
+  if (Field_op0_Slot_inst16a_get (insn) == 8)
+    return OPCODE_L32I_N;
+  if (Field_op0_Slot_inst16a_get (insn) == 9)
+    return OPCODE_S32I_N;
+  if (Field_op0_Slot_inst16a_get (insn) == 10)
+    return OPCODE_ADD_N;
+  if (Field_op0_Slot_inst16a_get (insn) == 11)
+    return OPCODE_ADDI_N;
   return XTENSA_UNDEFINED;
 }
 
@@ -30898,45 +30711,31 @@ Slot_ae_slot0_decode (const xtensa_insnbuf insn)
   if (Field_ftsf213ae_slot0_Slot_ae_slot0_get (insn) == 2 &&
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
     return OPCODE_EXTUI;
-  switch (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn))
-    {
-    case 6:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_BGEZ;
-      break;
-    case 7:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_BLTZ;
-      break;
-    case 8:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_BEQZ;
-      break;
-    case 9:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_BNEZ;
-      break;
-    case 10:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVI;
-      break;
-    }
-  switch (Field_ftsf215ae_slot0_Slot_ae_slot0_get (insn))
-    {
-    case 88:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SRAI;
-      break;
-    case 96:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SLLI;
-      break;
-    case 123:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
-	  Field_ftsf364ae_slot0_Slot_ae_slot0_get (insn) == 0)
-	return OPCODE_AE_MOVTQ56;
-      break;
-    }
+  if (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn) == 6 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_BGEZ;
+  if (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn) == 7 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_BLTZ;
+  if (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn) == 8 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_BEQZ;
+  if (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn) == 9 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_BNEZ;
+  if (Field_ftsf214ae_slot0_Slot_ae_slot0_get (insn) == 10 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVI;
+  if (Field_ftsf215ae_slot0_Slot_ae_slot0_get (insn) == 88 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SRAI;
+  if (Field_ftsf215ae_slot0_Slot_ae_slot0_get (insn) == 96 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SLLI;
+  if (Field_ftsf215ae_slot0_Slot_ae_slot0_get (insn) == 123 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
+      Field_ftsf364ae_slot0_Slot_ae_slot0_get (insn) == 0)
+    return OPCODE_AE_MOVTQ56;
   if (Field_ftsf216ae_slot0_Slot_ae_slot0_get (insn) == 418 &&
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
     return OPCODE_AE_CVTP24A16X2_HH;
@@ -31160,17 +30959,12 @@ Slot_ae_slot0_decode (const xtensa_insnbuf insn)
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
       Field_s_Slot_ae_slot0_get (insn) == 0)
     return OPCODE_ALL8;
-  switch (Field_ftsf293_Slot_ae_slot0_get (insn))
-    {
-    case 0:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BBCI;
-      break;
-    case 1:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BBSI;
-      break;
-    }
+  if (Field_ftsf293_Slot_ae_slot0_get (insn) == 0 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BBCI;
+  if (Field_ftsf293_Slot_ae_slot0_get (insn) == 1 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BBSI;
   if (Field_ftsf294ae_slot0_Slot_ae_slot0_get (insn) == 1915 &&
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
       Field_s_Slot_ae_slot0_get (insn) == 0)
@@ -31188,57 +30982,38 @@ Slot_ae_slot0_decode (const xtensa_insnbuf insn)
   if (Field_ftsf298ae_slot0_Slot_ae_slot0_get (insn) == 963 &&
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
     return OPCODE_AE_SQ56S_IU;
-  switch (Field_ftsf299ae_slot0_Slot_ae_slot0_get (insn))
-    {
-    case 964:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_AE_SLLIQ56;
-      break;
-    case 965:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_AE_SRAIQ56;
-      break;
-    case 966:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_AE_SRLIQ56;
-      break;
-    case 968:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_AE_SLLISQ56S;
-      break;
-    }
-  switch (Field_ftsf300ae_slot0_Slot_ae_slot0_get (insn))
-    {
-    case 3868:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ABS;
-      break;
-    case 3869:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_NEG;
-      break;
-    case 3870:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SRA;
-      break;
-    case 3871:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SRL;
-      break;
-    }
-  switch (Field_ftsf301ae_slot0_Slot_ae_slot0_get (insn))
-    {
-    case 7752:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
-	  Field_ftsf321_Slot_ae_slot0_get (insn) == 0)
-	return OPCODE_AE_MOVP48;
-      break;
-    case 7753:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
-	  Field_ftsf353_Slot_ae_slot0_get (insn) == 0)
-	return OPCODE_ANY4;
-      break;
-    }
+  if (Field_ftsf299ae_slot0_Slot_ae_slot0_get (insn) == 964 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_AE_SLLIQ56;
+  if (Field_ftsf299ae_slot0_Slot_ae_slot0_get (insn) == 965 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_AE_SRAIQ56;
+  if (Field_ftsf299ae_slot0_Slot_ae_slot0_get (insn) == 966 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_AE_SRLIQ56;
+  if (Field_ftsf299ae_slot0_Slot_ae_slot0_get (insn) == 968 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_AE_SLLISQ56S;
+  if (Field_ftsf300ae_slot0_Slot_ae_slot0_get (insn) == 3868 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ABS;
+  if (Field_ftsf300ae_slot0_Slot_ae_slot0_get (insn) == 3869 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_NEG;
+  if (Field_ftsf300ae_slot0_Slot_ae_slot0_get (insn) == 3870 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SRA;
+  if (Field_ftsf300ae_slot0_Slot_ae_slot0_get (insn) == 3871 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SRL;
+  if (Field_ftsf301ae_slot0_Slot_ae_slot0_get (insn) == 7752 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
+      Field_ftsf321_Slot_ae_slot0_get (insn) == 0)
+    return OPCODE_AE_MOVP48;
+  if (Field_ftsf301ae_slot0_Slot_ae_slot0_get (insn) == 7753 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
+      Field_ftsf353_Slot_ae_slot0_get (insn) == 0)
+    return OPCODE_ANY4;
   if (Field_ftsf302ae_slot0_Slot_ae_slot0_get (insn) == 31016 &&
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
       Field_ftsf321_Slot_ae_slot0_get (insn) == 0)
@@ -31328,239 +31103,181 @@ Slot_ae_slot0_decode (const xtensa_insnbuf insn)
       Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
       Field_ftsf362ae_slot0_Slot_ae_slot0_get (insn) == 0)
     return OPCODE_AE_SQ32F_XU;
-  switch (Field_imm8_Slot_ae_slot0_get (insn))
-    {
-    case 178:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ADD;
-      break;
-    case 179:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ADDX8;
-      break;
-    case 180:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ADDX2;
-      break;
-    case 181:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_AND;
-      break;
-    case 182:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ANDB;
-      break;
-    case 183:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ANDBC;
-      break;
-    case 184:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ADDX4;
-      break;
-    case 185:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_CLAMPS;
-      break;
-    case 186:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MAX;
-      break;
-    case 187:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MIN;
-      break;
-    case 188:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MAXU;
-      break;
-    case 189:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MINU;
-      break;
-    case 190:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVEQZ;
-      break;
-    case 191:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVF;
-      break;
-    case 194:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVGEZ;
-      break;
-    case 195:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ORB;
-      break;
-    case 196:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVLTZ;
-      break;
-    case 197:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_ORBC;
-      break;
-    case 198:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SEXT;
-      break;
-    case 199:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SRC;
-      break;
-    case 200:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVNEZ;
-      break;
-    case 201:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SRLI;
-      break;
-    case 202:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SUB;
-      break;
-    case 203:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SUBX4;
-      break;
-    case 204:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SUBX2;
-      break;
-    case 205:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_SUBX8;
-      break;
-    case 206:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_XOR;
-      break;
-    case 207:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_XORB;
-      break;
-    case 208:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_MOVT;
-      break;
-    case 224:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
-	return OPCODE_OR;
-      break;
-    case 244:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
-	  Field_ae_r32_Slot_ae_slot0_get (insn) == 0)
-	return OPCODE_AE_SQ32F_X;
-      break;
-    }
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 178 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ADD;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 179 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ADDX8;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 180 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ADDX2;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 181 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_AND;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 182 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ANDB;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 183 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ANDBC;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 184 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ADDX4;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 185 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_CLAMPS;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 186 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MAX;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 187 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MIN;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 188 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MAXU;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 189 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MINU;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 190 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVEQZ;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 191 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVF;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 194 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVGEZ;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 195 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ORB;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 196 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVLTZ;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 197 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_ORBC;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 198 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SEXT;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 199 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SRC;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 200 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVNEZ;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 201 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SRLI;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 202 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SUB;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 203 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SUBX4;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 204 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SUBX2;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 205 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_SUBX8;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 206 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_XOR;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 207 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_XORB;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 208 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_MOVT;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 224 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1)
+    return OPCODE_OR;
+  if (Field_imm8_Slot_ae_slot0_get (insn) == 244 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 1 &&
+      Field_ae_r32_Slot_ae_slot0_get (insn) == 0)
+    return OPCODE_AE_SQ32F_X;
   if (Field_op0_s4_Slot_ae_slot0_get (insn) == 5)
     return OPCODE_L32R;
-  switch (Field_r_Slot_ae_slot0_get (insn))
-    {
-    case 0:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_BNE;
-      break;
-    case 1:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_BNONE;
-      break;
-    case 2:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_L16SI;
-      break;
-    case 3:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_L8UI;
-      break;
-    case 4:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_ADDI;
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_L16UI;
-      break;
-    case 5:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BALL;
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_S16I;
-      break;
-    case 6:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BANY;
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_S32I;
-      break;
-    case 7:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BBC;
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
-	return OPCODE_S8I;
-      break;
-    case 8:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_ADDMI;
-      break;
-    case 9:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BBS;
-      break;
-    case 10:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BEQ;
-      break;
-    case 11:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BGEU;
-      break;
-    case 12:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BGE;
-      break;
-    case 13:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BLT;
-      break;
-    case 14:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BLTU;
-      break;
-    case 15:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
-	return OPCODE_BNALL;
-      break;
-    }
-  switch (Field_t_Slot_ae_slot0_get (insn))
-    {
-    case 0:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
-	return OPCODE_BEQI;
-      break;
-    case 1:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
-	return OPCODE_BGEI;
-      break;
-    case 2:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
-	return OPCODE_BGEUI;
-      break;
-    case 3:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
-	return OPCODE_BNEI;
-      break;
-    case 4:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
-	return OPCODE_BLTI;
-      break;
-    case 5:
-      if (Field_op0_s4_Slot_ae_slot0_get (insn) == 3 &&
-	  Field_r_Slot_ae_slot0_get (insn) == 0)
-	return OPCODE_BF;
-      break;
-    }
+  if (Field_r_Slot_ae_slot0_get (insn) == 0 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_BNE;
+  if (Field_r_Slot_ae_slot0_get (insn) == 1 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_BNONE;
+  if (Field_r_Slot_ae_slot0_get (insn) == 2 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_L16SI;
+  if (Field_r_Slot_ae_slot0_get (insn) == 3 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_L8UI;
+  if (Field_r_Slot_ae_slot0_get (insn) == 4 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_ADDI;
+  if (Field_r_Slot_ae_slot0_get (insn) == 4 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_L16UI;
+  if (Field_r_Slot_ae_slot0_get (insn) == 5 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BALL;
+  if (Field_r_Slot_ae_slot0_get (insn) == 5 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_S16I;
+  if (Field_r_Slot_ae_slot0_get (insn) == 6 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BANY;
+  if (Field_r_Slot_ae_slot0_get (insn) == 6 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_S32I;
+  if (Field_r_Slot_ae_slot0_get (insn) == 7 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BBC;
+  if (Field_r_Slot_ae_slot0_get (insn) == 7 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 4)
+    return OPCODE_S8I;
+  if (Field_r_Slot_ae_slot0_get (insn) == 8 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_ADDMI;
+  if (Field_r_Slot_ae_slot0_get (insn) == 9 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BBS;
+  if (Field_r_Slot_ae_slot0_get (insn) == 10 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BEQ;
+  if (Field_r_Slot_ae_slot0_get (insn) == 11 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BGEU;
+  if (Field_r_Slot_ae_slot0_get (insn) == 12 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BGE;
+  if (Field_r_Slot_ae_slot0_get (insn) == 13 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BLT;
+  if (Field_r_Slot_ae_slot0_get (insn) == 14 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BLTU;
+  if (Field_r_Slot_ae_slot0_get (insn) == 15 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 2)
+    return OPCODE_BNALL;
+  if (Field_t_Slot_ae_slot0_get (insn) == 0 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
+    return OPCODE_BEQI;
+  if (Field_t_Slot_ae_slot0_get (insn) == 1 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
+    return OPCODE_BGEI;
+  if (Field_t_Slot_ae_slot0_get (insn) == 2 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
+    return OPCODE_BGEUI;
+  if (Field_t_Slot_ae_slot0_get (insn) == 3 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
+    return OPCODE_BNEI;
+  if (Field_t_Slot_ae_slot0_get (insn) == 4 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3)
+    return OPCODE_BLTI;
+  if (Field_t_Slot_ae_slot0_get (insn) == 5 &&
+      Field_op0_s4_Slot_ae_slot0_get (insn) == 3 &&
+      Field_r_Slot_ae_slot0_get (insn) == 0)
+    return OPCODE_BF;
   return XTENSA_UNDEFINED;
 }
 
@@ -31958,21 +31675,15 @@ Slot_ae_slot1_decode (const xtensa_insnbuf insn)
   if (Field_ftsf36ae_slot1_Slot_ae_slot1_get (insn) == 31 &&
       Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
     return OPCODE_AE_SUBP24;
-  switch (Field_ftsf37ae_slot1_Slot_ae_slot1_get (insn))
-    {
-    case 8:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
-	return OPCODE_AE_SLLIP24;
-      break;
-    case 9:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
-	return OPCODE_AE_SRAIP24;
-      break;
-    case 10:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
-	return OPCODE_AE_SRLIP24;
-      break;
-    }
+  if (Field_ftsf37ae_slot1_Slot_ae_slot1_get (insn) == 8 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
+    return OPCODE_AE_SLLIP24;
+  if (Field_ftsf37ae_slot1_Slot_ae_slot1_get (insn) == 9 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
+    return OPCODE_AE_SRAIP24;
+  if (Field_ftsf37ae_slot1_Slot_ae_slot1_get (insn) == 10 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
+    return OPCODE_AE_SRLIP24;
   if (Field_ftsf38ae_slot1_Slot_ae_slot1_get (insn) == 176 &&
       Field_op0_s3_Slot_ae_slot1_get (insn) == 1)
     return OPCODE_AE_MULAFQ32SP16S_L;
@@ -32148,137 +31859,150 @@ Slot_ae_slot1_decode (const xtensa_insnbuf insn)
       Field_op0_s3_Slot_ae_slot1_get (insn) == 1 &&
       Field_ae_r20_Slot_ae_slot1_get (insn) == 0)
     return OPCODE_AE_ABSP24;
-  switch (Field_t_Slot_ae_slot1_get (insn))
-    {
-    case 0:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASFQ32SP16U_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSAQ32SP16S_LL;
-      break;
-    case 1:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASFQ32SP16U_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSAQ32SP16U_HH;
-      break;
-    case 2:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16S_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSAQ32SP16U_LH;
-      break;
-    case 3:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16U_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16U_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16S_LH;
-      break;
-    case 4:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16U_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSAQ32SP16U_LL;
-      break;
-    case 5:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16U_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16S_LL;
-      break;
-    case 6:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16U_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16U_HH;
-      break;
-    case 7:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16S_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16U_LH;
-      break;
-    case 8:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAFQ32SP16U_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZASQ32SP16S_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16S_HH;
-      break;
-    case 9:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16U_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSFQ32SP16U_LL;
-      break;
-    case 10:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16U_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16S_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16S_HH;
-      break;
-    case 11:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZASFQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16U_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16S_LL;
-      break;
-    case 12:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZAAQ32SP16U_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16U_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16S_LH;
-      break;
-    case 13:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZASFQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAFQ32SP16U_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16U_HH;
-      break;
-    case 14:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZASFQ32SP16S_LL;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAQ32SP16S_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16U_LH;
-      break;
-    case 15:
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
-	return OPCODE_AE_MULZASFQ32SP16U_HH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
-	return OPCODE_AE_MULZSAQ32SP16S_LH;
-      if (Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
-	return OPCODE_AE_MULZSSQ32SP16U_LL;
-      break;
-    }
+  if (Field_t_Slot_ae_slot1_get (insn) == 0 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 0 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASFQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 0 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSAQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 1 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 1 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASFQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 1 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSAQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 2 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 2 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 2 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSAQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 3 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 3 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 3 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 4 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 4 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 4 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSAQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 5 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 5 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 5 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 6 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 6 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 6 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 7 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 7 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 7 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 8 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAFQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 8 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZASQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 8 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 9 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 9 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 9 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSFQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 10 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 10 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 10 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 11 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZASFQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 11 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 11 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 12 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZAAQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 12 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 12 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 13 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZASFQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 13 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAFQ32SP16U_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 13 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 14 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZASFQ32SP16S_LL;
+  if (Field_t_Slot_ae_slot1_get (insn) == 14 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAQ32SP16S_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 14 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16U_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 15 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 2)
+    return OPCODE_AE_MULZASFQ32SP16U_HH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 15 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 3)
+    return OPCODE_AE_MULZSAQ32SP16S_LH;
+  if (Field_t_Slot_ae_slot1_get (insn) == 15 &&
+      Field_op0_s3_Slot_ae_slot1_get (insn) == 4)
+    return OPCODE_AE_MULZSSQ32SP16U_LL;
   return XTENSA_UNDEFINED;
 }
 
@@ -32418,6 +32142,8 @@ Slot_inst_get_field_fns[] = {
   Field_ae_r20_Slot_inst_get,
   Field_ae_r10_Slot_inst_get,
   Field_ae_s20_Slot_inst_get,
+  Field_ae_fld_ohba_Slot_inst_get,
+  Field_ae_fld_ohba2_Slot_inst_get,
   0,
   Field_ftsf12_Slot_inst_get,
   Field_ftsf13_Slot_inst_get,
@@ -32809,6 +32535,8 @@ Slot_inst_set_field_fns[] = {
   Field_ae_r20_Slot_inst_set,
   Field_ae_r10_Slot_inst_set,
   Field_ae_s20_Slot_inst_set,
+  Field_ae_fld_ohba_Slot_inst_set,
+  Field_ae_fld_ohba2_Slot_inst_set,
   0,
   Field_ftsf12_Slot_inst_set,
   Field_ftsf13_Slot_inst_set,
@@ -33525,6 +33253,8 @@ Slot_inst16a_get_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Implicit_Field_ar0_get,
   Implicit_Field_ar4_get,
   Implicit_Field_ar8_get,
@@ -33916,6 +33646,8 @@ Slot_inst16a_set_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Implicit_Field_set,
   Implicit_Field_set,
   Implicit_Field_set,
@@ -34307,6 +34039,8 @@ Slot_inst16b_get_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Implicit_Field_ar0_get,
   Implicit_Field_ar4_get,
   Implicit_Field_ar8_get,
@@ -34698,6 +34432,8 @@ Slot_inst16b_set_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Implicit_Field_set,
   Implicit_Field_set,
   Implicit_Field_set,
@@ -34764,6 +34500,8 @@ Slot_ae_slot1_get_field_fns[] = {
   Field_ae_r20_Slot_ae_slot1_get,
   Field_ae_r10_Slot_ae_slot1_get,
   Field_ae_s20_Slot_ae_slot1_get,
+  0,
+  0,
   Field_op0_s3_Slot_ae_slot1_get,
   Field_ftsf12_Slot_ae_slot1_get,
   Field_ftsf13_Slot_ae_slot1_get,
@@ -35155,6 +34893,8 @@ Slot_ae_slot1_set_field_fns[] = {
   Field_ae_r20_Slot_ae_slot1_set,
   Field_ae_r10_Slot_ae_slot1_set,
   Field_ae_s20_Slot_ae_slot1_set,
+  0,
+  0,
   Field_op0_s3_Slot_ae_slot1_set,
   Field_ftsf12_Slot_ae_slot1_set,
   Field_ftsf13_Slot_ae_slot1_set,
@@ -35745,6 +35485,8 @@ Slot_ae_slot0_get_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Field_op0_s4_Slot_ae_slot0_get,
   Field_ftsf212ae_slot0_Slot_ae_slot0_get,
   Field_ftsf213ae_slot0_Slot_ae_slot0_get,
@@ -36136,6 +35878,8 @@ Slot_ae_slot0_set_field_fns[] = {
   0,
   0,
   0,
+  0,
+  0,
   Field_op0_s4_Slot_ae_slot0_set,
   Field_ftsf212ae_slot0_Slot_ae_slot0_set,
   Field_ftsf213ae_slot0_Slot_ae_slot0_set,
@@ -36356,7 +36100,247 @@ format_decoder (const xtensa_insnbuf insn)
   return -1;
 }
 
-static int length_table[16] = {
+static int length_table[256] = {
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  3,
+  2,
+  2,
+  2,
+  2,
+  2,
+  2,
+  -1,
+  8,
   3,
   3,
   3,
@@ -36378,8 +36362,8 @@ static int length_table[16] = {
 static int
 length_decoder (const unsigned char *insn)
 {
-  int op0 = insn[0] & 0xf;
-  return length_table[op0];
+  int l = insn[0];
+  return length_table[l];
 }
 
 
@@ -36390,8 +36374,8 @@ xtensa_isa_internal xtensa_modules = {
   8 /* insn_size */, 0,
   4, formats, format_decoder, length_decoder,
   5, slots,
-  387 /* num_fields */,
-  445, operands,
+  389 /* num_fields */,
+  454, operands,
   588, iclasses,
   656, opcodes, 0,
   8, regfiles,
diff --git a/tests/acceptance/pc_cpu_hotplug_props.py b/tests/acceptance/pc_cpu_hotplug_props.py
new file mode 100644
index 0000000000..08b7e632c6
--- /dev/null
+++ b/tests/acceptance/pc_cpu_hotplug_props.py
@@ -0,0 +1,35 @@
+#
+# Ensure CPU die-id can be omitted on -device
+#
+#  Copyright (c) 2019 Red Hat Inc
+#
+# Author:
+#  Eduardo Habkost <ehabkost@redhat.com>
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, see <http://www.gnu.org/licenses/>.
+#
+
+from avocado_qemu import Test
+
+class OmittedCPUProps(Test):
+    """
+    :avocado: tags=arch:x86_64
+    """
+    def test_no_die_id(self):
+        self.vm.add_args('-nodefaults', '-S')
+        self.vm.add_args('-smp', '1,sockets=2,cores=2,threads=2,maxcpus=8')
+        self.vm.add_args('-cpu', 'qemu64')
+        self.vm.add_args('-device', 'qemu64-x86_64-cpu,socket-id=1,core-id=0,thread-id=0')
+        self.vm.launch()
+        self.assertEquals(len(self.vm.command('query-cpus')), 2)
diff --git a/tests/qemu-iotests/030 b/tests/qemu-iotests/030
index 1b69f318c6..f3766f2a81 100755
--- a/tests/qemu-iotests/030
+++ b/tests/qemu-iotests/030
@@ -957,4 +957,5 @@ class TestSetSpeed(iotests.QMPTestCase):
         self.cancel_and_wait(resume=True)
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2', 'qed'])
+    iotests.main(supported_fmts=['qcow2', 'qed'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/040 b/tests/qemu-iotests/040
index aa0b1847e3..f9e603e715 100755
--- a/tests/qemu-iotests/040
+++ b/tests/qemu-iotests/040
@@ -433,4 +433,5 @@ class TestReopenOverlay(ImageCommitTestCase):
         self.run_commit_test(self.img1, self.img0)
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2', 'qed'])
+    iotests.main(supported_fmts=['qcow2', 'qed'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/041 b/tests/qemu-iotests/041
index 26bf1701eb..ae6ed952c6 100755
--- a/tests/qemu-iotests/041
+++ b/tests/qemu-iotests/041
@@ -1068,4 +1068,5 @@ class TestOrphanedSource(iotests.QMPTestCase):
         self.assert_qmp(result, 'error/class', 'GenericError')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2', 'qed'])
+    iotests.main(supported_fmts=['qcow2', 'qed'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/044 b/tests/qemu-iotests/044
index 9ec3dba734..05ea1f49c5 100755
--- a/tests/qemu-iotests/044
+++ b/tests/qemu-iotests/044
@@ -118,4 +118,5 @@ class TestRefcountTableGrowth(iotests.QMPTestCase):
         pass
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/045 b/tests/qemu-iotests/045
index d5484a0ee1..01cc038884 100755
--- a/tests/qemu-iotests/045
+++ b/tests/qemu-iotests/045
@@ -175,4 +175,5 @@ class TestSCMFd(iotests.QMPTestCase):
             "File descriptor named '%s' not found" % fdname)
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['raw'])
+    iotests.main(supported_fmts=['raw'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/055 b/tests/qemu-iotests/055
index 3437c11507..c732a112d6 100755
--- a/tests/qemu-iotests/055
+++ b/tests/qemu-iotests/055
@@ -563,4 +563,5 @@ class TestDriveCompression(iotests.QMPTestCase):
                                         target='drive1')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['raw', 'qcow2'])
+    iotests.main(supported_fmts=['raw', 'qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/056 b/tests/qemu-iotests/056
index e761e465ae..98c55d8e5a 100755
--- a/tests/qemu-iotests/056
+++ b/tests/qemu-iotests/056
@@ -335,4 +335,5 @@ class BackupTest(iotests.QMPTestCase):
         self.dismissal_failure(True)
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2', 'qed'])
+    iotests.main(supported_fmts=['qcow2', 'qed'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/057 b/tests/qemu-iotests/057
index 9f0a5a3057..9fbba759b6 100755
--- a/tests/qemu-iotests/057
+++ b/tests/qemu-iotests/057
@@ -256,4 +256,5 @@ class TestSnapshotDelete(ImageSnapshotTestCase):
         self.assert_qmp(result, 'error/class', 'GenericError')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/059.out b/tests/qemu-iotests/059.out
index 4fab42a28c..fe3f861f3c 100644
--- a/tests/qemu-iotests/059.out
+++ b/tests/qemu-iotests/059.out
@@ -27,7 +27,7 @@ Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1073741824000 subformat=twoGbMax
 image: TEST_DIR/t.vmdk
 file format: vmdk
 virtual size: 0.977 TiB (1073741824000 bytes)
-disk size: 16 KiB
+disk size: 1.97 MiB
 Format specific information:
     cid: XXXXXXXX
     parent cid: XXXXXXXX
diff --git a/tests/qemu-iotests/065 b/tests/qemu-iotests/065
index 8bac383ea7..5b21eb96bd 100755
--- a/tests/qemu-iotests/065
+++ b/tests/qemu-iotests/065
@@ -129,4 +129,5 @@ TestQemuImgInfo = None
 TestQMP = None
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/096 b/tests/qemu-iotests/096
index a69439602d..ab9cb47822 100755
--- a/tests/qemu-iotests/096
+++ b/tests/qemu-iotests/096
@@ -67,4 +67,5 @@ class TestLiveSnapshot(iotests.QMPTestCase):
         self.checkConfig('target')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/118 b/tests/qemu-iotests/118
index 499c5f0901..c7d8af1a85 100755
--- a/tests/qemu-iotests/118
+++ b/tests/qemu-iotests/118
@@ -707,4 +707,5 @@ if __name__ == '__main__':
                        iotests.qemu_default_machine)
     # Need to support image creation
     iotests.main(supported_fmts=['vpc', 'parallels', 'qcow', 'vdi', 'qcow2',
-                                 'vmdk', 'raw', 'vhdx', 'qed'])
+                                 'vmdk', 'raw', 'vhdx', 'qed'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/124 b/tests/qemu-iotests/124
index 3440f54781..ca40ba3be2 100755
--- a/tests/qemu-iotests/124
+++ b/tests/qemu-iotests/124
@@ -779,4 +779,5 @@ class TestIncrementalBackupBlkdebug(TestIncrementalBackupBase):
 
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/129 b/tests/qemu-iotests/129
index 9e87e1c8d9..cd6b9e9ce7 100755
--- a/tests/qemu-iotests/129
+++ b/tests/qemu-iotests/129
@@ -83,4 +83,5 @@ class TestStopWithBlockJob(iotests.QMPTestCase):
         self.do_test_stop("block-commit", device="drive0")
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=["qcow2"])
+    iotests.main(supported_fmts=["qcow2"],
+                 supported_protocols=["file"])
diff --git a/tests/qemu-iotests/132 b/tests/qemu-iotests/132
index f53ef6e391..0f2a106c81 100755
--- a/tests/qemu-iotests/132
+++ b/tests/qemu-iotests/132
@@ -56,4 +56,5 @@ class TestSingleDrive(iotests.QMPTestCase):
                         'target image does not match source after mirroring')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['raw', 'qcow2'])
+    iotests.main(supported_fmts=['raw', 'qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/139 b/tests/qemu-iotests/139
index 933b45121a..8dc839ec7e 100755
--- a/tests/qemu-iotests/139
+++ b/tests/qemu-iotests/139
@@ -361,4 +361,5 @@ class TestBlockdevDel(iotests.QMPTestCase):
 
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=["qcow2"])
+    iotests.main(supported_fmts=["qcow2"],
+                 supported_protocols=["file"])
diff --git a/tests/qemu-iotests/147 b/tests/qemu-iotests/147
index 2d84fddb01..ab8480b9a4 100755
--- a/tests/qemu-iotests/147
+++ b/tests/qemu-iotests/147
@@ -287,6 +287,5 @@ class BuiltinNBD(NBDBlockdevAddBase):
 
 
 if __name__ == '__main__':
-    # Need to support image creation
-    iotests.main(supported_fmts=['vpc', 'parallels', 'qcow', 'vdi', 'qcow2',
-                                 'vmdk', 'raw', 'vhdx', 'qed'])
+    iotests.main(supported_fmts=['raw'],
+                 supported_protocols=['nbd'])
diff --git a/tests/qemu-iotests/148 b/tests/qemu-iotests/148
index e01b061fe7..8c11c53cba 100755
--- a/tests/qemu-iotests/148
+++ b/tests/qemu-iotests/148
@@ -137,4 +137,5 @@ class TestFifoQuorumEvents(TestQuorumEvents):
 
 if __name__ == '__main__':
     iotests.verify_quorum()
-    iotests.main(supported_fmts=["raw"])
+    iotests.main(supported_fmts=["raw"],
+                 supported_protocols=["file"])
diff --git a/tests/qemu-iotests/150.out b/tests/qemu-iotests/150.out.qcow2
similarity index 100%
rename from tests/qemu-iotests/150.out
rename to tests/qemu-iotests/150.out.qcow2
diff --git a/tests/qemu-iotests/150.out.raw b/tests/qemu-iotests/150.out.raw
new file mode 100644
index 0000000000..3cdc7727a5
--- /dev/null
+++ b/tests/qemu-iotests/150.out.raw
@@ -0,0 +1,12 @@
+QA output created by 150
+
+=== Mapping sparse conversion ===
+
+Offset          Length          File
+0               0x1000          TEST_DIR/t.IMGFMT
+
+=== Mapping non-sparse conversion ===
+
+Offset          Length          File
+0               0x100000        TEST_DIR/t.IMGFMT
+*** done
diff --git a/tests/qemu-iotests/151 b/tests/qemu-iotests/151
index ad7359fc8d..76ae265cc1 100755
--- a/tests/qemu-iotests/151
+++ b/tests/qemu-iotests/151
@@ -142,4 +142,5 @@ class TestActiveMirror(iotests.QMPTestCase):
 
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2', 'raw'])
+    iotests.main(supported_fmts=['qcow2', 'raw'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/152 b/tests/qemu-iotests/152
index fec546d033..732bf5f062 100755
--- a/tests/qemu-iotests/152
+++ b/tests/qemu-iotests/152
@@ -59,4 +59,5 @@ class TestUnaligned(iotests.QMPTestCase):
 
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['raw', 'qcow2'])
+    iotests.main(supported_fmts=['raw', 'qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/155 b/tests/qemu-iotests/155
index 63a5b5e2c0..e19485911c 100755
--- a/tests/qemu-iotests/155
+++ b/tests/qemu-iotests/155
@@ -258,4 +258,5 @@ BaseClass = None
 MirrorBaseClass = None
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/163 b/tests/qemu-iotests/163
index 158ba5d092..081ccc8ac1 100755
--- a/tests/qemu-iotests/163
+++ b/tests/qemu-iotests/163
@@ -170,4 +170,5 @@ class TestShrink1M(ShrinkBaseClass):
 ShrinkBaseClass = None
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['raw', 'qcow2'])
+    iotests.main(supported_fmts=['raw', 'qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/165 b/tests/qemu-iotests/165
index 88f62d3c6d..5650dc7c87 100755
--- a/tests/qemu-iotests/165
+++ b/tests/qemu-iotests/165
@@ -103,4 +103,5 @@ class TestPersistentDirtyBitmap(iotests.QMPTestCase):
         self.vm.shutdown()
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/169 b/tests/qemu-iotests/169
index 7e06cc1145..8c204caf20 100755
--- a/tests/qemu-iotests/169
+++ b/tests/qemu-iotests/169
@@ -227,4 +227,5 @@ for cmb in list(itertools.product((True, False), repeat=2)):
                      'do_test_migration_resume_source', *list(cmb))
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/175 b/tests/qemu-iotests/175
index 51e62c8276..7ba28b3c1b 100755
--- a/tests/qemu-iotests/175
+++ b/tests/qemu-iotests/175
@@ -37,14 +37,16 @@ trap "_cleanup; exit \$status" 0 1 2 3 15
 # the file size.  This function hides the resulting difference in the
 # stat -c '%b' output.
 # Parameter 1: Number of blocks an empty file occupies
-# Parameter 2: Image size in bytes
+# Parameter 2: Minimal number of blocks in an image
+# Parameter 3: Image size in bytes
 _filter_blocks()
 {
     extra_blocks=$1
-    img_size=$2
+    min_blocks=$2
+    img_size=$3
 
-    sed -e "s/blocks=$extra_blocks\\(\$\\|[^0-9]\\)/nothing allocated/" \
-        -e "s/blocks=$((extra_blocks + img_size / 512))\\(\$\\|[^0-9]\\)/everything allocated/"
+    sed -e "s/blocks=$min_blocks\\(\$\\|[^0-9]\\)/min allocation/" \
+        -e "s/blocks=$((extra_blocks + img_size / 512))\\(\$\\|[^0-9]\\)/max allocation/"
 }
 
 # get standard environment, filters and checks
@@ -60,16 +62,21 @@ size=$((1 * 1024 * 1024))
 touch "$TEST_DIR/empty"
 extra_blocks=$(stat -c '%b' "$TEST_DIR/empty")
 
+# We always write the first byte; check how many blocks this filesystem
+# allocates to match empty image alloation.
+printf "\0" > "$TEST_DIR/empty"
+min_blocks=$(stat -c '%b' "$TEST_DIR/empty")
+
 echo
 echo "== creating image with default preallocation =="
 _make_test_img $size | _filter_imgfmt
-stat -c "size=%s, blocks=%b" $TEST_IMG | _filter_blocks $extra_blocks $size
+stat -c "size=%s, blocks=%b" $TEST_IMG | _filter_blocks $extra_blocks $min_blocks $size
 
 for mode in off full falloc; do
     echo
     echo "== creating image with preallocation $mode =="
     IMGOPTS=preallocation=$mode _make_test_img $size | _filter_imgfmt
-    stat -c "size=%s, blocks=%b" $TEST_IMG | _filter_blocks $extra_blocks $size
+    stat -c "size=%s, blocks=%b" $TEST_IMG | _filter_blocks $extra_blocks $min_blocks $size
 done
 
 # success, all done
diff --git a/tests/qemu-iotests/175.out b/tests/qemu-iotests/175.out
index 6d9a5ed84e..263e521262 100644
--- a/tests/qemu-iotests/175.out
+++ b/tests/qemu-iotests/175.out
@@ -2,17 +2,17 @@ QA output created by 175
 
 == creating image with default preallocation ==
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048576
-size=1048576, nothing allocated
+size=1048576, min allocation
 
 == creating image with preallocation off ==
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048576 preallocation=off
-size=1048576, nothing allocated
+size=1048576, min allocation
 
 == creating image with preallocation full ==
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048576 preallocation=full
-size=1048576, everything allocated
+size=1048576, max allocation
 
 == creating image with preallocation falloc ==
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048576 preallocation=falloc
-size=1048576, everything allocated
+size=1048576, max allocation
  *** done
diff --git a/tests/qemu-iotests/178.out.qcow2 b/tests/qemu-iotests/178.out.qcow2
index 55a8dc926f..9e7d8c44df 100644
--- a/tests/qemu-iotests/178.out.qcow2
+++ b/tests/qemu-iotests/178.out.qcow2
@@ -101,7 +101,7 @@ converted image file size in bytes: 196608
 == raw input image with data (human) ==
 
 Formatting 'TEST_DIR/t.qcow2', fmt=IMGFMT size=1073741824
-required size: 393216
+required size: 458752
 fully allocated size: 1074135040
 wrote 512/512 bytes at offset 512
 512 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
@@ -257,7 +257,7 @@ converted image file size in bytes: 196608
 
 Formatting 'TEST_DIR/t.qcow2', fmt=IMGFMT size=1073741824
 {
-    "required": 393216,
+    "required": 458752,
     "fully-allocated": 1074135040
 }
 wrote 512/512 bytes at offset 512
diff --git a/tests/qemu-iotests/196 b/tests/qemu-iotests/196
index 4116ebc92b..92fe9244f8 100755
--- a/tests/qemu-iotests/196
+++ b/tests/qemu-iotests/196
@@ -63,4 +63,5 @@ class TestInvalidateAutoclear(iotests.QMPTestCase):
             self.assertEqual(f.read(1), b'\x00')
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'])
+    iotests.main(supported_fmts=['qcow2'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/199 b/tests/qemu-iotests/199
index 651e8df5d9..a2c8ecab5a 100755
--- a/tests/qemu-iotests/199
+++ b/tests/qemu-iotests/199
@@ -115,4 +115,5 @@ class TestDirtyBitmapPostcopyMigration(iotests.QMPTestCase):
         self.assert_qmp(result, 'return/sha256', sha256);
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['qcow2'], supported_cache_modes=['none'])
+    iotests.main(supported_fmts=['qcow2'], supported_cache_modes=['none'],
+                 supported_protocols=['file'])
diff --git a/tests/qemu-iotests/205 b/tests/qemu-iotests/205
index b8a86c446e..76f6c5fa2b 100755
--- a/tests/qemu-iotests/205
+++ b/tests/qemu-iotests/205
@@ -153,4 +153,5 @@ class TestNbdServerRemove(iotests.QMPTestCase):
 
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=['generic'])
+    iotests.main(supported_fmts=['raw'],
+                 supported_protocols=['nbd'])
diff --git a/tests/qemu-iotests/221.out b/tests/qemu-iotests/221.out
index 9f9dd52bb0..dca024a0c3 100644
--- a/tests/qemu-iotests/221.out
+++ b/tests/qemu-iotests/221.out
@@ -3,14 +3,18 @@ QA output created by 221
 === Check mapping of unaligned raw image ===
 
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=65537
-[{ "start": 0, "length": 66048, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
-[{ "start": 0, "length": 66048, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 61952, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 61952, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
 wrote 1/1 bytes at offset 65536
 1 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
-[{ "start": 0, "length": 65536, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 61440, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
 { "start": 65536, "length": 1, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
 { "start": 65537, "length": 511, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
-[{ "start": 0, "length": 65536, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 61440, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
 { "start": 65536, "length": 1, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
 { "start": 65537, "length": 511, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
 *** done
diff --git a/tests/qemu-iotests/245 b/tests/qemu-iotests/245
index bc1ceb9792..41218d5f1d 100644
--- a/tests/qemu-iotests/245
+++ b/tests/qemu-iotests/245
@@ -1000,4 +1000,5 @@ class TestBlockdevReopen(iotests.QMPTestCase):
         self.reopen(opts, {'backing': 'hd2'})
 
 if __name__ == '__main__':
-    iotests.main(supported_fmts=["qcow2"])
+    iotests.main(supported_fmts=["qcow2"],
+                 supported_protocols=["file"])
diff --git a/tests/qemu-iotests/253.out b/tests/qemu-iotests/253.out
index 607c0baa0b..3d08b305d7 100644
--- a/tests/qemu-iotests/253.out
+++ b/tests/qemu-iotests/253.out
@@ -3,12 +3,16 @@ QA output created by 253
 === Check mapping of unaligned raw image ===
 
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048575
-[{ "start": 0, "length": 1048576, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
-[{ "start": 0, "length": 1048576, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 1044480, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 1044480, "depth": 0, "zero": true, "data": false, "offset": OFFSET}]
 wrote 65535/65535 bytes at offset 983040
 63.999 KiB, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
-[{ "start": 0, "length": 983040, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 978944, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
 { "start": 983040, "length": 65536, "depth": 0, "zero": false, "data": true, "offset": OFFSET}]
-[{ "start": 0, "length": 983040, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
+[{ "start": 0, "length": 4096, "depth": 0, "zero": false, "data": true, "offset": OFFSET},
+{ "start": 4096, "length": 978944, "depth": 0, "zero": true, "data": false, "offset": OFFSET},
 { "start": 983040, "length": 65536, "depth": 0, "zero": false, "data": true, "offset": OFFSET}]
 *** done
diff --git a/tests/qemu-iotests/265 b/tests/qemu-iotests/265
new file mode 100755
index 0000000000..dce6f77be3
--- /dev/null
+++ b/tests/qemu-iotests/265
@@ -0,0 +1,67 @@
+#!/usr/bin/env bash
+#
+# Test reverse-ordered qcow2 writes on a sub-cluster level
+#
+# Copyright (C) 2019 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+seq=$(basename $0)
+echo "QA output created by $seq"
+
+status=1	# failure is the default!
+
+_cleanup()
+{
+    _cleanup_test_img
+}
+trap "_cleanup; exit \$status" 0 1 2 3 15
+
+# get standard environment, filters and checks
+. ./common.rc
+. ./common.filter
+
+# qcow2-specific test
+_supported_fmt qcow2
+_supported_proto file
+_supported_os Linux
+
+echo '--- Writing to the image ---'
+
+# Reduce cluster size so we get more and quicker I/O
+IMGOPTS='cluster_size=4096' _make_test_img 1M
+(for ((kb = 1024 - 4; kb >= 0; kb -= 4)); do \
+     echo "aio_write -P 42 $((kb + 1))k 2k"; \
+ done) \
+ | $QEMU_IO "$TEST_IMG" > /dev/null
+
+echo '--- Verifying its content ---'
+
+(for ((kb = 0; kb < 1024; kb += 4)); do \
+    echo "read -P 0 ${kb}k 1k"; \
+    echo "read -P 42 $((kb + 1))k 2k"; \
+    echo "read -P 0 $((kb + 3))k 1k"; \
+ done) \
+ | $QEMU_IO "$TEST_IMG" | _filter_qemu_io | grep 'verification'
+
+# Status of qemu-io
+if [ ${PIPESTATUS[1]} = 0 ]; then
+    echo 'Content verified.'
+fi
+
+# success, all done
+echo "*** done"
+rm -f $seq.full
+status=0
diff --git a/tests/qemu-iotests/265.out b/tests/qemu-iotests/265.out
new file mode 100644
index 0000000000..6eac620f25
--- /dev/null
+++ b/tests/qemu-iotests/265.out
@@ -0,0 +1,6 @@
+QA output created by 265
+--- Writing to the image ---
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=1048576
+--- Verifying its content ---
+Content verified.
+*** done
diff --git a/tests/qemu-iotests/266 b/tests/qemu-iotests/266
new file mode 100755
index 0000000000..5b35cd67e4
--- /dev/null
+++ b/tests/qemu-iotests/266
@@ -0,0 +1,153 @@
+#!/usr/bin/env python
+#
+# Test VPC and file image creation
+#
+# Copyright (C) 2019 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+import iotests
+from iotests import imgfmt
+
+
+def blockdev_create(vm, options):
+    result = vm.qmp_log('blockdev-create', job_id='job0', options=options,
+                        filters=[iotests.filter_qmp_testfiles])
+
+    if 'return' in result:
+        assert result['return'] == {}
+        vm.run_job('job0')
+
+
+# Successful image creation (defaults)
+def implicit_defaults(vm, file_path):
+    iotests.log("=== Successful image creation (defaults) ===")
+    iotests.log("")
+
+    # 8 heads, 964 cyls/head, 17 secs/cyl
+    # (Close to 64 MB)
+    size = 8 * 964 * 17 * 512
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': size })
+
+
+# Successful image creation (explicit defaults)
+def explicit_defaults(vm, file_path):
+    iotests.log("=== Successful image creation (explicit defaults) ===")
+    iotests.log("")
+
+    # 16 heads, 964 cyls/head, 17 secs/cyl
+    # (Close to 128 MB)
+    size = 16 * 964 * 17 * 512
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': size,
+                          'subformat': 'dynamic',
+                          'force-size': False })
+
+
+# Successful image creation (non-default options)
+def non_defaults(vm, file_path):
+    iotests.log("=== Successful image creation (non-default options) ===")
+    iotests.log("")
+
+    # Not representable in CHS (fine with force-size=True)
+    size = 1048576
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': size,
+                          'subformat': 'fixed',
+                          'force-size': True })
+
+
+# Size not representable in CHS with force-size=False
+def non_chs_size_without_force(vm, file_path):
+    iotests.log("=== Size not representable in CHS ===")
+    iotests.log("")
+
+    # Not representable in CHS (will not work with force-size=False)
+    size = 1048576
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': size,
+                          'force-size': False })
+
+
+# Zero size
+def zero_size(vm, file_path):
+    iotests.log("=== Zero size===")
+    iotests.log("")
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': 0 })
+
+
+# Maximum CHS size
+def maximum_chs_size(vm, file_path):
+    iotests.log("=== Maximum CHS size===")
+    iotests.log("")
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': 16 * 65535 * 255 * 512 })
+
+
+# Actual maximum size
+def maximum_size(vm, file_path):
+    iotests.log("=== Actual maximum size===")
+    iotests.log("")
+
+    blockdev_create(vm, { 'driver': imgfmt,
+                          'file': 'protocol-node',
+                          'size': 0xff000000 * 512,
+                          'force-size': True })
+
+
+def main():
+    for test_func in [implicit_defaults, explicit_defaults, non_defaults,
+                      non_chs_size_without_force, zero_size, maximum_chs_size,
+                      maximum_size]:
+
+        with iotests.FilePath('t.vpc') as file_path, \
+             iotests.VM() as vm:
+
+            vm.launch()
+
+            iotests.log('--- Creating empty file ---')
+            blockdev_create(vm, { 'driver': 'file',
+                                  'filename': file_path,
+                                  'size': 0 })
+
+            vm.qmp_log('blockdev-add', driver='file', filename=file_path,
+                       node_name='protocol-node',
+                       filters=[iotests.filter_qmp_testfiles])
+            iotests.log('')
+
+            print_info = test_func(vm, file_path)
+            iotests.log('')
+
+            vm.shutdown()
+            iotests.img_info_log(file_path)
+
+
+iotests.script_main(main,
+                    supported_fmts=['vpc'],
+                    supported_protocols=['file'])
diff --git a/tests/qemu-iotests/266.out b/tests/qemu-iotests/266.out
new file mode 100644
index 0000000000..b11953e81f
--- /dev/null
+++ b/tests/qemu-iotests/266.out
@@ -0,0 +1,137 @@
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Successful image creation (defaults) ===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "size": 67125248}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 64 MiB (67125248 bytes)
+cluster_size: 2097152
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Successful image creation (explicit defaults) ===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "force-size": false, "size": 134250496, "subformat": "dynamic"}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 128 MiB (134250496 bytes)
+cluster_size: 2097152
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Successful image creation (non-default options) ===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "force-size": true, "size": 1048576, "subformat": "fixed"}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 1 MiB (1048576 bytes)
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Size not representable in CHS ===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "force-size": false, "size": 1048576}}}
+{"return": {}}
+Job failed: The requested image size cannot be represented in CHS geometry
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+qemu-img: Could not open 'TEST_IMG': File too small for a VHD header
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Zero size===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 0 B (0 bytes)
+cluster_size: 2097152
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Maximum CHS size===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "size": 136899993600}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 127 GiB (136899993600 bytes)
+cluster_size: 2097152
+
+--- Creating empty file ---
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "size": 0}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+{"execute": "blockdev-add", "arguments": {"driver": "file", "filename": "TEST_DIR/PID-t.vpc", "node-name": "protocol-node"}}
+{"return": {}}
+
+=== Actual maximum size===
+
+{"execute": "blockdev-create", "arguments": {"job-id": "job0", "options": {"driver": "vpc", "file": "protocol-node", "force-size": true, "size": 2190433320960}}}
+{"return": {}}
+{"execute": "job-dismiss", "arguments": {"id": "job0"}}
+{"return": {}}
+
+image: TEST_IMG
+file format: IMGFMT
+virtual size: 1.99 TiB (2190433320960 bytes)
+cluster_size: 2097152
+
diff --git a/tests/qemu-iotests/267 b/tests/qemu-iotests/267
new file mode 100755
index 0000000000..d37a67c012
--- /dev/null
+++ b/tests/qemu-iotests/267
@@ -0,0 +1,168 @@
+#!/usr/bin/env bash
+#
+# Test which nodes are involved in internal snapshots
+#
+# Copyright (C) 2019 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+# creator
+owner=kwolf@redhat.com
+
+seq=`basename $0`
+echo "QA output created by $seq"
+
+status=1	# failure is the default!
+
+_cleanup()
+{
+    _cleanup_test_img
+    rm -f "$TEST_DIR/nbd"
+}
+trap "_cleanup; exit \$status" 0 1 2 3 15
+
+# get standard environment, filters and checks
+. ./common.rc
+. ./common.filter
+
+_supported_fmt qcow2
+_supported_proto file
+_supported_os Linux
+
+# Internal snapshots are (currently) impossible with refcount_bits=1
+_unsupported_imgopts 'refcount_bits=1[^0-9]'
+
+do_run_qemu()
+{
+    echo Testing: "$@"
+    (
+        if ! test -t 0; then
+            while read cmd; do
+                echo $cmd
+            done
+        fi
+        echo quit
+    ) | $QEMU -nographic -monitor stdio -nodefaults "$@"
+    echo
+}
+
+run_qemu()
+{
+    do_run_qemu "$@" 2>&1 | _filter_testdir | _filter_qemu | _filter_hmp |
+        _filter_generated_node_ids | _filter_imgfmt | _filter_vmstate_size
+}
+
+size=128M
+
+run_test()
+{
+    _make_test_img $size
+    printf "savevm snap0\ninfo snapshots\nloadvm snap0\n" | run_qemu "$@" | _filter_date
+}
+
+
+echo
+echo "=== No block devices at all ==="
+echo
+
+run_test
+
+echo
+echo "=== -drive if=none ==="
+echo
+
+run_test -drive driver=file,file="$TEST_IMG",if=none
+run_test -drive driver=$IMGFMT,file="$TEST_IMG",if=none
+run_test -drive driver=$IMGFMT,file="$TEST_IMG",if=none -device virtio-blk,drive=none0
+
+echo
+echo "=== -drive if=virtio ==="
+echo
+
+run_test -drive driver=file,file="$TEST_IMG",if=virtio
+run_test -drive driver=$IMGFMT,file="$TEST_IMG",if=virtio
+
+echo
+echo "=== Simple -blockdev ==="
+echo
+
+run_test -blockdev driver=file,filename="$TEST_IMG",node-name=file
+run_test -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=$IMGFMT,file=file,node-name=fmt
+run_test -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=raw,file=file,node-name=raw \
+         -blockdev driver=$IMGFMT,file=raw,node-name=fmt
+
+echo
+echo "=== -blockdev with a filter on top ==="
+echo
+
+run_test -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=$IMGFMT,file=file,node-name=fmt \
+         -blockdev driver=copy-on-read,file=fmt,node-name=filter
+
+echo
+echo "=== -blockdev with a backing file ==="
+echo
+
+TEST_IMG="$TEST_IMG.base" _make_test_img $size
+
+IMGOPTS="backing_file=$TEST_IMG.base" \
+run_test -blockdev driver=file,filename="$TEST_IMG.base",node-name=backing-file \
+         -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=$IMGFMT,file=file,backing=backing-file,node-name=fmt
+
+IMGOPTS="backing_file=$TEST_IMG.base" \
+run_test -blockdev driver=file,filename="$TEST_IMG.base",node-name=backing-file \
+         -blockdev driver=$IMGFMT,file=backing-file,node-name=backing-fmt \
+         -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=$IMGFMT,file=file,backing=backing-fmt,node-name=fmt
+
+# A snapshot should be present on the overlay, but not the backing file
+echo Internal snapshots on overlay:
+$QEMU_IMG snapshot -l "$TEST_IMG" | _filter_date | _filter_vmstate_size
+
+echo Internal snapshots on backing file:
+$QEMU_IMG snapshot -l "$TEST_IMG.base" | _filter_date | _filter_vmstate_size
+
+echo
+echo "=== -blockdev with NBD server on the backing file ==="
+echo
+
+IMGOPTS="backing_file=$TEST_IMG.base" _make_test_img $size
+cat <<EOF |
+nbd_server_start unix:$TEST_DIR/nbd
+nbd_server_add -w backing-fmt
+savevm snap0
+info snapshots
+loadvm snap0
+EOF
+run_qemu -blockdev driver=file,filename="$TEST_IMG.base",node-name=backing-file \
+         -blockdev driver=$IMGFMT,file=backing-file,node-name=backing-fmt \
+         -blockdev driver=file,filename="$TEST_IMG",node-name=file \
+         -blockdev driver=$IMGFMT,file=file,backing=backing-fmt,node-name=fmt |
+         _filter_date
+
+# This time, a snapshot should be created on both files
+echo Internal snapshots on overlay:
+$QEMU_IMG snapshot -l "$TEST_IMG" | _filter_date | _filter_vmstate_size
+
+echo Internal snapshots on backing file:
+$QEMU_IMG snapshot -l "$TEST_IMG.base" | _filter_date | _filter_vmstate_size
+
+# success, all done
+echo "*** done"
+rm -f $seq.full
+status=0
diff --git a/tests/qemu-iotests/267.out b/tests/qemu-iotests/267.out
new file mode 100644
index 0000000000..9d812e3c72
--- /dev/null
+++ b/tests/qemu-iotests/267.out
@@ -0,0 +1,182 @@
+QA output created by 267
+
+=== No block devices at all ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing:
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+Error: No block device can accept snapshots
+(qemu) info snapshots
+No available block device supports snapshots
+(qemu) loadvm snap0
+Error: No block device supports snapshots
+(qemu) quit
+
+
+=== -drive if=none ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -drive driver=file,file=TEST_DIR/t.IMGFMT,if=none
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+Error: Device 'none0' is writable but does not support snapshots
+(qemu) info snapshots
+No available block device supports snapshots
+(qemu) loadvm snap0
+Error: Device 'none0' is writable but does not support snapshots
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -drive driver=IMGFMT,file=TEST_DIR/t.IMGFMT,if=none
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -drive driver=IMGFMT,file=TEST_DIR/t.IMGFMT,if=none -device virtio-blk,drive=none0
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+
+=== -drive if=virtio ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -drive driver=file,file=TEST_DIR/t.IMGFMT,if=virtio
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+Error: Device 'virtio0' is writable but does not support snapshots
+(qemu) info snapshots
+No available block device supports snapshots
+(qemu) loadvm snap0
+Error: Device 'virtio0' is writable but does not support snapshots
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -drive driver=IMGFMT,file=TEST_DIR/t.IMGFMT,if=virtio
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+
+=== Simple -blockdev ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+Error: Device '' is writable but does not support snapshots
+(qemu) info snapshots
+No available block device supports snapshots
+(qemu) loadvm snap0
+Error: Device '' is writable but does not support snapshots
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=IMGFMT,file=file,node-name=fmt
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=raw,file=file,node-name=raw -blockdev driver=IMGFMT,file=raw,node-name=fmt
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+
+=== -blockdev with a filter on top ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=IMGFMT,file=file,node-name=fmt -blockdev driver=copy-on-read,file=fmt,node-name=filter
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+
+=== -blockdev with a backing file ===
+
+Formatting 'TEST_DIR/t.IMGFMT.base', fmt=IMGFMT size=134217728
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728 backing_file=TEST_DIR/t.IMGFMT.base
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT.base,node-name=backing-file -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=IMGFMT,file=file,backing=backing-file,node-name=fmt
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728 backing_file=TEST_DIR/t.IMGFMT.base
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT.base,node-name=backing-file -blockdev driver=IMGFMT,file=backing-file,node-name=backing-fmt -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=IMGFMT,file=file,backing=backing-fmt,node-name=fmt
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+Internal snapshots on overlay:
+Snapshot list:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+1         snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+Internal snapshots on backing file:
+
+=== -blockdev with NBD server on the backing file ===
+
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=134217728 backing_file=TEST_DIR/t.IMGFMT.base
+Testing: -blockdev driver=file,filename=TEST_DIR/t.IMGFMT.base,node-name=backing-file -blockdev driver=IMGFMT,file=backing-file,node-name=backing-fmt -blockdev driver=file,filename=TEST_DIR/t.IMGFMT,node-name=file -blockdev driver=IMGFMT,file=file,backing=backing-fmt,node-name=fmt
+QEMU X.Y.Z monitor - type 'help' for more information
+(qemu) nbd_server_start unix:TEST_DIR/nbd
+(qemu) nbd_server_add -w backing-fmt
+(qemu) savevm snap0
+(qemu) info snapshots
+List of snapshots present on all disks:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+--        snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+(qemu) loadvm snap0
+(qemu) quit
+
+Internal snapshots on overlay:
+Snapshot list:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+1         snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+Internal snapshots on backing file:
+Snapshot list:
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+1         snap0                  SIZE yyyy-mm-dd hh:mm:ss   00:00:00.000
+*** done
diff --git a/tests/qemu-iotests/270 b/tests/qemu-iotests/270
new file mode 100755
index 0000000000..b9a12b908c
--- /dev/null
+++ b/tests/qemu-iotests/270
@@ -0,0 +1,83 @@
+#!/usr/bin/env bash
+#
+# Test large write to a qcow2 image
+#
+# Copyright (C) 2019 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+seq=$(basename "$0")
+echo "QA output created by $seq"
+
+status=1	# failure is the default!
+
+_cleanup()
+{
+    _cleanup_test_img
+}
+trap "_cleanup; exit \$status" 0 1 2 3 15
+
+# get standard environment, filters and checks
+. ./common.rc
+. ./common.filter
+
+# This is a qcow2 regression test
+_supported_fmt qcow2
+_supported_proto file
+_supported_os Linux
+
+# We use our own external data file and our own cluster size, and we
+# require v3 images
+_unsupported_imgopts data_file cluster_size 'compat=0.10'
+
+
+# We need a backing file so that handle_alloc_space() will not do
+# anything.  (If it were to do anything, it would simply fail its
+# write-zeroes request because the request range is too large.)
+TEST_IMG="$TEST_IMG.base" _make_test_img 4G
+$QEMU_IO -c 'write 0 512' "$TEST_IMG.base" | _filter_qemu_io
+
+# (Use .orig because _cleanup_test_img will remove that file)
+# We need a large cluster size, see below for why (above the $QEMU_IO
+# invocation)
+_make_test_img -o cluster_size=2M,data_file="$TEST_IMG.orig" \
+    -b "$TEST_IMG.base" 4G
+
+# We want a null-co as the data file, because it allows us to quickly
+# "write" 2G of data without using any space.
+# (qemu-img create does not like it, though, because null-co does not
+# support image creation.)
+$QEMU_IMG amend -o data_file="json:{'driver':'null-co',,'size':'4294967296'}" \
+    "$TEST_IMG"
+
+# This gives us a range of:
+#   2^31 - 512 + 768 - 1 = 2^31 + 255 > 2^31
+# until the beginning of the end COW block.  (The total allocation
+# size depends on the cluster size, but all that is important is that
+# it exceeds INT_MAX.)
+#
+# 2^31 - 512 is the maximum request size.  We want this to result in a
+# single allocation, and because the qcow2 driver splits allocations
+# on L2 boundaries, we need large L2 tables; hence the cluster size of
+# 2 MB.  (Anything from 256 kB should work, though, because then one L2
+# table covers 8 GB.)
+$QEMU_IO -c "write 768 $((2 ** 31 - 512))" "$TEST_IMG" | _filter_qemu_io
+
+_check_test_img
+
+# success, all done
+echo "*** done"
+rm -f $seq.full
+status=0
diff --git a/tests/qemu-iotests/270.out b/tests/qemu-iotests/270.out
new file mode 100644
index 0000000000..c7be111014
--- /dev/null
+++ b/tests/qemu-iotests/270.out
@@ -0,0 +1,9 @@
+QA output created by 270
+Formatting 'TEST_DIR/t.IMGFMT.base', fmt=IMGFMT size=4294967296
+wrote 512/512 bytes at offset 0
+512 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=4294967296 backing_file=TEST_DIR/t.IMGFMT.base data_file=TEST_DIR/t.IMGFMT.orig
+wrote 2147483136/2147483136 bytes at offset 768
+2 GiB, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
+No errors were found on the image.
+*** done
diff --git a/tests/qemu-iotests/272 b/tests/qemu-iotests/272
new file mode 100755
index 0000000000..c2f782d47b
--- /dev/null
+++ b/tests/qemu-iotests/272
@@ -0,0 +1,79 @@
+#!/usr/bin/env bash
+#
+# Test compressed write to a qcow2 image at an offset above 4 GB
+#
+# Copyright (C) 2019 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+seq=$(basename "$0")
+echo "QA output created by $seq"
+
+status=1	# failure is the default!
+
+_cleanup()
+{
+    _cleanup_test_img
+}
+trap "_cleanup; exit \$status" 0 1 2 3 15
+
+# get standard environment, filters and checks
+. ./common.rc
+. ./common.filter
+
+# This is a qcow2 regression test
+_supported_fmt qcow2
+_supported_proto file
+
+# External data files do not support compression;
+# We need an exact cluster size (2M) and refcount width (2) so we can
+# get this test quickly over with; and this in turn require
+# compat=1.1
+_unsupported_imgopts data_file cluster_size refcount_bits 'compat=0.10'
+
+# The idea is: Create an empty file, mark the first 4 GB as used, then
+# do a compressed write that thus must be put beyond 4 GB.
+# (This used to fail because the compressed sector mask was just a
+# 32 bit mask, so qemu-img check will count a cluster before 4 GB as
+# referenced twice.)
+
+# We would like to use refcount_bits=1 here, but then qemu-img check
+# will throw an error when trying to count a cluster as referenced
+# twice.
+_make_test_img -o cluster_size=2M,refcount_bits=2 64M
+
+reft_offs=$(peek_file_be "$TEST_IMG" 48 8)
+refb_offs=$(peek_file_be "$TEST_IMG" $reft_offs 8)
+
+# We want to cover 4 GB, those are 2048 clusters, equivalent to
+# 4096 bit = 512 B.
+truncate -s 4G "$TEST_IMG"
+for ((in_refb_offs = 0; in_refb_offs < 512; in_refb_offs += 8)); do
+    poke_file "$TEST_IMG" $((refb_offs + in_refb_offs)) \
+        '\x55\x55\x55\x55\x55\x55\x55\x55'
+done
+
+$QEMU_IO -c 'write -c -P 42 0 2M' "$TEST_IMG" | _filter_qemu_io
+
+echo
+echo '--- Check ---'
+
+# This should only print the leaked clusters in the first 4 GB
+_check_test_img | grep -v '^Leaked cluster '
+
+# success, all done
+echo "*** done"
+rm -f $seq.full
+status=0
diff --git a/tests/qemu-iotests/272.out b/tests/qemu-iotests/272.out
new file mode 100644
index 0000000000..35698b0e73
--- /dev/null
+++ b/tests/qemu-iotests/272.out
@@ -0,0 +1,10 @@
+QA output created by 272
+Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=67108864
+wrote 2097152/2097152 bytes at offset 0
+2 MiB, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
+
+--- Check ---
+
+2044 leaked clusters were found on the image.
+This means waste of disk space, but no harm to data.
+*** done
diff --git a/tests/qemu-iotests/common.filter b/tests/qemu-iotests/common.filter
index 35fddc746f..67fd5f4e41 100644
--- a/tests/qemu-iotests/common.filter
+++ b/tests/qemu-iotests/common.filter
@@ -19,12 +19,15 @@
 # standard filters
 #
 
-# ctime(3) dates
-#
 _filter_date()
 {
-    $SED \
-        -e 's/[A-Z][a-z][a-z] [A-z][a-z][a-z]  *[0-9][0-9]* [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9]$/DATE/'
+    $SED -re 's/[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/yyyy-mm-dd hh:mm:ss/'
+}
+
+_filter_vmstate_size()
+{
+    $SED -r -e 's/[0-9. ]{5} [KMGT]iB/     SIZE/' \
+            -e 's/[0-9. ]{5} B/   SIZE/'
 }
 
 _filter_generated_node_ids()
diff --git a/tests/qemu-iotests/common.rc b/tests/qemu-iotests/common.rc
index 5502c3da2f..78decfd5d5 100644
--- a/tests/qemu-iotests/common.rc
+++ b/tests/qemu-iotests/common.rc
@@ -53,6 +53,26 @@ poke_file()
     printf "$3" | dd "of=$1" bs=1 "seek=$2" conv=notrunc &>/dev/null
 }
 
+# peek_file_le 'test.img' 512 2 => 65534
+peek_file_le()
+{
+    # Wrap in echo $() to strip spaces
+    echo $(od -j"$2" -N"$3" --endian=little -An -vtu"$3" "$1")
+}
+
+# peek_file_be 'test.img' 512 2 => 65279
+peek_file_be()
+{
+    # Wrap in echo $() to strip spaces
+    echo $(od -j"$2" -N"$3" --endian=big -An -vtu"$3" "$1")
+}
+
+# peek_file_raw 'test.img' 512 2 => '\xff\xfe'
+peek_file_raw()
+{
+    dd if="$1" bs=1 skip="$2" count="$3" status=none
+}
+
 
 if ! . ./common.config
     then
diff --git a/tests/qemu-iotests/group b/tests/qemu-iotests/group
index f13e5f2e23..3070d160d5 100644
--- a/tests/qemu-iotests/group
+++ b/tests/qemu-iotests/group
@@ -271,3 +271,8 @@
 254 rw backing quick
 255 rw quick
 256 rw quick
+265 rw auto quick
+266 rw quick
+267 rw auto quick snapshot
+270 rw backing quick
+272 rw
diff --git a/tests/qemu-iotests/iotests.py b/tests/qemu-iotests/iotests.py
index ce74177ab1..2f7edc2f33 100644
--- a/tests/qemu-iotests/iotests.py
+++ b/tests/qemu-iotests/iotests.py
@@ -61,7 +61,6 @@ cachemode = os.environ.get('CACHEMODE')
 qemu_default_machine = os.environ.get('QEMU_DEFAULT_MACHINE')
 
 socket_scm_helper = os.environ.get('SOCKET_SCM_HELPER', 'socket_scm_helper')
-debug = False
 
 luks_default_secret_object = 'secret,id=keysec0,data=' + \
                              os.environ.get('IMGKEYSECRET', '')
@@ -842,11 +841,23 @@ def skip_if_unsupported(required_formats=[], read_only=False):
         return func_wrapper
     return skip_test_decorator
 
-def main(supported_fmts=[], supported_oses=['linux'], supported_cache_modes=[],
-         unsupported_fmts=[]):
-    '''Run tests'''
+def execute_unittest(output, verbosity, debug):
+    runner = unittest.TextTestRunner(stream=output, descriptions=True,
+                                     verbosity=verbosity)
+    try:
+        # unittest.main() will use sys.exit(); so expect a SystemExit
+        # exception
+        unittest.main(testRunner=runner)
+    finally:
+        if not debug:
+            sys.stderr.write(re.sub(r'Ran (\d+) tests? in [\d.]+s',
+                                    r'Ran \1 tests', output.getvalue()))
 
-    global debug
+def execute_test(test_function=None,
+                 supported_fmts=[], supported_oses=['linux'],
+                 supported_cache_modes=[], unsupported_fmts=[],
+                 supported_protocols=[], unsupported_protocols=[]):
+    """Run either unittest or script-style tests."""
 
     # We are using TEST_DIR and QEMU_DEFAULT_MACHINE as proxies to
     # indicate that we're not being run via "check". There may be
@@ -859,6 +870,7 @@ def main(supported_fmts=[], supported_oses=['linux'], supported_cache_modes=[],
     debug = '-d' in sys.argv
     verbosity = 1
     verify_image_format(supported_fmts, unsupported_fmts)
+    verify_protocol(supported_protocols, unsupported_protocols)
     verify_platform(supported_oses)
     verify_cache_mode(supported_cache_modes)
 
@@ -878,13 +890,15 @@ def main(supported_fmts=[], supported_oses=['linux'], supported_cache_modes=[],
 
     logging.basicConfig(level=(logging.DEBUG if debug else logging.WARN))
 
-    class MyTestRunner(unittest.TextTestRunner):
-        def __init__(self, stream=output, descriptions=True, verbosity=verbosity):
-            unittest.TextTestRunner.__init__(self, stream, descriptions, verbosity)
+    if not test_function:
+        execute_unittest(output, verbosity, debug)
+    else:
+        test_function()
+
+def script_main(test_function, *args, **kwargs):
+    """Run script-style tests outside of the unittest framework"""
+    execute_test(test_function, *args, **kwargs)
 
-    # unittest.main() will use sys.exit() so expect a SystemExit exception
-    try:
-        unittest.main(testRunner=MyTestRunner)
-    finally:
-        if not debug:
-            sys.stderr.write(re.sub(r'Ran (\d+) tests? in [\d.]+s', r'Ran \1 tests', output.getvalue()))
+def main(*args, **kwargs):
+    """Run tests using the unittest framework"""
+    execute_test(None, *args, **kwargs)
diff --git a/tests/test-hbitmap.c b/tests/test-hbitmap.c
index 592d8219db..2be56d1597 100644
--- a/tests/test-hbitmap.c
+++ b/tests/test-hbitmap.c
@@ -423,7 +423,7 @@ static void test_hbitmap_granularity(TestHBitmapData *data,
     hbitmap_test_check(data, 0);
     hbitmap_test_set(data, 0, 3);
     g_assert_cmpint(hbitmap_count(data->hb), ==, 4);
-    hbitmap_test_reset(data, 0, 1);
+    hbitmap_test_reset(data, 0, 2);
     g_assert_cmpint(hbitmap_count(data->hb), ==, 2);
 }
 
diff --git a/tests/test-util-filemonitor.c b/tests/test-util-filemonitor.c
index 46e781c022..301cd2db61 100644
--- a/tests/test-util-filemonitor.c
+++ b/tests/test-util-filemonitor.c
@@ -45,6 +45,11 @@ typedef struct {
     const char *filedst;
     int64_t *watchid;
     int eventid;
+    /*
+     * Only valid with OP_EVENT - this event might be
+     * swapped with the next OP_EVENT
+     */
+    bool swapnext;
 } QFileMonitorTestOp;
 
 typedef struct {
@@ -98,6 +103,10 @@ qemu_file_monitor_test_handler(int64_t id,
     QFileMonitorTestData *data = opaque;
     QFileMonitorTestRecord *rec = g_new0(QFileMonitorTestRecord, 1);
 
+    if (debug) {
+        g_printerr("Queue event id %" PRIx64 " event %d file %s\n",
+                   id, event, filename);
+    }
     rec->id = id;
     rec->event = event;
     rec->filename = g_strdup(filename);
@@ -125,7 +134,8 @@ qemu_file_monitor_test_record_free(QFileMonitorTestRecord *rec)
  * to wait for the event to be queued for us.
  */
 static QFileMonitorTestRecord *
-qemu_file_monitor_test_next_record(QFileMonitorTestData *data)
+qemu_file_monitor_test_next_record(QFileMonitorTestData *data,
+                                   QFileMonitorTestRecord *pushback)
 {
     GTimer *timer = g_timer_new();
     QFileMonitorTestRecord *record = NULL;
@@ -139,9 +149,15 @@ qemu_file_monitor_test_next_record(QFileMonitorTestData *data)
     }
     if (data->records) {
         record = data->records->data;
-        tmp = data->records;
-        data->records = g_list_remove_link(data->records, tmp);
-        g_list_free(tmp);
+        if (pushback) {
+            data->records->data = pushback;
+        } else {
+            tmp = data->records;
+            data->records = g_list_remove_link(data->records, tmp);
+            g_list_free(tmp);
+        }
+    } else if (pushback) {
+        qemu_file_monitor_test_record_free(pushback);
     }
     qemu_mutex_unlock(&data->lock);
 
@@ -158,13 +174,15 @@ static bool
 qemu_file_monitor_test_expect(QFileMonitorTestData *data,
                               int64_t id,
                               QFileMonitorEvent event,
-                              const char *filename)
+                              const char *filename,
+                              bool swapnext)
 {
     QFileMonitorTestRecord *rec;
     bool ret = false;
 
-    rec = qemu_file_monitor_test_next_record(data);
+    rec = qemu_file_monitor_test_next_record(data, NULL);
 
+ retry:
     if (!rec) {
         g_printerr("Missing event watch id %" PRIx64 " event %d file %s\n",
                    id, event, filename);
@@ -172,6 +190,11 @@ qemu_file_monitor_test_expect(QFileMonitorTestData *data,
     }
 
     if (id != rec->id) {
+        if (swapnext) {
+            rec = qemu_file_monitor_test_next_record(data, rec);
+            swapnext = false;
+            goto retry;
+        }
         g_printerr("Expected watch id %" PRIx64 " but got %" PRIx64 "\n",
                    id, rec->id);
         goto cleanup;
@@ -347,7 +370,8 @@ test_file_monitor_events(void)
           .filesrc = "fish", },
         { .type = QFILE_MONITOR_TEST_OP_EVENT,
           .filesrc = "", .watchid = &watch4,
-          .eventid = QFILE_MONITOR_EVENT_IGNORED },
+          .eventid = QFILE_MONITOR_EVENT_IGNORED,
+          .swapnext = true },
         { .type = QFILE_MONITOR_TEST_OP_EVENT,
           .filesrc = "fish", .watchid = &watch0,
           .eventid = QFILE_MONITOR_EVENT_DELETED },
@@ -493,8 +517,9 @@ test_file_monitor_events(void)
                 g_printerr("Event id=%" PRIx64 " event=%d file=%s\n",
                            *op->watchid, op->eventid, op->filesrc);
             }
-            if (!qemu_file_monitor_test_expect(
-                    &data, *op->watchid, op->eventid, op->filesrc))
+            if (!qemu_file_monitor_test_expect(&data, *op->watchid,
+                                               op->eventid, op->filesrc,
+                                               op->swapnext))
                 goto cleanup;
             break;
         case QFILE_MONITOR_TEST_OP_CREATE:
diff --git a/ui/cocoa.m b/ui/cocoa.m
index c2984028c5..3026ead621 100644
--- a/ui/cocoa.m
+++ b/ui/cocoa.m
@@ -132,6 +132,7 @@ NSArray * supportedImageFileTypes;
 
 static QemuSemaphore display_init_sem;
 static QemuSemaphore app_started_sem;
+static bool allow_events;
 
 // Utility functions to run specified code block with iothread lock held
 typedef void (^CodeBlock)(void);
@@ -727,6 +728,16 @@ QemuCocoaView *cocoaView;
 
 - (bool) handleEvent:(NSEvent *)event
 {
+    if(!allow_events) {
+        /*
+         * Just let OSX have all events that arrive before
+         * applicationDidFinishLaunching.
+         * This avoids a deadlock on the iothread lock, which cocoa_display_init()
+         * will not drop until after the app_started_sem is posted. (In theory
+         * there should not be any such events, but OSX Catalina now emits some.)
+         */
+        return false;
+    }
     return bool_with_iothread_lock(^{
         return [self handleEventLocked:event];
     });
@@ -1154,6 +1165,7 @@ QemuCocoaView *cocoaView;
 - (void)applicationDidFinishLaunching: (NSNotification *) note
 {
     COCOA_DEBUG("QemuCocoaAppController: applicationDidFinishLaunching\n");
+    allow_events = true;
     /* Tell cocoa_display_init to proceed */
     qemu_sem_post(&app_started_sem);
 }
diff --git a/util/hbitmap.c b/util/hbitmap.c
index bcc0acdc6a..c059313b9e 100644
--- a/util/hbitmap.c
+++ b/util/hbitmap.c
@@ -387,6 +387,10 @@ void hbitmap_set(HBitmap *hb, uint64_t start, uint64_t count)
     uint64_t first, n;
     uint64_t last = start + count - 1;
 
+    if (count == 0) {
+        return;
+    }
+
     trace_hbitmap_set(hb, start, count,
                       start >> hb->granularity, last >> hb->granularity);
 
@@ -476,6 +480,14 @@ void hbitmap_reset(HBitmap *hb, uint64_t start, uint64_t count)
     /* Compute range in the last layer.  */
     uint64_t first;
     uint64_t last = start + count - 1;
+    uint64_t gran = 1ULL << hb->granularity;
+
+    if (count == 0) {
+        return;
+    }
+
+    assert(QEMU_IS_ALIGNED(start, gran));
+    assert(QEMU_IS_ALIGNED(count, gran) || (start + count == hb->orig_size));
 
     trace_hbitmap_reset(hb, start, count,
                         start >> hb->granularity, last >> hb->granularity);
diff --git a/util/iov.c b/util/iov.c
index 74e6ca8ed7..9ac0261853 100644
--- a/util/iov.c
+++ b/util/iov.c
@@ -354,34 +354,143 @@ void qemu_iovec_concat(QEMUIOVector *dst,
 }
 
 /*
- * Check if the contents of the iovecs are all zero
+ * qiov_find_iov
+ *
+ * Return pointer to iovec structure, where byte at @offset in original vector
+ * @iov exactly is.
+ * Set @remaining_offset to be offset inside that iovec to the same byte.
  */
-bool qemu_iovec_is_zero(QEMUIOVector *qiov)
+static struct iovec *iov_skip_offset(struct iovec *iov, size_t offset,
+                                     size_t *remaining_offset)
 {
-    int i;
-    for (i = 0; i < qiov->niov; i++) {
-        size_t offs = QEMU_ALIGN_DOWN(qiov->iov[i].iov_len, 4 * sizeof(long));
-        uint8_t *ptr = qiov->iov[i].iov_base;
-        if (offs && !buffer_is_zero(qiov->iov[i].iov_base, offs)) {
+    while (offset > 0 && offset >= iov->iov_len) {
+        offset -= iov->iov_len;
+        iov++;
+    }
+    *remaining_offset = offset;
+
+    return iov;
+}
+
+/*
+ * qiov_slice
+ *
+ * Find subarray of iovec's, containing requested range. @head would
+ * be offset in first iov (returned by the function), @tail would be
+ * count of extra bytes in last iovec (returned iov + @niov - 1).
+ */
+static struct iovec *qiov_slice(QEMUIOVector *qiov,
+                                size_t offset, size_t len,
+                                size_t *head, size_t *tail, int *niov)
+{
+    struct iovec *iov, *end_iov;
+
+    assert(offset + len <= qiov->size);
+
+    iov = iov_skip_offset(qiov->iov, offset, head);
+    end_iov = iov_skip_offset(iov, *head + len, tail);
+
+    if (*tail > 0) {
+        assert(*tail < end_iov->iov_len);
+        *tail = end_iov->iov_len - *tail;
+        end_iov++;
+    }
+
+    *niov = end_iov - iov;
+
+    return iov;
+}
+
+/*
+ * Compile new iovec, combining @head_buf buffer, sub-qiov of @mid_qiov,
+ * and @tail_buf buffer into new qiov.
+ */
+void qemu_iovec_init_extended(
+        QEMUIOVector *qiov,
+        void *head_buf, size_t head_len,
+        QEMUIOVector *mid_qiov, size_t mid_offset, size_t mid_len,
+        void *tail_buf, size_t tail_len)
+{
+    size_t mid_head, mid_tail;
+    int total_niov, mid_niov = 0;
+    struct iovec *p, *mid_iov;
+
+    if (mid_len) {
+        mid_iov = qiov_slice(mid_qiov, mid_offset, mid_len,
+                             &mid_head, &mid_tail, &mid_niov);
+    }
+
+    total_niov = !!head_len + mid_niov + !!tail_len;
+    if (total_niov == 1) {
+        qemu_iovec_init_buf(qiov, NULL, 0);
+        p = &qiov->local_iov;
+    } else {
+        qiov->niov = qiov->nalloc = total_niov;
+        qiov->size = head_len + mid_len + tail_len;
+        p = qiov->iov = g_new(struct iovec, qiov->niov);
+    }
+
+    if (head_len) {
+        p->iov_base = head_buf;
+        p->iov_len = head_len;
+        p++;
+    }
+
+    if (mid_len) {
+        memcpy(p, mid_iov, mid_niov * sizeof(*p));
+        p[0].iov_base = (uint8_t *)p[0].iov_base + mid_head;
+        p[0].iov_len -= mid_head;
+        p[mid_niov - 1].iov_len -= mid_tail;
+        p += mid_niov;
+    }
+
+    if (tail_len) {
+        p->iov_base = tail_buf;
+        p->iov_len = tail_len;
+    }
+}
+
+/*
+ * Check if the contents of subrange of qiov data is all zeroes.
+ */
+bool qemu_iovec_is_zero(QEMUIOVector *qiov, size_t offset, size_t bytes)
+{
+    struct iovec *iov;
+    size_t current_offset;
+
+    assert(offset + bytes <= qiov->size);
+
+    iov = iov_skip_offset(qiov->iov, offset, &current_offset);
+
+    while (bytes) {
+        uint8_t *base = (uint8_t *)iov->iov_base + current_offset;
+        size_t len = MIN(iov->iov_len - current_offset, bytes);
+
+        if (!buffer_is_zero(base, len)) {
             return false;
         }
-        for (; offs < qiov->iov[i].iov_len; offs++) {
-            if (ptr[offs]) {
-                return false;
-            }
-        }
+
+        current_offset = 0;
+        bytes -= len;
+        iov++;
     }
+
     return true;
 }
 
+void qemu_iovec_init_slice(QEMUIOVector *qiov, QEMUIOVector *source,
+                           size_t offset, size_t len)
+{
+    qemu_iovec_init_extended(qiov, NULL, 0, source, offset, len, NULL, 0);
+}
+
 void qemu_iovec_destroy(QEMUIOVector *qiov)
 {
-    assert(qiov->nalloc != -1);
+    if (qiov->nalloc != -1) {
+        g_free(qiov->iov);
+    }
 
-    qemu_iovec_reset(qiov);
-    g_free(qiov->iov);
-    qiov->nalloc = 0;
-    qiov->iov = NULL;
+    memset(qiov, 0, sizeof(*qiov));
 }
 
 void qemu_iovec_reset(QEMUIOVector *qiov)
